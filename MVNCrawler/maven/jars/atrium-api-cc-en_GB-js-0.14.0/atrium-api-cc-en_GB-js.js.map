{"version":3,"file":"atrium-api-cc-en_GB-js.js","sources":["../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/AssertImpl.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/anyAssertionsBuilders.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/ExpectImpl.kt","../../../../../kbox-common/src/main/kotlin/ch/tutteli/kbox/varargToList.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/charSequenceAssertionsBuilders.kt","generated/_Collections.kt","text/regex/RegexExtensions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/FeatureAssertionsBuilder.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/iterableAssertionsBuilders.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/throwableAssertionsBuilders.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/anyAssertions.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/arrayAssertions.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/charSequenceAssertions.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/charSequenceContainsCheckers.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/charSequenceContainsCreators.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/charSequenceContainsSearchBehaviours.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/collectionAssertions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/CollectionAssertionsBuilder.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/comparableAssertions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/ComparableAssertionsBuilder.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/charsequence/contains/builders/impl/AtLeastCheckerOptionImpl.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/charsequence/contains/builders/impl/AtMostCheckerOptionImpl.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/charsequence/contains/builders/impl/ButAtMostCheckerOptionImpl.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/charsequence/contains/builders/impl/ExactlyCheckerOptionImpl.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/charsequence/contains/builders/impl/NotCheckerOptionImpl.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/charsequence/contains/builders/impl/NotOrAtMostCheckerOptionImpl.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/charsequence/contains/builders/impl/nameContainsNotFun.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/iterable/contains/builders/impl/AtLeastCheckerOptionImpl.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/iterable/contains/builders/impl/AtMostCheckerOptionImpl.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/iterable/contains/builders/impl/ButAtMostCheckerOptionImpl.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/iterable/contains/builders/impl/ExactlyCheckerOptionImpl.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/iterable/contains/builders/impl/NotCheckerOptionImpl.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/iterable/contains/builders/impl/NotOrAtMostCheckerOptionImpl.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/iterable/contains/builders/impl/nameContainsNotFun.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/featureAssertions.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/floatingPointAssertions.kt","../../../../src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/FloatingPointAssertionsBuilder.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/iterableAssertions.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/iterableContainsCheckers.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/iterableContainsInAnyOrderCreators.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/iterableContainsInAnyOrderOnlyCreators.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/iterableContainsInOrderOnlyCreators.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/iterableContainsInOrderOnlyGroupedCreators.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/iterableContainsSearchBehaviours.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/listAssertions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/ListAssertionsBuilder.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/mapAssertions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/MapAssertionsBuilder.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/mapEntryAssertions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/MapEntryAssertionsBuilder.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/pairAssertions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/PairAssertionsBuilder.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/parameterObjects.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/sequenceAssertions.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/throwableAssertions.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/typeTransformationAssertions.kt"],"sourcesContent":["@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n\npackage ch.tutteli.atrium.domain.builders\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.assertions.builders.AssertionBuilder\nimport ch.tutteli.atrium.assertions.builders.assertionBuilder\nimport ch.tutteli.atrium.core.CoreFactory\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.BaseAssertionPlant\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.builders.creating.*\nimport ch.tutteli.atrium.domain.builders.creating.collectors.AssertionCollectorBuilder\nimport ch.tutteli.atrium.domain.creating.*\nimport ch.tutteli.atrium.domain.creating.changers.subjectChanger\nimport ch.tutteli.atrium.domain.creating.collectors.AssertionCollector\n\n/**\n * Bundles different domain objects which are defined by the module atrium-domain-api\n * to give users of Atrium a fluent API as well.\n */\n@Suppress(\"OVERRIDE_BY_INLINE\")\n@Deprecated(\"Switch from AssertImpl to ExpectImpl (as well as from Assert to Expect); will be removed with 1.0.0\", ReplaceWith(\"ExpectImpl\"))\nobject AssertImpl : AssertImplCommon {\n\n    override inline val builder get() = assertionBuilder\n\n    override inline val collector get() = AssertionCollectorBuilder\n\n    @Deprecated(\"Switch from AssertImpl.coreFactory to coreFactory; will be removed with 1.0.0\", ReplaceWith(\"ch.tutteli.atrium.core.coreFactory\", \"ch.tutteli.atrium.core.coreFactory\"))\n    override inline val coreFactory get() = ch.tutteli.atrium.core.coreFactory\n\n\n    //--- assertions ---------------------------------------------------------------------------\n\n    override inline val any get() = AnyAssertionsBuilder\n\n    override inline val charSequence get() = CharSequenceAssertionsBuilder\n\n    override inline val collection get() = CollectionAssertionsBuilder\n\n    override inline val comparable get() = ComparableAssertionsBuilder\n\n    @Suppress(\"DEPRECATION\")\n    override inline val feature get() = FeatureAssertionsBuilder\n\n    override inline val floatingPoint get() = FloatingPointAssertionsBuilder\n\n    override inline val iterable get() = IterableAssertionsBuilder\n\n    override inline val list get() = ListAssertionsBuilder\n\n    override inline val map get() = MapAssertionsBuilder\n\n    override inline val pair get() = PairAssertionsBuilder\n\n    override inline val throwable get() = ThrowableAssertionsBuilder\n}\n\n@Deprecated(\"Switch from AssertImplCommon to ExpectImplCommon (as well as from Assert to Expect); will be removed with 1.0.0\")\ninterface AssertImplCommon {\n\n    /**\n     * Returns [AssertionBuilder] - helping you creating [Assertion]s.\n     * In detail, its an `inline` property which returns [ch.tutteli.atrium.assertions.builders.assertionBuilder]\n     * which in turn returns an implementation of [AssertionBuilder].\n     */\n    val builder: AssertionBuilder\n\n    /**\n     * Returns [AssertionCollectorBuilder] - helping you to collect feature assertions.\n     * which inter alia delegates to the implementation of [AssertionCollector].\n     */\n    val collector: AssertionCollectorBuilder\n\n    /**\n     * Returns the implementation of [CoreFactory].\n     * In detail, its an `inline` property which returns [ch.tutteli.atrium.core.coreFactory]\n     * which in turn delegates to the implementation via [loadSingleService].\n     */\n    val coreFactory: CoreFactory\n\n    /**\n     * Creates a new [AssertionPlant] based on the given [subjectProvider] whereas the [AssertionPlant] delegates\n     * assertion checking to the given [originalPlant].\n     *\n     * This method is useful if you want to make feature assertion(s) but you do not want that the feature is shown up\n     * in reporting. For instance, if a class can behave as another class (e.g. `Sequence::asIterable`) or you want to\n     * hide a conversion (e.g. `Int::toChar`) then you can use this function.\n     *\n     * Notice, if you do not require the resulting [AssertionPlant] but merely want to make feature assertions so that\n     * you can use them as part of a bigger assertion, then use [collector] instead.\n     */\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\n        \"Use ExpectImpl.changeSubject.unreported; will be removed with 1.0.0 - moreover we advice you to switch to Expect and no longer use Assert\",\n        ReplaceWith(\n            \"ExpectImpl.changeSubject(originalPlant, subjectProvider).unreported\",\n            \"import ch.tutteli.atrium.domain.builders.ExpectImpl\"\n        )\n    )\n    fun <T, R : Any> changeSubject(\n        originalPlant: BaseAssertionPlant<T, *>,\n        subjectProvider: () -> R\n    ): AssertionPlant<R> = subjectChanger.unreportedToAssert(originalPlant) { subjectProvider() }\n\n    @Deprecated(\n        \"Use ExpectImpl.changeSubject.unreported - this method was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\",\n        ReplaceWith(\n            \"ExpectImpl.changeSubject(originalAssertionCreator, transformation).unreported\",\n            \"import ch.tutteli.atrium.domain.builders.ExpectImpl\"\n        )\n    )\n    fun <T, R : Any> changeSubject(\n        originalAssertionCreator: Expect<T>,\n        transformation: (T) -> R\n    ): Expect<R> = subjectChanger.unreported(originalAssertionCreator, transformation)\n\n    /**\n     * Creates a new [AssertionPlantNullable] based on the given [subjectProvider] whereas the [AssertionPlant]\n     * delegates assertion checking to the given [originalPlant].\n     *\n     * This method is useful if you want to make feature assertion(s) but you do not want that the feature is shown up\n     * in reporting. For instance, if a class can behave as another class (e.g. `Sequence::asIterable`) or you want to\n     * hide a conversion (e.g. `Int::toChar`) then you can use this function.\n     *\n     * Notice, if you do not require the resulting [AssertionPlantNullable] but merely want to make feature\n     * assertions so that you can use them as part of a bigger assertion, then use [collector] instead.\n     */\n    @Deprecated(\n        \"Use ExpectImpl.changeSubject.unreported; will be removed with 1.0.0 - moreover we advice you to switch to Expect and no longer use Assert\",\n        ReplaceWith(\n            \"ExpectImpl.changeSubject(originalPlant, subjectProvider).unreported\",\n            \"import ch.tutteli.atrium.domain.builders.ExpectImpl\"\n        )\n    )\n    fun <T, R> changeToNullableSubject(\n        originalPlant: BaseAssertionPlant<T, *>,\n        subjectProvider: () -> R\n    ): AssertionPlantNullable<R> = subjectChanger.unreportedNullableToAssert(originalPlant) { subjectProvider() }\n\n    @Deprecated(\n        \"Use ExpectImpl.changeSubject.unreported - this method was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\",\n        ReplaceWith(\n            \"ExpectImpl.changeSubject(originalAssertionCreator, transformation).unreported\",\n            \"import ch.tutteli.atrium.domain.builders.ExpectImpl\"\n        )\n    )\n    fun <T, R : Any> changeToNullableSubject(\n        originalAssertionCreator: Expect<T>,\n        transformation: (T) -> R\n    ): Expect<R> = changeSubject(originalAssertionCreator, transformation)\n\n    //--- assertions ---------------------------------------------------------------------------\n\n    /**\n     * Returns [AnyAssertionsBuilder]\n     * which inter alia delegates to the implementation of [AnyAssertions].\n     */\n    @Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\n    val any: AnyAssertionsBuilder\n\n    /**\n     * Returns [CharSequenceAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CharSequenceAssertions].\n     */\n    @Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\n    val charSequence: CharSequenceAssertionsBuilder\n\n    /**\n     * Returns [CollectionAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CollectionAssertions].\n     */\n    @Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\n    val collection: CollectionAssertionsBuilder\n\n    /**\n     * Returns [ComparableAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ComparableAssertions].\n     */\n    @Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\n    val comparable: ComparableAssertionsBuilder\n\n    /**\n     * Returns [FeatureAssertionsBuilder]\n     * which inter alia delegates to the implementation of [FeatureAssertions].\n     */\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\n    val feature: FeatureAssertionsBuilder\n\n    /**\n     * Returns [FloatingPointAssertionsBuilder] - [Assertion]s applicable to [Float], [Double]\n     * and maybe more - which inter alia delegates to the implementation of [FloatingPointAssertions].\n     */\n    @Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\n    val floatingPoint: FloatingPointAssertionsBuilder\n\n    /**\n     * Returns [IterableAssertionsBuilder].\n     * which inter alia delegates to the implementation of [IterableAssertions].\n     */\n    @Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\n    val iterable: IterableAssertionsBuilder\n\n    /**\n     * Returns [ListAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ListAssertions].\n     */\n    @Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\n    val list: ListAssertionsBuilder\n\n    /**\n     * Returns [MapAssertionsBuilder]\n     * which inter alia delegates to the implementation of [MapAssertions].\n     */\n    @Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\n    val map: MapAssertionsBuilder\n\n    /**\n     * Returns [PairAssertionsBuilder]\n     * which inter alia delegates to the implementation of [PairAssertions].\n     */\n    @Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\n    val pair: PairAssertionsBuilder\n\n    /**\n     * Returns [ThrowableAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ThrowableAssertions].\n     */\n    @Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\n    val throwable: ThrowableAssertionsBuilder\n}\n","//TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.*\nimport ch.tutteli.atrium.domain.creating.AnyAssertions\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.AnyTypeTransformation\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.creators.AnyTypeTransformationAssertions\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.creators.anyTypeTransformationAssertions\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.failurehandlers.FailureHandlerFactory\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.failurehandlers.failureHandlerFactory\nimport ch.tutteli.atrium.domain.creating.anyAssertions\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport kotlin.reflect.KClass\n\n/**\n * Delegates inter alia to the implementation of [AnyAssertions].\n * In detail, it implements [AnyAssertions] by delegating to [anyAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\nobject AnyAssertionsBuilder : AnyAssertions {\n\n    override inline fun <T> toBe(subjectProvider: SubjectProvider<T>, expected: T): Assertion =\n        anyAssertions.toBe(subjectProvider, expected)\n\n    override inline fun <T> notToBe(subjectProvider: SubjectProvider<T>, expected: T) =\n        anyAssertions.notToBe(subjectProvider, expected)\n\n    override inline fun <T> isSame(subjectProvider: SubjectProvider<T>, expected: T) =\n        anyAssertions.isSame(subjectProvider, expected)\n\n    override inline fun <T> isNotSame(subjectProvider: SubjectProvider<T>, expected: T) =\n        anyAssertions.isNotSame(subjectProvider, expected)\n\n    override inline fun <T> toBeNull(subjectProvider: SubjectProvider<T>) =\n        anyAssertions.toBeNull(subjectProvider)\n\n    override inline fun <T : Any> toBeNullIfNullGivenElse(\n        expect: Expect<T?>,\n        type: KClass<T>,\n        noinline assertionCreatorOrNull: (Expect<T>.() -> Unit)?\n    ) = anyAssertions.toBeNullIfNullGivenElse(expect, type, assertionCreatorOrNull)\n\n    override inline fun <T, TSub : Any> isA(expect: Expect<T>, subType: KClass<TSub>) =\n        anyAssertions.isA(expect, subType)\n\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect and use toBeNullable; will be removed with 1.0.0\")\n    override inline fun <T : Any> isNullable(plant: AssertionPlantNullable<T?>, type: KClass<T>, expectedOrNull: T?) =\n        anyAssertions.isNullable(plant, type, expectedOrNull)\n\n\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect and use toBeNullable; will be removed with 1.0.0\")\n    override inline fun <T : Any> isNotNull(\n        plant: AssertionPlantNullable<T?>,\n        type: KClass<T>,\n        noinline assertionCreator: AssertionPlant<T>.() -> Unit\n    ) = anyAssertions.isNotNull(plant, type, assertionCreator)\n\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect and use toBeNullable; will be removed with 1.0.0\")\n    override inline fun <T : Any> isNotNullBut(plant: AssertionPlantNullable<T?>, type: KClass<T>, expected: T) =\n        anyAssertions.isNotNullBut(plant, type, expected)\n\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect and use toBeNullable; will be removed with 1.0.0\")\n    override inline fun <T : Any> isNullIfNullGivenElse(\n        plant: AssertionPlantNullable<T?>,\n        type: KClass<T>,\n        noinline assertionCreatorOrNull: (AssertionPlant<T>.() -> Unit)?\n    ) = anyAssertions.isNullIfNullGivenElse(plant, type, assertionCreatorOrNull)\n\n\n    /**\n     * Returns [AnyTypeTransformationAssertionsBuilder]\n     * which inter alia delegates to the implementation of [AnyTypeTransformationAssertions].\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from `Assert` to `Expect` use `ExpectImpl.changeSubject` or `ExpectImpl.feature.extract` instead; will be removed with 1.0.0\")\n    inline val typeTransformation\n        get() = AnyTypeTransformationAssertionsBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [AnyTypeTransformationAssertions].\n * In detail, it implements [AnyTypeTransformationAssertions] by delegating to [anyTypeTransformationAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Switch from `Assert` to `Expect` and use `ExpectImpl` instead; will be removed with 1.0.0\")\nobject AnyTypeTransformationAssertionsBuilder : AnyTypeTransformationAssertions {\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\n        \"This function will be removed in v.1.0.0 in favour of AssertImpl.any.isNotNull\", ReplaceWith(\n            \"plant.addAssertion(AssertImpl.any.isNotNull(plant, type, assertionCreator))\",\n            \"ch.tutteli.atrium.domain.builders.AssertImpl\"\n        )\n    )\n    override inline fun <T : Any> isNotNull(\n        plant: AssertionPlantNullable<T?>,\n        type: KClass<T>,\n        noinline assertionCreator: AssertionPlant<T>.() -> Unit\n    ) = anyTypeTransformationAssertions.isNotNull(plant, type, assertionCreator)\n\n    override inline fun <TSub : Any> isA(\n        plant: AssertionPlant<Any>,\n        subType: KClass<TSub>,\n        noinline assertionCreator: AssertionPlant<TSub>.() -> Unit\n    ) = anyTypeTransformationAssertions.isA(plant, subType, assertionCreator)\n\n    override inline fun <T : Any, TSub : T> downCast(\n        description: Translatable,\n        subType: KClass<TSub>,\n        subjectPlant: BaseAssertionPlant<T?, *>,\n        noinline assertionCreator: AssertionPlant<TSub>.() -> Unit,\n        failureHandler: AnyTypeTransformation.FailureHandler<T, TSub>\n    ) = anyTypeTransformationAssertions.downCast(description, subType, subjectPlant, assertionCreator, failureHandler)\n\n    override inline fun <S : Any, T : Any> transform(\n        parameterObject: AnyTypeTransformation.ParameterObject<S, T>,\n        noinline canBeTransformed: (S) -> Boolean,\n        noinline transform: (S) -> T,\n        failureHandler: AnyTypeTransformation.FailureHandler<S, T>\n    ) = anyTypeTransformationAssertions.transform(parameterObject, canBeTransformed, transform, failureHandler)\n\n    /**\n     * Returns [AnyTypeTransformationFailureHandlerFactoryBuilder]\n     * which inter alia delegates to the implementation of [FailureHandlerFactory].\n     */\n    inline val failureHandlers get() = AnyTypeTransformationFailureHandlerFactoryBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [FailureHandlerFactory].\n * In detail, it implements [FailureHandlerFactory] by delegating to [failureHandlerFactory]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Switch from `Assert` to `Expect` and use `ExpectImpl` instead; will be removed with 1.0.0\")\nobject AnyTypeTransformationFailureHandlerFactoryBuilder : FailureHandlerFactory {\n\n    override inline fun <S : Any, T : Any> newExplanatory() = failureHandlerFactory.newExplanatory<S, T>()\n\n    override inline fun <S : Any, T : Any> newExplanatoryWithHint(\n        noinline showHint: () -> Boolean,\n        noinline failureHintFactory: () -> Assertion\n    ) = failureHandlerFactory.newExplanatoryWithHint<S, T>(showHint, failureHintFactory)\n}\n","//TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n\npackage ch.tutteli.atrium.domain.builders\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.assertions.builders.AssertionBuilder\nimport ch.tutteli.atrium.assertions.builders.assertionBuilder\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.creating.*\nimport ch.tutteli.atrium.domain.builders.creating.changers.SubjectChangerBuilder\nimport ch.tutteli.atrium.domain.builders.creating.collectors.AssertionCollectorBuilder\nimport ch.tutteli.atrium.domain.creating.*\nimport ch.tutteli.atrium.domain.creating.changers.SubjectChanger\nimport ch.tutteli.atrium.domain.creating.collectors.AssertionCollector\n\n/**\n * Bundles different domain objects which are defined by the module atrium-domain-api\n * to give assertion writers (and other consumers of the domain) a fluent API as well.\n */\n@Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\nobject ExpectImpl {\n\n    /**\n     * Returns [AssertionBuilder] - helping you creating [Assertion]s.\n     * In detail, its an `inline` property which returns [ch.tutteli.atrium.assertions.builders.assertionBuilder]\n     * which in turn returns an implementation of [AssertionBuilder].\n     */\n    @Deprecated(\n        \"Use assertionBuilder directly, ExpectImpl will be removed with 1.0.0\",\n        ReplaceWith(\"ch.tutteli.atrium.assertions.builders.assertionBuilder\")\n    )\n    inline val builder\n        get() = assertionBuilder\n\n    /**\n     * Returns [SubjectChangerBuilder] - helping you to change the subject of the assertion.\n     * In detail, its an `inline` property which returns [SubjectChangerBuilder]\n     * which inter alia delegates to the implementation of [SubjectChanger].\n     *\n     * In case you want to extract a feature (e.g. get the first element of a `List`) instead of changing the subject\n     * into another representation (e.g. down-cast `Person` to `Student`) then you should use\n     * [feature.extractor][NewFeatureAssertionsBuilder.extractor] instead.\n     */\n    @Deprecated(\"Use _logic.changeSubject, will be removed with 1.0.0\")\n    inline fun <T> changeSubject(originalExpect: Expect<T>) =\n        SubjectChangerBuilder.create(originalExpect)\n\n    @Deprecated(\"Do no longer use Assert, use Expect instead - this method was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\")\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    inline fun <T> changeSubject(originalAssertionContainer: SubjectProvider<T>) =\n        SubjectChangerBuilder.create(originalAssertionContainer)\n\n    /**\n     * Returns [AssertionCollectorBuilder] - helping you to collect feature assertions.\n     * In detail, its an `inline` property which returns [AssertionCollectorBuilder]\n     * which inter alia delegates to the implementation of [AssertionCollector].\n     */\n    @Deprecated(\"Use _logic.collect instead; will be removed with 1.0.0\")\n    inline val collector\n        get() = AssertionCollectorBuilder\n\n    //--- assertions ---------------------------------------------------------------------------\n\n    /**\n     * Returns [AnyAssertionsBuilder]\n     * which inter alia delegates to the implementation of [AnyAssertions].\n     */\n    @Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\n    inline val any\n        get() = AnyAssertionsBuilder\n\n    /**\n     * Returns [CharSequenceAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CharSequenceAssertions].\n     */\n    @Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\n    inline val charSequence get() = CharSequenceAssertionsBuilder\n\n    /**\n     * Returns [CollectionAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CollectionAssertions].\n     */\n    @Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\n    inline val collection\n        get() = CollectionAssertionsBuilder\n\n    /**\n     * Returns [ComparableAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ComparableAssertions].\n     */\n    @Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\n    inline val comparable\n        get() = ComparableAssertionsBuilder\n\n    /**\n     * Returns [NewFeatureAssertionsBuilder]\n     * which inter alia delegates to the implementation of [FeatureAssertions].\n     */\n    @Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\n    inline val feature\n        get() = NewFeatureAssertionsBuilder\n\n    /**\n     * Returns [FloatingPointAssertionsBuilder] - [Assertion]s applicable to [Float], [Double]\n     * and maybe more - which inter alia delegates to the implementation of [FloatingPointAssertions].\n     */\n    @Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\n    inline val floatingPoint\n        get() = FloatingPointAssertionsBuilder\n\n    /**\n     * Returns [Fun0AssertionsBuilder] - [Assertion]s applicable to lambdas with arity 0\n     * which inter alia delegates to the implementation of [FloatingPointAssertions].\n     */\n    @Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\n    inline val fun0\n        get() = Fun0AssertionsBuilder\n\n    /**\n     * Returns [IterableAssertionsBuilder].\n     * which inter alia delegates to the implementation of [IterableAssertions].\n     */\n    inline val iterable get() = IterableAssertionsBuilder\n\n    /**\n     * Returns [ListAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ListAssertions].\n     */\n    @Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\n    val list\n        get() = ListAssertionsBuilder\n\n    /**\n     * Returns [MapAssertionsBuilder]\n     * which inter alia delegates to the implementation of [MapAssertions].\n     */\n    @Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\n    inline val map\n        get() = MapAssertionsBuilder\n\n    /**\n     * Returns [PairAssertionsBuilder]\n     * which inter alia delegates to the implementation of [PairAssertions].\n     */\n    @Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\n    inline val pair\n        get() = PairAssertionsBuilder\n\n    /**\n     * Returns [ThrowableAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ThrowableAssertions].\n     */\n    @Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\n    inline val throwable\n        get() = ThrowableAssertionsBuilder\n\n    /**\n     * Returns [IteratorAssertionsBuilder]\n     * which inter alia delegates to the implementation of [IteratorAssertions].\n     */\n    @Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\n    inline val iterator\n        get() = IteratorAssertionsBuilder\n}\n","package ch.tutteli.kbox\n\n/**\n * Adds the given [arg] and the [otherArgs] into a new [List] and returns it.\n *\n * This function is intended for API functions which expect `x: T, vararg otherX: T` and want to pass the arguments\n * to another function which expects only one argument of `List<T>`.\n *\n * @return a [List] containing [arg] and [otherArgs].\n */\nfun <T> varargToList(arg: T, otherArgs: Array<out T>): List<T> {\n    val list = ArrayList<T>(otherArgs.size + 1)\n    list.add(arg)\n    list.addAll(otherArgs)\n    return list\n}\n\n/**\n * Delegates to [varargToList] -- adds `this` and the [otherArgs] into a new [List] and returns it.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\ninline infix fun <T> T.glue(otherArgs: Array<out T>): List<T> = varargToList(this, otherArgs)\n","//TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.CharSequenceAssertions\nimport ch.tutteli.atrium.domain.creating.charSequenceAssertions\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.creators.CharSequenceContainsAssertions\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.creators.charSequenceContainsAssertions\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.IgnoringCaseSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NoOpSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.SearchBehaviourFactory\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.searchBehaviourFactory\nimport ch.tutteli.atrium.domain.creating.typeutils.CharSequenceOrNumberOrChar\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport kotlin.jvm.JvmName\n\n/**\n * Delegates inter alia to the implementation of [CharSequenceAssertions].\n * In detail, it implements [CharSequenceAssertions] by delegating to [charSequenceAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\nobject CharSequenceAssertionsBuilder : CharSequenceAssertions {\n\n    override inline fun <T : CharSequence> containsBuilder(subjectProvider: SubjectProvider<T>) =\n        charSequenceAssertions.containsBuilder(subjectProvider)\n\n    override inline fun <T : CharSequence> containsNotBuilder(subjectProvider: SubjectProvider<T>) =\n        charSequenceAssertions.containsNotBuilder(subjectProvider)\n\n    override inline fun startsWith(subjectProvider: SubjectProvider<CharSequence>, expected: CharSequence) =\n        charSequenceAssertions.startsWith(subjectProvider, expected)\n\n    override inline fun startsNotWith(subjectProvider: SubjectProvider<CharSequence>, expected: CharSequence) =\n        charSequenceAssertions.startsNotWith(subjectProvider, expected)\n\n    override inline fun endsWith(subjectProvider: SubjectProvider<CharSequence>, expected: CharSequence) =\n        charSequenceAssertions.endsWith(subjectProvider, expected)\n\n    override inline fun endsNotWith(subjectProvider: SubjectProvider<CharSequence>, expected: CharSequence) =\n        charSequenceAssertions.endsNotWith(subjectProvider, expected)\n\n    override inline fun isEmpty(subjectProvider: SubjectProvider<CharSequence>) =\n        charSequenceAssertions.isEmpty(subjectProvider)\n\n    override inline fun isNotEmpty(subjectProvider: SubjectProvider<CharSequence>) =\n        charSequenceAssertions.isNotEmpty(subjectProvider)\n\n    override inline fun isNotBlank(subjectProvider: SubjectProvider<CharSequence>) =\n        charSequenceAssertions.isNotBlank(subjectProvider)\n\n    override inline fun <T : CharSequence> matches(expect: Expect<T>, expected: Regex) =\n        charSequenceAssertions.matches(expect, expected)\n\n    override inline fun <T : CharSequence> mismatches(expect: Expect<T>, expected: Regex) =\n        charSequenceAssertions.mismatches(expect, expected)\n\n    /**\n     * Returns [CharSequenceContainsAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CharSequenceContainsAssertions].\n     */\n    inline val contains get() = CharSequenceContainsAssertionsBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [CharSequenceContainsAssertions].\n * In detail, it implements [CharSequenceContainsAssertions] by delegating to [charSequenceContainsAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\nobject CharSequenceContainsAssertionsBuilder : CharSequenceContainsAssertions {\n\n    override inline fun <T : CharSequence> values(\n        checkerOption: CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>,\n        expected: List<CharSequenceOrNumberOrChar>\n    ) = charSequenceContainsAssertions.values(checkerOption, expected)\n\n    override inline fun <T : CharSequence> valuesIgnoringCase(\n        checkerOption: CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>,\n        expected: List<CharSequenceOrNumberOrChar>\n    ) = charSequenceContainsAssertions.valuesIgnoringCase(checkerOption, expected)\n\n    @Suppress(\"OverridingDeprecatedMember\")\n    override inline fun <T : CharSequence> defaultTranslationOf(\n        checkerOption: CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>,\n        expected: List<Translatable>\n    ) = charSequenceContainsAssertions.defaultTranslationOf(checkerOption, expected)\n\n    @Suppress(\"OverridingDeprecatedMember\")\n    override inline fun <T : CharSequence> defaultTranslationOfIgnoringCase(\n        checkerOption: CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>,\n        expected: List<Translatable>\n    ) = charSequenceContainsAssertions.defaultTranslationOfIgnoringCase(checkerOption, expected)\n\n    @JvmName(\"stringRegex\")\n    inline fun <T : CharSequence> regex(\n        checkerOption: CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>,\n        expected: List<String>\n    ) = regex(checkerOption, expected.map { it.toRegex() })\n\n    override inline fun <T : CharSequence> regex(\n        checkerOption: CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>,\n        expected: List<Regex>\n    ) = charSequenceContainsAssertions.regex(checkerOption, expected)\n\n    override inline fun <T : CharSequence> regexIgnoringCase(\n        checkerOption: CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>,\n        expected: List<String>\n    ) = charSequenceContainsAssertions.regexIgnoringCase(checkerOption, expected)\n\n    /**\n     * Returns [CharSequenceContainsSearchBehaviourFactoryBuilder]\n     * which inter alia delegates to the implementation of [SearchBehaviourFactory].\n     */\n    inline val searchBehaviours get() = CharSequenceContainsSearchBehaviourFactoryBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [SearchBehaviourFactory].\n * In detail, it implements [SearchBehaviourFactory] by delegating to [searchBehaviourFactory]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\nobject CharSequenceContainsSearchBehaviourFactoryBuilder : SearchBehaviourFactory {\n\n    override inline fun <T : CharSequence> ignoringCase(\n        containsBuilder: CharSequenceContains.Builder<T, NoOpSearchBehaviour>\n    ): CharSequenceContains.Builder<T, IgnoringCaseSearchBehaviour> =\n        searchBehaviourFactory.ignoringCase(containsBuilder)\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 1.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 2.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 3.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 4.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this collection, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <T> Collection<T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element. Returns null if the collection is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Iterable<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value. Returns null if the list is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> List<T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <T, R> Iterable<T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <T, R> Iterable<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var index = 0\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(index++, accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Iterable<T>.scanReduce(operation: (acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Iterable<T>.scanReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    var index = 1\n    while (iterator.hasNext()) {\n        accumulator = operation(index++, accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Iterables.Operations.partition\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * Converts the string into a regular expression [Regex] with the default options.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.toRegex(): Regex = Regex(this)\n\n/**\n * Converts the string into a regular expression [Regex] with the specified single [option].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.toRegex(option: RegexOption): Regex = Regex(this, option)\n\n/**\n * Converts the string into a regular expression [Regex] with the specified set of [options].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.toRegex(options: Set<RegexOption>): Regex = Regex(this, options)\n","//TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.domain.creating.FeatureAssertions\nimport ch.tutteli.atrium.domain.creating.feature.extract.FeatureExtractor\nimport ch.tutteli.atrium.domain.creating.featureAssertions\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport ch.tutteli.atrium.reporting.translating.Untranslatable\nimport kotlin.reflect.*\nimport kotlin.jvm.JvmName\n\n/**\n * Delegates inter alia to the implementation of [FeatureAssertions].\n * In detail, it implements [FeatureAssertions] by delegating to [featureAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Deprecated(\"Switch from `Assert` to `Expect` and use then ExpectImpl.feature, NewFeatureAssertionsBuilder respectively; will be removed with 1.0.0\")\nobject FeatureAssertionsBuilder : FeatureAssertions {\n\n    @Suppress(\"DEPRECATION\")\n    inline val extractor: FeatureExtractor.DescriptionOption\n        get() = FeatureExtractor.builder\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, property: KProperty1<T, TProperty>) =\n        property(plant, { @Suppress(\"DEPRECATION\") property.invoke(plant.subject) }, Untranslatable(property.name))\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, property: KProperty0<TProperty>) =\n        property(plant, property, Untranslatable(property.name))\n\n    override inline fun <T : Any, TProperty : Any> property(\n        plant: AssertionPlant<T>,\n        noinline subjectProvider: () -> TProperty,\n        name: Translatable\n    ): AssertionPlant<TProperty> = featureAssertions.property(plant, subjectProvider, name)\n\n    override inline fun <T : Any, TProperty : Any> property(\n        plant: AssertionPlant<T>,\n        noinline subjectProvider: () -> TProperty,\n        noinline representationProvider: () -> Any?,\n        name: Translatable\n    ): AssertionPlant<TProperty> = featureAssertions.property(plant, subjectProvider, representationProvider, name)\n\n\n    inline fun <T : Any, TProperty : Any> property(\n        plant: AssertionPlant<T>,\n        property: KProperty1<T, TProperty>,\n        noinline assertionCreator: AssertionPlant<TProperty>.() -> Unit\n    ) = property(\n        plant,\n        { @Suppress(\"DEPRECATION\") property.invoke(plant.subject) },\n        Untranslatable(property.name),\n        assertionCreator\n    )\n\n    inline fun <T : Any, TProperty : Any> property(\n        plant: AssertionPlant<T>,\n        property: KProperty0<TProperty>,\n        noinline assertionCreator: AssertionPlant<TProperty>.() -> Unit\n    ) = property(plant, property, Untranslatable(property.name), assertionCreator)\n\n    inline fun <T : Any, TProperty : Any> property(\n        plant: AssertionPlant<T>,\n        noinline subjectProvider: () -> TProperty,\n        name: Translatable,\n        noinline assertionCreator: AssertionPlant<TProperty>.() -> Unit\n    ): AssertionPlant<TProperty> = property(plant, subjectProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, TProperty : Any> property(\n        plant: AssertionPlant<T>,\n        noinline subjectProvider: () -> TProperty,\n        noinline representationProvider: () -> Any?,\n        name: Translatable,\n        noinline assertionCreator: AssertionPlant<TProperty>.() -> Unit\n    ): AssertionPlant<TProperty> =\n        property(plant, subjectProvider, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    inline fun <T : Any, TProperty : Any?> property(\n        plant: AssertionPlant<T>,\n        property: KProperty1<T, TProperty>\n    ): AssertionPlantNullable<TProperty> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l = { @Suppress(\"DEPRECATION\") property.invoke(plant.subject) }\n        return property(plant, l, Untranslatable(property.name))\n    }\n\n    inline fun <T : Any, TProperty : Any?> property(plant: AssertionPlant<T>, property: KProperty0<TProperty>) =\n        property(plant, property, Untranslatable(property.name))\n\n    override inline fun <T : Any, TProperty : Any?> property(\n        plant: AssertionPlant<T>,\n        noinline subjectProvider: () -> TProperty,\n        name: Translatable\n    ): AssertionPlantNullable<TProperty> = featureAssertions.property(plant, subjectProvider, name)\n\n    override inline fun <T : Any, TProperty : Any?> property(\n        plant: AssertionPlant<T>,\n        noinline subjectProvider: () -> TProperty,\n        noinline representationProvider: () -> Any?,\n        name: Translatable\n    ): AssertionPlantNullable<TProperty> =\n        featureAssertions.property(plant, subjectProvider, representationProvider, name)\n\n\n    //Arg0\n    @JvmName(\"safeReturnValueOf0\")\n    inline fun <T : Any, R : Any> returnValueOf0(\n        plant: AssertionPlant<T>,\n        method: KFunction1<T, R>\n    ): AssertionPlant<R> = returnValueOf0(plant, { @Suppress(\"DEPRECATION\") method(plant.subject) }, method.name)\n\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, method: KFunction0<R>): AssertionPlant<R> =\n        returnValueOf0(plant, method, method.name)\n\n    override inline fun <T : Any, R : Any> returnValueOf0(\n        plant: AssertionPlant<T>,\n        noinline method: () -> R,\n        name: String\n    ): AssertionPlant<R> = featureAssertions.returnValueOf0(plant, method, name)\n\n    override inline fun <T : Any, R : Any> returnValueOf0(\n        plant: AssertionPlant<T>,\n        noinline method: () -> R,\n        noinline representationProvider: () -> Any?,\n        name: String\n    ): AssertionPlant<R> = featureAssertions.returnValueOf0(plant, method, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf0\")\n    inline fun <T : Any, R : Any> returnValueOf0(\n        plant: AssertionPlant<T>,\n        method: KFunction1<T, R>,\n        noinline assertionCreator: AssertionPlant<R>.() -> Unit\n    ): AssertionPlant<R> =\n        returnValueOf0(plant, { @Suppress(\"DEPRECATION\") method(plant.subject) }, method.name, assertionCreator)\n\n    inline fun <T : Any, R : Any> returnValueOf0(\n        plant: AssertionPlant<T>,\n        method: KFunction0<R>,\n        noinline assertionCreator: AssertionPlant<R>.() -> Unit\n    ): AssertionPlant<R> = returnValueOf0(plant, method, method.name, assertionCreator)\n\n    inline fun <T : Any, R : Any> returnValueOf0(\n        plant: AssertionPlant<T>,\n        noinline method: () -> R,\n        name: String,\n        noinline assertionCreator: AssertionPlant<R>.() -> Unit\n    ): AssertionPlant<R> = returnValueOf0(plant, method, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, R : Any> returnValueOf0(\n        plant: AssertionPlant<T>,\n        noinline method: () -> R,\n        noinline representationProvider: () -> Any?,\n        name: String,\n        noinline assertionCreator: AssertionPlant<R>.() -> Unit\n    ): AssertionPlant<R> =\n        returnValueOf0(plant, method, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf0\")\n    inline fun <T : Any, R : Any?> returnValueOf0(\n        plant: AssertionPlant<T>,\n        method: KFunction1<T, R>\n    ): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l = { @Suppress(\"DEPRECATION\") method(plant.subject) }\n        return returnValueOf0(plant, l, l, method.name)\n    }\n\n    inline fun <T : Any, R : Any?> returnValueOf0(\n        plant: AssertionPlant<T>,\n        method: KFunction0<R>\n    ): AssertionPlantNullable<R> = returnValueOf0(plant, method, method.name)\n\n    override inline fun <T : Any, R : Any?> returnValueOf0(\n        plant: AssertionPlant<T>,\n        noinline method: () -> R,\n        name: String\n    ): AssertionPlantNullable<R> = featureAssertions.returnValueOf0(plant, method, name)\n\n    override inline fun <T : Any, R : Any?> returnValueOf0(\n        plant: AssertionPlant<T>,\n        noinline method: () -> R,\n        noinline representationProvider: () -> Any?,\n        name: String\n    ): AssertionPlantNullable<R> = featureAssertions.returnValueOf0(plant, method, representationProvider, name)\n\n\n    //Arg1\n    @JvmName(\"safeReturnValueOf1\")\n    inline fun <T : Any, T1, R : Any> returnValueOf1(\n        plant: AssertionPlant<T>,\n        method: KFunction2<T, T1, R>,\n        arg1: T1\n    ): AssertionPlant<R> =\n        returnValueOf1(plant, { a1 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1) }, arg1, method.name)\n\n    inline fun <T : Any, T1, R : Any> returnValueOf1(\n        plant: AssertionPlant<T>,\n        method: KFunction1<T1, R>,\n        arg1: T1\n    ): AssertionPlant<R> = returnValueOf1(plant, method, arg1, method.name)\n\n    override inline fun <T : Any, T1, R : Any> returnValueOf1(\n        plant: AssertionPlant<T>,\n        noinline method: (T1) -> R,\n        arg1: T1,\n        name: String\n    ): AssertionPlant<R> = featureAssertions.returnValueOf1(plant, method, arg1, name)\n\n    override inline fun <T : Any, T1, R : Any> returnValueOf1(\n        plant: AssertionPlant<T>,\n        noinline method: (T1) -> R,\n        arg1: T1,\n        noinline representationProvider: () -> Any?,\n        name: String\n    ): AssertionPlant<R> = featureAssertions.returnValueOf1(plant, method, arg1, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf1\")\n    inline fun <T : Any, T1, R : Any> returnValueOf1(\n        plant: AssertionPlant<T>,\n        method: KFunction2<T, T1, R>,\n        arg1: T1,\n        noinline assertionCreator: AssertionPlant<R>.() -> Unit\n    ): AssertionPlant<R> = returnValueOf1(\n        plant,\n        { a1 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1) },\n        arg1,\n        method.name,\n        assertionCreator\n    )\n\n    inline fun <T : Any, T1, R : Any> returnValueOf1(\n        plant: AssertionPlant<T>,\n        method: KFunction1<T1, R>,\n        arg1: T1,\n        noinline assertionCreator: AssertionPlant<R>.() -> Unit\n    ): AssertionPlant<R> = returnValueOf1(plant, method, arg1, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, R : Any> returnValueOf1(\n        plant: AssertionPlant<T>,\n        noinline method: (T1) -> R,\n        arg1: T1,\n        name: String,\n        noinline assertionCreator: AssertionPlant<R>.() -> Unit\n    ): AssertionPlant<R> = returnValueOf1(plant, method, arg1, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, R : Any> returnValueOf1(\n        plant: AssertionPlant<T>,\n        noinline method: (T1) -> R,\n        arg1: T1,\n        noinline representationProvider: () -> Any?,\n        name: String,\n        noinline assertionCreator: AssertionPlant<R>.() -> Unit\n    ): AssertionPlant<R> =\n        returnValueOf1(plant, method, arg1, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf1\")\n    inline fun <T : Any, T1, R : Any?> returnValueOf1(\n        plant: AssertionPlant<T>,\n        method: KFunction2<T, T1, R>,\n        arg1: T1\n    ): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l: (T1) -> R = { a1 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1) }\n        return returnValueOf1(plant, l, arg1, method.name)\n    }\n\n    inline fun <T : Any, T1, R : Any?> returnValueOf1(\n        plant: AssertionPlant<T>,\n        method: KFunction1<T1, R>,\n        arg1: T1\n    ): AssertionPlantNullable<R> = returnValueOf1(plant, method, arg1, method.name)\n\n    override inline fun <T : Any, T1, R : Any?> returnValueOf1(\n        plant: AssertionPlant<T>,\n        noinline method: (T1) -> R,\n        arg1: T1,\n        name: String\n    ): AssertionPlantNullable<R> = featureAssertions.returnValueOf1(plant, method, arg1, name)\n\n    override inline fun <T : Any, T1, R : Any?> returnValueOf1(\n        plant: AssertionPlant<T>,\n        noinline method: (T1) -> R,\n        arg1: T1,\n        noinline representationProvider: () -> Any?,\n        name: String\n    ): AssertionPlantNullable<R> = featureAssertions.returnValueOf1(plant, method, arg1, representationProvider, name)\n\n\n    //Arg2\n    @JvmName(\"safeReturnValueOf2\")\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(\n        plant: AssertionPlant<T>,\n        method: KFunction3<T, T1, T2, R>,\n        arg1: T1,\n        arg2: T2\n    ): AssertionPlant<R> = returnValueOf2(\n        plant,\n        { a1, a2 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2) },\n        arg1,\n        arg2,\n        method.name\n    )\n\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(\n        plant: AssertionPlant<T>,\n        method: KFunction2<T1, T2, R>,\n        arg1: T1,\n        arg2: T2\n    ): AssertionPlant<R> = returnValueOf2(plant, method, arg1, arg2, method.name)\n\n    override inline fun <T : Any, T1, T2, R : Any> returnValueOf2(\n        plant: AssertionPlant<T>,\n        noinline method: (T1, T2) -> R,\n        arg1: T1,\n        arg2: T2,\n        name: String\n    ): AssertionPlant<R> = featureAssertions.returnValueOf2(plant, method, arg1, arg2, name)\n\n    override inline fun <T : Any, T1, T2, R : Any> returnValueOf2(\n        plant: AssertionPlant<T>,\n        noinline method: (T1, T2) -> R,\n        arg1: T1,\n        arg2: T2,\n        noinline representationProvider: () -> Any?,\n        name: String\n    ): AssertionPlant<R> = featureAssertions.returnValueOf2(plant, method, arg1, arg2, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf2\")\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(\n        plant: AssertionPlant<T>,\n        method: KFunction3<T, T1, T2, R>,\n        arg1: T1,\n        arg2: T2,\n        noinline assertionCreator: AssertionPlant<R>.() -> Unit\n    ): AssertionPlant<R> = returnValueOf2(\n        plant,\n        { a1, a2 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2) },\n        arg1,\n        arg2,\n        method.name,\n        assertionCreator\n    )\n\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(\n        plant: AssertionPlant<T>,\n        method: KFunction2<T1, T2, R>,\n        arg1: T1,\n        arg2: T2,\n        noinline assertionCreator: AssertionPlant<R>.() -> Unit\n    ): AssertionPlant<R> = returnValueOf2(plant, method, arg1, arg2, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(\n        plant: AssertionPlant<T>,\n        noinline method: (T1, T2) -> R,\n        arg1: T1,\n        arg2: T2,\n        name: String,\n        noinline assertionCreator: AssertionPlant<R>.() -> Unit\n    ): AssertionPlant<R> = returnValueOf2(plant, method, arg1, arg2, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(\n        plant: AssertionPlant<T>,\n        noinline method: (T1, T2) -> R,\n        arg1: T1,\n        arg2: T2,\n        noinline representationProvider: () -> Any?,\n        name: String,\n        noinline assertionCreator: AssertionPlant<R>.() -> Unit\n    ): AssertionPlant<R> =\n        returnValueOf2(plant, method, arg1, arg2, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf2\")\n    inline fun <T : Any, T1, T2, R : Any?> returnValueOf2(\n        plant: AssertionPlant<T>,\n        method: KFunction3<T, T1, T2, R>,\n        arg1: T1,\n        arg2: T2\n    ): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l: (T1, T2) -> R = { a1, a2 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2) }\n        return returnValueOf2(plant, l, arg1, arg2, method.name)\n    }\n\n    inline fun <T : Any, T1, T2, R : Any?> returnValueOf2(\n        plant: AssertionPlant<T>,\n        method: KFunction2<T1, T2, R>,\n        arg1: T1,\n        arg2: T2\n    ): AssertionPlantNullable<R> = returnValueOf2(plant, method, arg1, arg2, method.name)\n\n    override inline fun <T : Any, T1, T2, R : Any?> returnValueOf2(\n        plant: AssertionPlant<T>,\n        noinline method: (T1, T2) -> R,\n        arg1: T1,\n        arg2: T2,\n        name: String\n    ): AssertionPlantNullable<R> = featureAssertions.returnValueOf2(plant, method, arg1, arg2, name)\n\n    override inline fun <T : Any, T1, T2, R : Any?> returnValueOf2(\n        plant: AssertionPlant<T>,\n        noinline method: (T1, T2) -> R,\n        arg1: T1,\n        arg2: T2,\n        noinline representationProvider: () -> Any?,\n        name: String\n    ): AssertionPlantNullable<R> =\n        featureAssertions.returnValueOf2(plant, method, arg1, arg2, representationProvider, name)\n\n\n    //Arg3\n    @JvmName(\"safeReturnValueOf3\")\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(\n        plant: AssertionPlant<T>,\n        method: KFunction4<T, T1, T2, T3, R>,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3\n    ): AssertionPlant<R> = returnValueOf3(\n        plant,\n        { a1, a2, a3 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3) },\n        arg1,\n        arg2,\n        arg3,\n        method.name\n    )\n\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(\n        plant: AssertionPlant<T>,\n        method: KFunction3<T1, T2, T3, R>,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3\n    ): AssertionPlant<R> = returnValueOf3(plant, method, arg1, arg2, arg3, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(\n        plant: AssertionPlant<T>,\n        noinline method: (T1, T2, T3) -> R,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        name: String\n    ): AssertionPlant<R> = featureAssertions.returnValueOf3(plant, method, arg1, arg2, arg3, name)\n\n    override inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(\n        plant: AssertionPlant<T>,\n        noinline method: (T1, T2, T3) -> R,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        noinline representationProvider: () -> Any?,\n        name: String\n    ): AssertionPlant<R> =\n        featureAssertions.returnValueOf3(plant, method, arg1, arg2, arg3, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf3\")\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(\n        plant: AssertionPlant<T>,\n        method: KFunction4<T, T1, T2, T3, R>,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        noinline assertionCreator: AssertionPlant<R>.() -> Unit\n    ): AssertionPlant<R> = returnValueOf3(\n        plant,\n        { a1, a2, a3 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3) },\n        arg1,\n        arg2,\n        arg3,\n        method.name,\n        assertionCreator\n    )\n\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(\n        plant: AssertionPlant<T>,\n        method: KFunction3<T1, T2, T3, R>,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        noinline assertionCreator: AssertionPlant<R>.() -> Unit\n    ): AssertionPlant<R> = returnValueOf3(plant, method, arg1, arg2, arg3, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(\n        plant: AssertionPlant<T>,\n        noinline method: (T1, T2, T3) -> R,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        name: String,\n        noinline assertionCreator: AssertionPlant<R>.() -> Unit\n    ): AssertionPlant<R> =\n        returnValueOf3(plant, method, arg1, arg2, arg3, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(\n        plant: AssertionPlant<T>,\n        noinline method: (T1, T2, T3) -> R,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        noinline representationProvider: () -> Any?,\n        name: String,\n        noinline assertionCreator: AssertionPlant<R>.() -> Unit\n    ): AssertionPlant<R> =\n        returnValueOf3(plant, method, arg1, arg2, arg3, representationProvider, name).addAssertionsCreatedBy(\n            assertionCreator\n        )\n\n\n    @JvmName(\"safeReturnValueOf3\")\n    inline fun <T : Any, T1, T2, T3, R : Any?> returnValueOf3(\n        plant: AssertionPlant<T>,\n        method: KFunction4<T, T1, T2, T3, R>,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3\n    ): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l: (T1, T2, T3) -> R = { a1, a2, a3 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3) }\n        return returnValueOf3(plant, l, arg1, arg2, arg3, method.name)\n    }\n\n    inline fun <T : Any, T1, T2, T3, R : Any?> returnValueOf3(\n        plant: AssertionPlant<T>,\n        method: KFunction3<T1, T2, T3, R>,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3\n    ): AssertionPlantNullable<R> = returnValueOf3(plant, method, arg1, arg2, arg3, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, R : Any?> returnValueOf3(\n        plant: AssertionPlant<T>,\n        noinline method: (T1, T2, T3) -> R,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        name: String\n    ): AssertionPlantNullable<R> = featureAssertions.returnValueOf3(plant, method, arg1, arg2, arg3, name)\n\n    override inline fun <T : Any, T1, T2, T3, R : Any?> returnValueOf3(\n        plant: AssertionPlant<T>,\n        noinline method: (T1, T2, T3) -> R,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        noinline representationProvider: () -> Any?,\n        name: String\n    ): AssertionPlantNullable<R> =\n        featureAssertions.returnValueOf3(plant, method, arg1, arg2, arg3, representationProvider, name)\n\n\n    //Arg4\n    @JvmName(\"safeReturnValueOf4\")\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(\n        plant: AssertionPlant<T>,\n        method: KFunction5<T, T1, T2, T3, T4, R>,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4\n    ): AssertionPlant<R> = returnValueOf4(\n        plant,\n        { a1, a2, a3, a4 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4) },\n        arg1,\n        arg2,\n        arg3,\n        arg4,\n        method.name\n    )\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(\n        plant: AssertionPlant<T>,\n        method: KFunction4<T1, T2, T3, T4, R>,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4\n    ): AssertionPlant<R> = returnValueOf4(plant, method, arg1, arg2, arg3, arg4, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(\n        plant: AssertionPlant<T>,\n        noinline method: (T1, T2, T3, T4) -> R,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        name: String\n    ): AssertionPlant<R> = featureAssertions.returnValueOf4(plant, method, arg1, arg2, arg3, arg4, name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(\n        plant: AssertionPlant<T>,\n        noinline method: (T1, T2, T3, T4) -> R,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        noinline representationProvider: () -> Any?,\n        name: String\n    ): AssertionPlant<R> =\n        featureAssertions.returnValueOf4(plant, method, arg1, arg2, arg3, arg4, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf4\")\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(\n        plant: AssertionPlant<T>,\n        method: KFunction5<T, T1, T2, T3, T4, R>,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        noinline assertionCreator: AssertionPlant<R>.() -> Unit\n    ): AssertionPlant<R> = returnValueOf4(\n        plant,\n        { a1, a2, a3, a4 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4) },\n        arg1,\n        arg2,\n        arg3,\n        arg4,\n        method.name,\n        assertionCreator\n    )\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(\n        plant: AssertionPlant<T>,\n        method: KFunction4<T1, T2, T3, T4, R>,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        noinline assertionCreator: AssertionPlant<R>.() -> Unit\n    ): AssertionPlant<R> = returnValueOf4(plant, method, arg1, arg2, arg3, arg4, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(\n        plant: AssertionPlant<T>,\n        noinline method: (T1, T2, T3, T4) -> R,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        name: String,\n        noinline assertionCreator: AssertionPlant<R>.() -> Unit\n    ): AssertionPlant<R> =\n        returnValueOf4(plant, method, arg1, arg2, arg3, arg4, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(\n        plant: AssertionPlant<T>,\n        noinline method: (T1, T2, T3, T4) -> R,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        noinline representationProvider: () -> Any?,\n        name: String,\n        noinline assertionCreator: AssertionPlant<R>.() -> Unit\n    ): AssertionPlant<R> =\n        returnValueOf4(plant, method, arg1, arg2, arg3, arg4, representationProvider, name).addAssertionsCreatedBy(\n            assertionCreator\n        )\n\n\n    @JvmName(\"safeReturnValueOf4\")\n    inline fun <T : Any, T1, T2, T3, T4, R : Any?> returnValueOf4(\n        plant: AssertionPlant<T>,\n        method: KFunction5<T, T1, T2, T3, T4, R>,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4\n    ): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l: (T1, T2, T3, T4) -> R =\n            { a1, a2, a3, a4 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4) }\n        return returnValueOf4(plant, l, arg1, arg2, arg3, arg4, method.name)\n    }\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any?> returnValueOf4(\n        plant: AssertionPlant<T>,\n        method: KFunction4<T1, T2, T3, T4, R>,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4\n    ): AssertionPlantNullable<R> = returnValueOf4(plant, method, arg1, arg2, arg3, arg4, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, R : Any?> returnValueOf4(\n        plant: AssertionPlant<T>,\n        noinline method: (T1, T2, T3, T4) -> R,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        name: String\n    ): AssertionPlantNullable<R> = featureAssertions.returnValueOf4(plant, method, arg1, arg2, arg3, arg4, name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, R : Any?> returnValueOf4(\n        plant: AssertionPlant<T>,\n        noinline method: (T1, T2, T3, T4) -> R,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        noinline representationProvider: () -> Any?,\n        name: String\n    ): AssertionPlantNullable<R> =\n        featureAssertions.returnValueOf4(plant, method, arg1, arg2, arg3, arg4, representationProvider, name)\n\n\n    //Arg5\n    @JvmName(\"safeReturnValueOf5\")\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(\n        plant: AssertionPlant<T>,\n        method: KFunction6<T, T1, T2, T3, T4, T5, R>,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        arg5: T5\n    ): AssertionPlant<R> = returnValueOf5(\n        plant,\n        { a1, a2, a3, a4, a5 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4, a5) },\n        arg1,\n        arg2,\n        arg3,\n        arg4,\n        arg5,\n        method.name\n    )\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(\n        plant: AssertionPlant<T>,\n        method: KFunction5<T1, T2, T3, T4, T5, R>,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        arg5: T5\n    ): AssertionPlant<R> = returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(\n        plant: AssertionPlant<T>,\n        noinline method: (T1, T2, T3, T4, T5) -> R,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        arg5: T5,\n        name: String\n    ): AssertionPlant<R> = featureAssertions.returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(\n        plant: AssertionPlant<T>,\n        noinline method: (T1, T2, T3, T4, T5) -> R,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        arg5: T5,\n        noinline representationProvider: () -> Any?,\n        name: String\n    ): AssertionPlant<R> =\n        featureAssertions.returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf5\")\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(\n        plant: AssertionPlant<T>,\n        method: KFunction6<T, T1, T2, T3, T4, T5, R>,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        arg5: T5,\n        noinline assertionCreator: AssertionPlant<R>.() -> Unit\n    ): AssertionPlant<R> = returnValueOf5(\n        plant,\n        { a1, a2, a3, a4, a5 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4, a5) },\n        arg1,\n        arg2,\n        arg3,\n        arg4,\n        arg5,\n        method.name,\n        assertionCreator\n    )\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(\n        plant: AssertionPlant<T>,\n        method: KFunction5<T1, T2, T3, T4, T5, R>,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        arg5: T5,\n        noinline assertionCreator: AssertionPlant<R>.() -> Unit\n    ): AssertionPlant<R> = returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(\n        plant: AssertionPlant<T>,\n        noinline method: (T1, T2, T3, T4, T5) -> R,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        arg5: T5,\n        name: String,\n        noinline assertionCreator: AssertionPlant<R>.() -> Unit\n    ): AssertionPlant<R> =\n        returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(\n        plant: AssertionPlant<T>,\n        noinline method: (T1, T2, T3, T4, T5) -> R,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        arg5: T5,\n        noinline representationProvider: () -> Any?,\n        name: String,\n        noinline assertionCreator: AssertionPlant<R>.() -> Unit\n    ): AssertionPlant<R> = returnValueOf5(\n        plant,\n        method,\n        arg1,\n        arg2,\n        arg3,\n        arg4,\n        arg5,\n        representationProvider,\n        name\n    ).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf5\")\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any?> returnValueOf5(\n        plant: AssertionPlant<T>,\n        method: KFunction6<T, T1, T2, T3, T4, T5, R>,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        arg5: T5\n    ): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l: (T1, T2, T3, T4, T5) -> R =\n            { a1, a2, a3, a4, a5 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4, a5) }\n        return returnValueOf5(plant, l, arg1, arg2, arg3, arg4, arg5, method.name)\n    }\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any?> returnValueOf5(\n        plant: AssertionPlant<T>,\n        method: KFunction5<T1, T2, T3, T4, T5, R>,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        arg5: T5\n    ): AssertionPlantNullable<R> = returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, T5, R : Any?> returnValueOf5(\n        plant: AssertionPlant<T>,\n        noinline method: (T1, T2, T3, T4, T5) -> R,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        arg5: T5,\n        name: String\n    ): AssertionPlantNullable<R> = featureAssertions.returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, T5, R : Any?> returnValueOf5(\n        plant: AssertionPlant<T>,\n        noinline method: (T1, T2, T3, T4, T5) -> R,\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        arg5: T5,\n        noinline representationProvider: () -> Any?,\n        name: String\n    ): AssertionPlantNullable<R> =\n        featureAssertions.returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, representationProvider, name)\n}\n","//TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.IterableAssertions\nimport ch.tutteli.atrium.domain.creating.changers.ExtractedFeaturePostStep\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.creators.IterableContainsAssertions\nimport ch.tutteli.atrium.domain.creating.iterable.contains.creators.iterableContainsAssertions\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.*\nimport ch.tutteli.atrium.domain.creating.iterableAssertions\n\n/**\n * Delegates inter alia to the implementation of [IterableAssertions].\n * In detail, it implements [IterableAssertions] by delegating to [iterableAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\nobject IterableAssertionsBuilder : IterableAssertions {\n\n    override inline fun <E, T : Iterable<E>> containsBuilder(subjectProvider: SubjectProvider<T>) =\n        iterableAssertions.containsBuilder(subjectProvider)\n\n    override inline fun <E, T : Iterable<E>> containsNotBuilder(subjectProvider: SubjectProvider<T>) =\n        iterableAssertions.containsNotBuilder(subjectProvider)\n\n    override inline fun <E : Any, T : Iterable<E?>> all(\n        expect: Expect<T>,\n        noinline assertionCreator: (Expect<E>.() -> Unit)?\n    ): Assertion = iterableAssertions.all(expect, assertionCreator)\n\n\n    override inline fun <E, T : Iterable<E>> hasNext(expect: Expect<T>): Assertion =\n        iterableAssertions.hasNext(expect)\n\n    override inline fun <E, T : Iterable<E>> hasNotNext(expect: Expect<T>): Assertion =\n        iterableAssertions.hasNotNext(expect)\n\n    override inline fun <E : Comparable<E>, T : Iterable<E>> min(expect: Expect<T>): ExtractedFeaturePostStep<T, E> =\n        iterableAssertions.min(expect)\n\n    override inline fun <E : Comparable<E>, T : Iterable<E>> max(expect: Expect<T>) =\n        iterableAssertions.max(expect)\n\n    /**\n     * Returns [IterableContainsAssertionsBuilder]\n     * which inter alia delegates to the implementation of [IterableContainsAssertions].\n     */\n    inline val contains get() = IterableContainsAssertionsBuilder\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any> all(\n        plant: AssertionPlant<Iterable<E?>>,\n        noinline assertionCreator: (AssertionPlant<E>.() -> Unit)?\n    ): Assertion = iterableAssertions.all(plant, assertionCreator)\n}\n\n/**\n * Delegates inter alia to the implementation of [IterableContainsAssertions].\n * In detail, it implements [IterableContainsAssertions] by delegating to [iterableContainsAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\nobject IterableContainsAssertionsBuilder : IterableContainsAssertions {\n\n    override inline fun <E, T : Iterable<E>> valuesInAnyOrder(\n        checkerOption: IterableContains.CheckerOption<E, T, InAnyOrderSearchBehaviour>,\n        expected: List<E>\n    ) = iterableContainsAssertions.valuesInAnyOrder(checkerOption, expected)\n\n    override inline fun <E : Any, T : Iterable<E?>> entriesInAnyOrder(\n        checkerOption: IterableContains.CheckerOption<E?, T, InAnyOrderSearchBehaviour>,\n        assertionCreators: List<(Expect<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInAnyOrder(checkerOption, assertionCreators)\n\n    override inline fun <E, T : Iterable<E>> valuesInAnyOrderOnly(\n        builder: IterableContains.Builder<E, T, InAnyOrderOnlySearchBehaviour>,\n        expected: List<E>\n    ) = iterableContainsAssertions.valuesInAnyOrderOnly(builder, expected)\n\n    override inline fun <E : Any, T : Iterable<E?>> entriesInAnyOrderOnly(\n        builder: IterableContains.Builder<E?, T, InAnyOrderOnlySearchBehaviour>,\n        assertionCreators: List<(Expect<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInAnyOrderOnly(builder, assertionCreators)\n\n    override inline fun <E, T : Iterable<E>> valuesInOrderOnly(\n        builder: IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>,\n        expected: List<E>\n    ) = iterableContainsAssertions.valuesInOrderOnly(builder, expected)\n\n    override inline fun <E : Any, T : Iterable<E?>> entriesInOrderOnly(\n        builder: IterableContains.Builder<E?, T, InOrderOnlySearchBehaviour>,\n        assertionCreators: List<(Expect<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInOrderOnly(builder, assertionCreators)\n\n    override inline fun <E, T : Iterable<E>> valuesInOrderOnlyGrouped(\n        builder: IterableContains.Builder<E, T, InOrderOnlyGroupedSearchBehaviour>,\n        groups: List<List<E>>\n    ): Assertion = iterableContainsAssertions.valuesInOrderOnlyGrouped(builder, groups)\n\n    override inline fun <E : Any, T : Iterable<E?>> entriesInOrderOnlyGrouped(\n        builder: IterableContains.Builder<E?, T, InOrderOnlyGroupedSearchBehaviour>,\n        groups: List<List<(Expect<E>.() -> Unit)?>>\n    ): Assertion = iterableContainsAssertions.entriesInOrderOnlyGrouped(builder, groups)\n\n\n    /**\n     * Returns [IterableContainsSearchBehaviourFactoryBuilder]\n     * which inter alia delegates to the implementation of [SearchBehaviourFactory].\n     */\n    inline val searchBehaviours get() = IterableContainsSearchBehaviourFactoryBuilder\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any, T : Iterable<E?>> entriesInAnyOrderWithAssert(\n        checkerOption: IterableContains.CheckerOption<E?, T, InAnyOrderSearchBehaviour>,\n        assertionCreators: List<(AssertionPlant<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInAnyOrderWithAssert(checkerOption, assertionCreators)\n\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any, T : Iterable<E?>> entriesInAnyOrderOnlyWithAssert(\n        builder: IterableContains.Builder<E?, T, InAnyOrderOnlySearchBehaviour>,\n        assertionCreators: List<(AssertionPlant<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInAnyOrderOnlyWithAssert(builder, assertionCreators)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any, T : Iterable<E?>> entriesInOrderOnlyWithAssert(\n        builder: IterableContains.Builder<E?, T, InOrderOnlySearchBehaviour>,\n        assertionCreators: List<(AssertionPlant<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInOrderOnlyWithAssert(builder, assertionCreators)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any, T : Iterable<E?>> entriesInOrderOnlyGroupedWithAssert(\n        builder: IterableContains.Builder<E?, T, InOrderOnlyGroupedSearchBehaviour>,\n        groups: List<List<(AssertionPlant<E>.() -> Unit)?>>\n    ): Assertion = iterableContainsAssertions.entriesInOrderOnlyGroupedWithAssert(builder, groups)\n}\n\n/**\n * Delegates inter alia to the implementation of [SearchBehaviourFactory].\n * In detail, it implements [SearchBehaviourFactory] by delegating to [searchBehaviourFactory]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\nobject IterableContainsSearchBehaviourFactoryBuilder : SearchBehaviourFactory {\n\n    override inline fun <E, T : Iterable<E>> inAnyOrder(builder: IterableContains.Builder<E, T, NoOpSearchBehaviour>) =\n        searchBehaviourFactory.inAnyOrder(builder)\n\n    override inline fun <E, T : Iterable<E>> inAnyOrderOnly(builder: IterableContains.Builder<E, T, InAnyOrderSearchBehaviour>) =\n        searchBehaviourFactory.inAnyOrderOnly(builder)\n\n    override inline fun <E, T : Iterable<E>> inOrder(builder: IterableContains.Builder<E, T, NoOpSearchBehaviour>) =\n        searchBehaviourFactory.inOrder(builder)\n\n    override inline fun <E, T : Iterable<E>> inOrderOnly(builder: IterableContains.Builder<E, T, InOrderSearchBehaviour>) =\n        searchBehaviourFactory.inOrderOnly(builder)\n\n    override inline fun <E, T : Iterable<E>> inOrderOnlyGrouped(builder: IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>) =\n        searchBehaviourFactory.inOrderOnlyGrouped(builder)\n\n    override inline fun <E, T : Iterable<E>> inOrderOnlyGroupedWithin(builder: IterableContains.Builder<E, T, InOrderOnlyGroupedSearchBehaviour>) =\n        searchBehaviourFactory.inOrderOnlyGroupedWithin(builder)\n\n}\n","//TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.creating.ThrowableAssertions\nimport ch.tutteli.atrium.domain.creating.changers.ChangedSubjectPostStep\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.ThrowableThrown\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.creators.ThrowableThrownAssertions\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.creators.throwableThrownAssertions\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.providers.absentThrowableMessageProviderFactory\nimport ch.tutteli.atrium.domain.creating.throwableAssertions\nimport ch.tutteli.atrium.reporting.Reporter\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport kotlin.reflect.KClass\n\n/**\n * Delegates inter alia to the implementation of [ThrowableAssertions].\n * In detail, it implements [ThrowableAssertions] by delegating to [throwableAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\nobject ThrowableAssertionsBuilder : ThrowableAssertions {\n\n    override inline fun <TExpected : Throwable> cause(\n        expect: Expect<out Throwable>,\n        expectedType: KClass<TExpected>\n    ): ChangedSubjectPostStep<Throwable?, TExpected> =\n        throwableAssertions.cause(expect,  expectedType)\n\n\n    @Deprecated(\n        \"Use Expect instead; will be removed with 1.0.0\",\n        ReplaceWith(\n            \"this.thrownBuilder(\\n\" +\n                \"// !!!! in case you define an assertion verb, remove it entirely, this is no longer required !!!!\\n\" +\n                \")\"\n        )\n    )\n    override inline fun thrownBuilder(\n        assertionVerb: Translatable,\n        noinline act: () -> Unit,\n        reporter: Reporter\n    ): ThrowableThrown.Builder = throwableAssertions.thrownBuilder(assertionVerb, act, reporter)\n\n    /**\n     * Returns [ThrowableThrownAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ThrowableThrownAssertions].\n     */\n    @Deprecated(\"Will be removed with 1.0.0\")\n    inline val thrown\n        get() = ThrowableThrownAssertionsBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [ThrowableThrownAssertions].\n * In detail, it implements [ThrowableThrownAssertions] by delegating to [throwableThrownAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Deprecated(\"Will be removed with 1.0.0\")\nobject ThrowableThrownAssertionsBuilder : ThrowableThrownAssertions {\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <TExpected : Throwable> toBe(\n        throwableThrownBuilder: ThrowableThrown.Builder,\n        expectedType: KClass<TExpected>,\n        noinline assertionCreator: AssertionPlant<TExpected>.() -> Unit\n    ) = throwableThrownAssertions.toBe(throwableThrownBuilder, expectedType, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun nothingThrown(throwableThrownBuilder: ThrowableThrown.Builder) =\n        throwableThrownAssertions.nothingThrown(throwableThrownBuilder)\n\n    /**\n     * Returns [AbsentThrowableMessageProviderFactoryBuilder]\n     * which inter alia delegates to the implementation of [ch.tutteli.atrium.domain.creating.throwable.thrown.providers.AbsentThrowableMessageProviderFactory].\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\", \"DEPRECATION\")\n    @Deprecated(\"Will be removed with 1.0.0\")\n    inline val providers\n        get() = AbsentThrowableMessageProviderFactoryBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [ch.tutteli.atrium.domain.creating.throwable.thrown.providers.AbsentThrowableMessageProviderFactory].\n * In detail, it implements [ch.tutteli.atrium.domain.creating.throwable.thrown.providers.AbsentThrowableMessageProviderFactory] by delegating to [absentThrowableMessageProviderFactory]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Will be removed with 1.0.0\")\nobject AbsentThrowableMessageProviderFactoryBuilder :\n    ch.tutteli.atrium.domain.creating.throwable.thrown.providers.AbsentThrowableMessageProviderFactory {\n\n    override inline fun translatableBased(translatable: Translatable): ThrowableThrown.AbsentThrowableMessageProvider =\n        absentThrowableMessageProviderFactory.translatableBased(translatable)\n}\n","// TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"TYPEALIAS_EXPANSION_DEPRECATION\")\n@file:JvmMultifileClass\n@file:JvmName(\"AnyAssertionsKt\")\n\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.checking.AssertionChecker\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.reporting.Reporter\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is (equal to) [expected].\n *\n * This method might enforce in the future, that [expected] has to be the same type as [Assert.subject][SubjectProvider.subject].\n * Currently the following is possible: `assert(1).toBe(1.0)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().toBe(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.toBe\"\n    )\n)\nfun <T : Any> Assert<T>.toBe(expected: T) = addAssertion(AssertImpl.any.toBe(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is not (equal to) [expected].\n *\n * This method might enforce in the future, that [expected] has to be the same type as [Assert.subject][SubjectProvider.subject].\n * Currently the following is possible: `assert(1).notToBe(1.0)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().notToBe(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.notToBe\"\n    )\n)\nfun <T : Any> Assert<T>.notToBe(expected: T) = addAssertion(AssertImpl.any.notToBe(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is the same instance as [expected].\n *\n * This method might enforce in the future, that [expected] has to be the same type as [Assert.subject][SubjectProvider.subject].\n * Currently the following is possible: `assert(1).isSameAs(1.0)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().isSameAs(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isSameAs\"\n    )\n)\nfun <T : Any> Assert<T>.isSameAs(expected: T) = addAssertion(AssertImpl.any.isSame(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is not the same instance as [expected].\n *\n * This method might enforce in the future, that [expected] has to be the same type as [Assert.subject][SubjectProvider.subject].\n * Currently the following is possible: `assert(1).isNotSameAs(1.0)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().isNotSameAs(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isNotSameAs\"\n    )\n)\nfun <T : Any> Assert<T>.isNotSameAs(expected: T) = addAssertion(AssertImpl.any.isNotSame(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is [expected].\n *\n * @return Does not support a fluent API because: what else would you want to assert about `null` anyway?\n *\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().toBe(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.toBe\"\n    )\n)\ninline fun <reified T : Any> AssertionPlantNullable<T?>.toBe(expected: T?) {\n    addAssertion(AssertImpl.any.isNullable(this, T::class, expected))\n}\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is either `null` if [assertionCreatorOrNull]\n * is `null` or is not `null` and holds all assertions [assertionCreatorOrNull] might create.\n *\n * It is a shortcut for\n * ```kotlin\n * if (assertionCreatorOrNull == null) toBe(null)\n * else notToBeNull(assertionCreatorOrNull)\n * ```\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().toBeNullIfNullGivenElse(assertionCreatorOrNull).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.toBeNullIfNullGivenElse\"\n    )\n)\ninline fun <reified T : Any> AssertionPlantNullable<T?>.toBeNullIfNullGivenElse(\n    noinline assertionCreatorOrNull: (Assert<T>.() -> Unit)?\n) {\n    addAssertion(AssertImpl.any.isNullIfNullGivenElse(this, T::class, assertionCreatorOrNull))\n}\n\n/**\n * Can be used to separate assertions when using the fluent API.\n *\n * For instance `assert(1).isLessThan(2).and.isGreaterThan(0)` creates\n * two assertions (not one assertion with two sub-assertions) - the first asserts that 1 is less than 2 and a second\n * asserts that 1 is greater than 0. If the first assertion fails, then usually (depending on the configured\n * [AssertionChecker]) the second assertion is not evaluated.\n *\n * @return This plant to support a fluent API.\n */\nval <T : Any> AssertionPlant<T>.and: AssertionPlant<T> get() = this\n\n/**\n * Can be used to create a group of sub assertions when using the fluent API.\n *\n * For instance `assert(1).isLessThan(3).and { isEven(); isGreaterThan(1) }` creates\n * two assertions where the second one consists of two sub-assertions. In case the first assertion holds, then the\n * second one is evaluated as a whole. Meaning, even though 1 is not even, it still evaluates that 1 is greater than 1.\n * Hence the reporting might (depending on the configured [Reporter]) contain both failing sub-assertions.\n *\n * @return This plant to support a fluent API.\n */\ninfix fun <T : Any> AssertionPlant<T>.and(assertionCreator: Assert<T>.() -> Unit) =\n    addAssertionsCreatedBy(assertionCreator)\n","// TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"TYPEALIAS_EXPANSION_DEPRECATION\")\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.ExpectImpl\nimport kotlin.jvm.JvmName\n\n/**\n * Turns `Assert<Array<E>>` into `Assert<Iterable<E>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(Array<out E>::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().asList().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asList\"\n    )\n)\nfun <E> Assert<Array<out E>>.asIterable(): Assert<Iterable<E>> =\n    ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<Array<E>>` into `Assert<Iterable<E>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(Array<out E>::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().asList().asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asList\"\n    )\n)\nfun <E> Assert<Array<out E>>.asIterable(assertionCreator: Assert<Iterable<E>>.() -> Unit): Assert<Iterable<E>> =\n    asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<CharArray>` into `Assert<Iterable<Byte>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(ByteArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [Assert] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().asList().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asList\"\n    )\n)\n@JvmName(\"byteArrAsIterable\")\nfun Assert<ByteArray>.asIterable(): Assert<Iterable<Byte>> =\n    ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<CharArray>` into `Assert<Iterable<Byte>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(ByteArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [Assert] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().asList().asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asList\"\n    )\n)\n@JvmName(\"byteArrAsIterable\")\nfun Assert<ByteArray>.asIterable(assertionCreator: Assert<Iterable<Byte>>.() -> Unit): Assert<Iterable<Byte>> =\n    asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<CharArray>` into `Assert<Iterable<Char>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(CharArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().asList().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asList\"\n    )\n)\n@JvmName(\"charArrAsIterable\")\nfun Assert<CharArray>.asIterable(): Assert<Iterable<Char>> =\n    ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<CharArray>` into `Assert<Iterable<Char>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(CharArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().asList().asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asList\"\n    )\n)\n@JvmName(\"charArrAsIterable\")\nfun Assert<CharArray>.asIterable(assertionCreator: Assert<Iterable<Char>>.() -> Unit): Assert<Iterable<Char>> =\n    asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<ShortArray>` into `Assert<Iterable<Short>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(ShortArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().asList().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asList\"\n    )\n)\n@JvmName(\"shortArrAsIterable\")\nfun Assert<ShortArray>.asIterable(): Assert<Iterable<Short>> =\n    ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<ShortArray>` into `Assert<Iterable<Short>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(ShortArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().asList().asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asList\"\n    )\n)\n@JvmName(\"shortArrAsIterable\")\nfun Assert<ShortArray>.asIterable(assertionCreator: Assert<Iterable<Short>>.() -> Unit): Assert<Iterable<Short>> =\n    asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<IntArray>` into `Assert<Iterable<Int>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(IntArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().asList().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asList\"\n    )\n)\n@JvmName(\"intArrAsIterable\")\nfun Assert<IntArray>.asIterable(): Assert<Iterable<Int>> = ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<IntArray>` into `Assert<Iterable<Int>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(IntArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().asList().asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asList\"\n    )\n)\n@JvmName(\"intArrAsIterable\")\nfun Assert<IntArray>.asIterable(assertionCreator: Assert<Iterable<Int>>.() -> Unit): Assert<Iterable<Int>> =\n    asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<LongArray>` into `Assert<Iterable<Double>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(LongArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().asList().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asList\"\n    )\n)\n@JvmName(\"longArrAsIterable\")\nfun Assert<LongArray>.asIterable(): Assert<Iterable<Long>> =\n    ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<LongArray>` into `Assert<Iterable<Double>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(LongArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().asList().asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asList\"\n    )\n)\n@JvmName(\"longArrAsIterable\")\nfun Assert<LongArray>.asIterable(assertionCreator: Assert<Iterable<Long>>.() -> Unit): Assert<Iterable<Long>> =\n    asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<FloatArray>` into `Assert<Iterable<Float>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(FloatArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().asList().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asList\"\n    )\n)\n@JvmName(\"floatArrAsIterable\")\nfun Assert<FloatArray>.asIterable(): Assert<Iterable<Float>> =\n    ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<FloatArray>` into `Assert<Iterable<Float>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(FloatArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().asList().asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asList\"\n    )\n)\n@JvmName(\"floatArrAsIterable\")\nfun Assert<FloatArray>.asIterable(assertionCreator: Assert<Iterable<Float>>.() -> Unit): Assert<Iterable<Float>> =\n    asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<DoubleArray>` into `Assert<Iterable<Double>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(DoubleArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().asList().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asList\"\n    )\n)\n@JvmName(\"doubleArrAsIterable\")\nfun Assert<DoubleArray>.asIterable(): Assert<Iterable<Double>> =\n    ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<DoubleArray>` into `Assert<Iterable<Double>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(DoubleArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().asList().asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asList\"\n    )\n)\n@JvmName(\"doubleArrAsIterable\")\nfun Assert<DoubleArray>.asIterable(assertionCreator: Assert<Iterable<Double>>.() -> Unit): Assert<Iterable<Double>> =\n    asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<BooleanArray>` into `Assert<Iterable<Boolean>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(BooleanArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().asList().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asList\"\n    )\n)\n@JvmName(\"boolArrAsIterable\")\nfun Assert<BooleanArray>.asIterable(): Assert<Iterable<Boolean>> =\n    ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<BooleanArray>` into `Assert<Iterable<Boolean>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(BooleanArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().asList().asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asList\"\n    )\n)\n@JvmName(\"boolArrAsIterable\")\nfun Assert<BooleanArray>.asIterable(assertionCreator: Assert<Iterable<Boolean>>.() -> Unit): Assert<Iterable<Boolean>> =\n    asIterable().addAssertionsCreatedBy(assertionCreator)\n","// TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"TYPEALIAS_EXPANSION_DEPRECATION\")\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.NotCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.impl.NotCheckerOptionImpl\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NoOpSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NotSearchBehaviour\n\n/**\n * Creates a [CharSequenceContains.Builder] based on this [AssertionPlant] which allows to define\n * more sophisticated `contains` assertions.\n *\n * @return The newly created builder.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().contains\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.contains\"\n    )\n)\nval <T : CharSequence> Assert<T>.contains: CharSequenceContains.Builder<T, NoOpSearchBehaviour>\n    get() = AssertImpl.charSequence.containsBuilder(this)\n\n/**\n * Creates a [CharSequenceContains.Builder] based on this [AssertionPlant] which allows to define\n * more sophisticated `contains not` assertions.\n *\n * @return The newly created builder.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().containsNot\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.containsNot\"\n    )\n)\nval <T : CharSequence> Assert<T>.containsNot: NotCheckerOption<T, NotSearchBehaviour>\n    get() = NotCheckerOptionImpl(AssertImpl.charSequence.containsNotBuilder(this))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains [expected]'s [toString] representation\n * and the [toString] representation of the [otherExpected] (if given), using a non disjoint search.\n *\n * It is a shortcut for `contains.atLeast(1).values(expected, *otherExpected)`.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'a'` and [expected]\n * is defined as `'a'` and one [otherExpected] is defined as `'a'` as well, then both match, even though they match the\n * same sequence in the input of the search. Use the property `contains` to create a more sophisticated `contains`\n * assertion where you can use options such as [atLeast], [atMost] and [exactly] to control the number of occurrences\n * you expect.\n *\n * Meaning you might want to use:\n *   `contains.exactly(2).value('a')`\n * instead of:\n *   `contains('a', 'a')`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] or one of the [otherExpected] is not a\n *   [CharSequence], [Number] or [Char].\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().contains(expected, *otherExpected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.contains\"\n    )\n)\nfun <T : CharSequence> Assert<T>.contains(expected: Any, vararg otherExpected: Any): AssertionPlant<T> =\n    contains.atLeast(1).values(expected, *otherExpected)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not contain [expected]'s [toString] representation\n * and neither one of the [otherExpected]'s [toString] representation (if given).\n *\n * It is a shortcut for `containsNot.values(expected, *otherExpected)`.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().containsNot(expected, *otherExpected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.containsNot\"\n    )\n)\nfun <T : CharSequence> Assert<T>.containsNot(expected: Any, vararg otherExpected: Any) =\n    containsNot.values(expected, *otherExpected)\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains a sequence which matches the given regular expression\n * [pattern] as well as the [otherPatterns] (if given), using a non disjoint search.\n *\n * It is a shortcut for `contains.atLeast(1).regex(pattern, *otherPatterns)`.\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'ab'` and [pattern]\n * is defined as `'a(b)?'` and one of the [otherPatterns] is defined as `'a(b)?'` as well, then both match, even though\n * they match the same sequence in the input of the search. Use an option such as [atLeast], [atMost] and [exactly] to\n * control the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `contains.exactly(2).regex('a(b)?')`\n * instead of:\n *   `contains.atLeast(1).regex('a(b)?', 'a(b)?')`\n *\n * @param pattern The pattern which is expected to have a match against the input of the search.\n * @param otherPatterns Additional patterns which are expected to have a match against the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().containsRegex(pattern, *otherPatterns).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.containsRegex\"\n    )\n)\nfun <T : CharSequence> Assert<T>.containsRegex(pattern: String, vararg otherPatterns: String): AssertionPlant<T> =\n    contains.atLeast(1).regex(pattern, *otherPatterns)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] starts with [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().startsWith(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.startsWith\"\n    )\n)\nfun <T : CharSequence> Assert<T>.startsWith(expected: CharSequence) =\n    addAssertion(AssertImpl.charSequence.startsWith(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not start with [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().startsNotWith(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.startsNotWith\"\n    )\n)\nfun <T : CharSequence> Assert<T>.startsNotWith(expected: CharSequence) =\n    addAssertion(AssertImpl.charSequence.startsNotWith(this, expected))\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] ends with [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().endsWith(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.endsWith\"\n    )\n)\nfun <T : CharSequence> Assert<T>.endsWith(expected: CharSequence) =\n    addAssertion(AssertImpl.charSequence.endsWith(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not end with [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().endsNotWith(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.endsNotWith\"\n    )\n)\nfun <T : CharSequence> Assert<T>.endsNotWith(expected: CharSequence) =\n    addAssertion(AssertImpl.charSequence.endsNotWith(this, expected))\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] [CharSequence].[kotlin.text.isEmpty].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().isEmpty().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isEmpty\"\n    )\n)\nfun <T : CharSequence> Assert<T>.isEmpty() = addAssertion(AssertImpl.charSequence.isEmpty(this))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] [CharSequence].[kotlin.text.isNotEmpty].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().isNotEmpty().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isNotEmpty\"\n    )\n)\nfun <T : CharSequence> Assert<T>.isNotEmpty() = addAssertion(AssertImpl.charSequence.isNotEmpty(this))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] [CharSequence].[kotlin.text.isNotBlank].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().isNotBlank().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isNotBlank\"\n    )\n)\nfun <T : CharSequence> Assert<T>.isNotBlank() = addAssertion(AssertImpl.charSequence.isNotBlank(this))\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.*\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.impl.*\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains.SearchBehaviour\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the value which we are looking\n * for occurs `at least` number of [times] within the search input.\n *\n * @param times The number which the check will compare against the actual number of times an expected value is\n *   found in the input of the search.\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.atLeast(times)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.atLeast\"\n    )\n)\nfun <T : CharSequence, S : SearchBehaviour> CharSequenceContains.Builder<T, S>.atLeast(times: Int): AtLeastCheckerOption<T, S> =\n    AtLeastCheckerOptionImpl(times, this)\n\n/**\n * Restricts a `contains at least` assertion by specifying that the number of occurrences of the value which we\n * are looking for occurs `at most` number of [times] within the search input.\n *\n * The resulting restriction will be a `contains at least but at most` assertion.\n *\n * @param times The number which the check will compare against the actual number of times an expected value is\n *   found in the input of the search.\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n * @throws IllegalArgumentException In case [times] of this `at most` restriction equals to the number of the\n *   `at least` restriction; use the [exactly] restriction instead.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.butAtMost(times)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.butAtMost\"\n    )\n)\nfun <T : CharSequence, S : SearchBehaviour> AtLeastCheckerOption<T, S>.butAtMost(times: Int): ButAtMostCheckerOption<T, S> =\n    ButAtMostCheckerOptionImpl(times, this, containsBuilder)\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the value which we\n * are looking for occurs `exactly` number of [times] within the search input.\n *\n * @param times The number which the check will compare against the actual number of times an expected value is\n *   found in the input of the search.\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.exactly(times)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.exactly\"\n    )\n)\nfun <T : CharSequence, S : SearchBehaviour> CharSequenceContains.Builder<T, S>.exactly(times: Int): ExactlyCheckerOption<T, S> =\n    ExactlyCheckerOptionImpl(times, this)\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the value which we\n * are looking for occurs `at least` once but `at most` number of [times] within the search input.\n *\n * If you want to use a higher lower bound than one, then use `atLeast(2).butAtMost(3)` instead of `atMost(3)`.\n * And in case you want to state that it is either not contained at all or at most a certain number of times,\n * then use `notOrAtMost(2)` instead.\n *\n * @param times The number which the check will compare against the actual number of times an expected value is\n *   found in the input of the search.\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n * @throws IllegalArgumentException In case [times] equals to one; use [exactly] instead.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.atMost(times)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.atMost\"\n    )\n)\nfun <T : CharSequence, S : SearchBehaviour> CharSequenceContains.Builder<T, S>.atMost(times: Int): AtMostCheckerOption<T, S> =\n    AtMostCheckerOptionImpl(times, this)\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the value which we\n * are looking for occurs `not at all or at most` number of [times] within the search input.\n *\n * @param times The number which the check will compare against the actual number of times an expected value is\n *   found in the input of the search.\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.notOrAtMost(times)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.notOrAtMost\"\n    )\n)\nfun <T : CharSequence, S : SearchBehaviour> CharSequenceContains.Builder<T, S>.notOrAtMost(times: Int): NotOrAtMostCheckerOption<T, S> =\n    NotOrAtMostCheckerOptionImpl(times, this)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.creating.basic.contains.addAssertionForAssert\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.IgnoringCaseSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NoOpSearchBehaviour\nimport ch.tutteli.kbox.glue\nimport kotlin.jvm.JvmName\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected] object shall be searched,\n * using a non disjoint search.\n *\n * Delegates to `values(expected)`.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that 'aa' in 'aaaa' is found three times and not only two times.\n *\n * @param expected The value which is expected to be contained within the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] is not a [CharSequence], [Number] or [Char].\n */\n\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.value(expected)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.value\"\n    )\n)\nfun <T : CharSequence> CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>.value(expected: Any): AssertionPlant<T> =\n    values(expected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected] value as well as\n * the [otherExpected] values shall be searched, using a non disjoint search.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'a'` and [expected]\n * is defined as `'a'` and one [otherExpected] is defined as `'a'` as well, then both match, even though they match the\n * same sequence in the input of the search. Use an option such as [atLeast], [atMost] and [exactly] to control\n * the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `contains.exactly(2).value('a')`\n * instead of:\n *   `contains.atLeast(1).values('a', 'a')`\n *\n * @param expected The value which is expected to be contained within the input of the search.\n * @param otherExpected Additional values which are expected to be contained within the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] or one of the [otherExpected] is not a\n *   [CharSequence], [Number] or [Char].\n */\n\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.values(expected, *otherExpected)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.values\"\n    )\n)\nfun <T : CharSequence> CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>.values(\n    expected: Any,\n    vararg otherExpected: Any\n): AssertionPlant<T> = addAssertion(AssertImpl.charSequence.contains.values(this, expected glue otherExpected))\n\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected] value shall be searched\n * (ignoring case), using a non disjoint search.\n *\n * Delegates to `values(expected)`.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that 'aa' in 'aaaa' is found three times and not only two times.\n *\n * @param expected The value which is expected to be contained within the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] is not a [CharSequence], [Number] or [Char].\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.value(expected)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.value\"\n    )\n)\n@JvmName(\"valueIgnoringCase\")\nfun <T : CharSequence> CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>.value(expected: Any): AssertionPlant<T> =\n    values(expected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected] value as well as\n * the [otherExpected] values shall be searched (ignoring case), using a non disjoint search.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'a'` and [expected]\n * is defined as `'a'` and one [otherExpected] is defined as `'a'` as well, then both match, even though they match the\n * same sequence in the input of the search. Use an option such as [atLeast], [atMost] and [exactly] to control\n * the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `contains.ignoringCase.exactly(2).value('a')`\n * instead of:\n *   `contains.ignoringCase.atLeast(1).values('a', 'a')`\n *\n * @param expected The value which is expected to be contained within the input of the search.\n * @param otherExpected Additional values which are expected to be contained within the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] or one of the [otherExpected] is not a\n *   [CharSequence], [Number] or [Char].\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.values(expected, *otherExpected)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.values\"\n    )\n)\n@JvmName(\"valuesIgnoringCase\")\nfun <T : CharSequence> CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>.values(\n    expected: Any,\n    vararg otherExpected: Any\n): AssertionPlant<T> =\n    addAssertion(AssertImpl.charSequence.contains.valuesIgnoringCase(this, expected glue otherExpected))\n\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected] value shall be searched\n * (ignoring case), using a non disjoint search where it needs to be contained at least once.\n *\n * Delegates to `atLeast(1).values(expected)`.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that 'aa' in 'aaaa' is found three times and not only two times.\n *\n * @param expected The value which is expected to be contained within the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] is not a [CharSequence], [Number] or [Char].\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.value(expected)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.value\"\n    )\n)\nfun <T : CharSequence> CharSequenceContains.Builder<T, IgnoringCaseSearchBehaviour>.value(expected: Any): AssertionPlant<T> =\n    atLeast(1).value(expected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected] value as well as\n * the [otherExpected] values shall be searched (ignoring case), using a non disjoint search\n * where each need to be contained at least once.\n *\n * Delegates to `atLeast(1).values(expected, otherExpected)`\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'a'` and [expected]\n * is defined as `'a'` and one [otherExpected] is defined as `'a'` as well, then both match, even though they match the\n * same sequence in the input of the search.\n *\n * @param expected The value which is expected to be contained within the input of the search.\n * @param otherExpected Additional values which are expected to be contained within the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] or one of the [otherExpected] is not a\n *   [CharSequence], [Number] or [Char].\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.values(expected, *otherExpected)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.values\"\n    )\n)\nfun <T : CharSequence> CharSequenceContains.Builder<T, IgnoringCaseSearchBehaviour>.values(\n    expected: Any,\n    vararg otherExpected: Any\n): AssertionPlant<T> = atLeast(1).values(expected, *otherExpected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the given regular expression [pattern]\n * as well as the [otherPatterns] are expected to have a match, using a non disjoint search.\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'ab'` and [pattern]\n * is defined as `'a(b)?'` and one of the [otherPatterns] is defined as `'a(b)?'` as well, then both match, even though\n * they match the same sequence in the input of the search. Use an option such as [atLeast], [atMost] and [exactly] to\n * control the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `contains.exactly(2).regex('a(b)?')`\n * instead of:\n *   `contains.atLeast(1).regex('a(b)?', 'a(b)?')`\n *\n * @param pattern The pattern which is expected to have a match against the input of the search.\n * @param otherPatterns Additional patterns which are expected to have a match against the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.regex(pattern, *otherPatterns)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.regex\"\n    )\n)\nfun <T : CharSequence> CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>.regex(\n    pattern: String,\n    vararg otherPatterns: String\n): AssertionPlant<T> = addAssertion(AssertImpl.charSequence.contains.regex(this, pattern glue otherPatterns))\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the given regular expression [pattern]\n * as well as the [otherPatterns] are expected to have a match (ignoring case), using a non disjoint search.\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'ab'` and [pattern]\n * is defined as `'a(b)?'` and one of the [otherPatterns] is defined as `'a(b)?'` as well, then both match, even though\n * they match the same sequence in the input of the search. Use an option such as [atLeast], [atMost] and [exactly] to\n * control the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `contains.ignoringCase.exactly(2).regex('a(b)?')`\n * instead of:\n *   `contains.ignoringCase.atLeast(1).regex('a(b)?', 'a(b)?')`\n *\n * @param pattern The pattern which is expected to have a match against the input of the search.\n * @param otherPatterns Additional patterns which are expected to have a match against the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@JvmName(\"regexIgnoringCase\")\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.regex(pattern, *otherPatterns)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.regex\"\n    )\n)\nfun <T : CharSequence> CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>.regex(\n    pattern: String,\n    vararg otherPatterns: String\n): AssertionPlant<T> =\n    addAssertion(AssertImpl.charSequence.contains.regexIgnoringCase(this, pattern glue otherPatterns))\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the given regular expression [pattern]\n * as well as the [otherPatterns] are expected to to have at least one match (ignoring case),\n * using a non disjoint search.\n *\n * Delegates to `atLeast(1).regex(pattern, otherPatterns)`\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'ab'` and [pattern]\n * is defined as `'a(b)?'` and one of the [otherPatterns] is defined as `'a(b)?'` as well, then both match, even though\n * they match the same sequence in the input of the search. Use an option such as [atLeast], [atMost] and [exactly]\n * to control the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `contains.ignoringCase.exactly(2).regex('a(b)?')`\n * instead of:\n *   `contains.ignoringCase.atLeast(1).regex('a(b)?', 'a(b)?')`\n *\n * @param pattern The pattern which is expected to have a match against the input of the search.\n * @param otherPatterns Additional patterns which are expected to have a match against the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.regex(pattern, *otherPatterns)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.regex\"\n    )\n)\nfun <T : CharSequence> CharSequenceContains.Builder<T, IgnoringCaseSearchBehaviour>.regex(\n    pattern: String,\n    vararg otherPatterns: String\n): AssertionPlant<T> = atLeast(1).regex(pattern, *otherPatterns)\n\n/**\n * Helper method to simplify adding assertions to the plant which itself is stored in\n * [CharSequenceContains.CheckerOption.containsBuilder].\n *\n * @return The plant to support a fluent API.\n */\nprivate fun <T : CharSequence, S : CharSequenceContains.SearchBehaviour> CharSequenceContains.CheckerOption<T, S>.addAssertion(\n    assertion: Assertion\n): AssertionPlant<T> = addAssertionForAssert(assertion)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.NotCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.impl.NotCheckerOptionImpl\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.IgnoringCaseSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NoOpSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NotSearchBehaviour\n\n/**\n * Defines that the v behaviour `ignore case` shall be applied to this sophisticated `contains` assertion.\n *\n * @return The newly created builder.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.ignoringCase\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.ignoringCase\"\n    )\n)\nval <T : CharSequence> CharSequenceContains.Builder<T, NoOpSearchBehaviour>.ignoringCase\n    get() : CharSequenceContains.Builder<T, IgnoringCaseSearchBehaviour>\n    = AssertImpl.charSequence.contains.searchBehaviours.ignoringCase(this)\n\n/**\n * Defines that the search behaviour `ignore case` shall be applied to this sophisticated `contains not` assertion.\n *\n * @return The newly created builder.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.ignoringCase\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.ignoringCase\"\n    )\n)\nval <T : CharSequence> NotCheckerOption<T, NotSearchBehaviour>.ignoringCase\n    get() : NotCheckerOption<T, IgnoringCaseSearchBehaviour>\n    = NotCheckerOptionImpl(containsBuilder.ignoringCase)\n","// TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"TYPEALIAS_EXPANSION_DEPRECATION\")\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s [Collection.size] is [size].\n *\n * Shortcut for `size.toBe(expectedSize)` depends on the underlying implementation though.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().hasSize(size).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.hasSize\"\n    )\n)\nfun <T : Collection<*>> Assert<T>.hasSize(size: Int)\n    = addAssertion(AssertImpl.collection.hasSize(this, size))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is an empty [Collection].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().isEmpty().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isEmpty\"\n    )\n)\nfun <T : Collection<*>> Assert<T>.isEmpty()\n    = addAssertion(AssertImpl.collection.isEmpty(this))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is not an empty [Collection].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().isNotEmpty().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isNotEmpty\"\n    )\n)\nfun <T : Collection<*>> Assert<T>.isNotEmpty()\n    = addAssertion(AssertImpl.collection.isNotEmpty(this))\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property\n * [size][Collection.size] so that further fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().size\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.size\"\n    )\n)\nval Assert<Collection<*>>.size get(): Assert<Int> = property(Collection<*>::size)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [size][Collection.size]\n * holds all assertions the given [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().size.asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.size\"\n    )\n)\nfun <E, T: Collection<E>> Assert<T>.size(assertionCreator: Assert<Int>.() -> Unit): Assert<T>\n    = addAssertion(AssertImpl.collection.size(this, assertionCreator))\n","@file:Suppress(\n/* TODO remove annotation with 1.0.0 */ \"DEPRECATION\",\n/* TODO remove annotation with 1.0.0 */ \"TYPEALIAS_EXPANSION_DEPRECATION\",\n    \"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\"\n)\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.CollectionAssertions\nimport ch.tutteli.atrium.domain.creating.collectionAssertions\n\n/**\n * Delegates inter alia to the implementation of [CollectionAssertions].\n * In detail, it implements [CollectionAssertions] by delegating to [collectionAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\nobject CollectionAssertionsBuilder : CollectionAssertions {\n\n    override inline fun isEmpty(subjectProvider: SubjectProvider<Collection<*>>) =\n        collectionAssertions.isEmpty(subjectProvider)\n\n    override inline fun isNotEmpty(subjectProvider: SubjectProvider<Collection<*>>) =\n        collectionAssertions.isNotEmpty(subjectProvider)\n\n    override inline fun <T : Collection<*>> size(expect: Expect<T>) =\n        collectionAssertions.size(expect)\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun hasSize(plant: AssertionPlant<Collection<*>>, size: Int) =\n        collectionAssertions.hasSize(plant, size)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun size(plant: AssertionPlant<Collection<*>>, noinline assertionCreator: Assert<Int>.() -> Unit) =\n        collectionAssertions.size(plant, assertionCreator)\n}\n","// TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"TYPEALIAS_EXPANSION_DEPRECATION\")\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is less than [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().isLessThan(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isLessThan\"\n    )\n)\nfun <T : Comparable<T>> Assert<T>.isLessThan(expected: T)\n    = addAssertion(AssertImpl.comparable.isLessThan(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is less than or equals [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().isLessThanOrEqual(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isLessThanOrEqual\"\n    )\n)\nfun <T : Comparable<T>> Assert<T>.isLessOrEquals(expected: T)\n    = addAssertion(AssertImpl.comparable.isLessOrEquals(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is greater than [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().isGreaterThan(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isGreaterThan\"\n    )\n)\nfun <T : Comparable<T>> Assert<T>.isGreaterThan(expected: T)\n    = addAssertion(AssertImpl.comparable.isGreaterThan(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is greater than or equals [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().isGreaterThanOrEqual(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isGreaterThanOrEqual\"\n    )\n)\nfun <T : Comparable<T>> Assert<T>.isGreaterOrEquals(expected: T)\n    = addAssertion(AssertImpl.comparable.isGreaterOrEquals(this, expected))\n\n","//TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.ComparableAssertions\nimport ch.tutteli.atrium.domain.creating.comparableAssertions\n\n/**\n * Delegates inter alia to the implementation of [ComparableAssertions].\n * In detail, it implements [ComparableAssertions] by delegating to [comparableAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\nobject ComparableAssertionsBuilder : ComparableAssertions {\n\n    override inline fun <T1 : Comparable<T2>, T2 : Any?> isLessThan(\n        subjectProvider: SubjectProvider<T1>,\n        expected: T2\n    ) = comparableAssertions.isLessThan(subjectProvider, expected)\n\n    override inline fun <T1 : Comparable<T2>, T2 : Any?> isLessOrEquals(\n        subjectProvider: SubjectProvider<T1>,\n        expected: T2\n    ) = comparableAssertions.isLessOrEquals(subjectProvider, expected)\n\n    override inline fun <T1 : Comparable<T2>, T2 : Any?> isGreaterThan(\n        subjectProvider: SubjectProvider<T1>,\n        expected: T2\n    ) = comparableAssertions.isGreaterThan(subjectProvider, expected)\n\n    override inline fun <T1 : Comparable<T2>, T2 : Any?> isGreaterOrEquals(\n        subjectProvider: SubjectProvider<T1>,\n        expected: T2\n    ) = comparableAssertions.isGreaterOrEquals(subjectProvider, expected)\n\n    override inline fun <T1 : Comparable<T2>, T2> isEqualComparingTo(\n        expect: Expect<T1>,\n        expected: T2\n    ) = comparableAssertions.isEqualComparingTo(expect, expected)\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.atLeast\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.AtLeastCheckerOption\nimport ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders.AtLeastCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n * Represents the builder of a `contains at least`-check within the fluent API of a sophisticated\n * `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor Represents the builder of a `contains at least` check within the fluent API of a sophisticated\n *   `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n */\ninternal class AtLeastCheckerOptionImpl<out T : CharSequence, out S : CharSequenceContains.SearchBehaviour>(\n    times: Int,\n    containsBuilder: CharSequenceContains.Builder<T, S>\n) : AtLeastCheckerOptionBase<T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"${containsBuilder::atLeast.name}($it)\" }\n), AtLeastCheckerOption<T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.atLeast\nimport ch.tutteli.atrium.api.cc.en_GB.atMost\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.AtMostCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.exactly\nimport ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders.AtMostCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n * Represents the builder of a `contains at least once but at most` check within the fluent API of a\n * sophisticated `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor Represents the builder of a `contains at least once but at most` check within the fluent API of a\n *   sophisticated `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n */\ninternal class AtMostCheckerOptionImpl<out T : CharSequence, out S : CharSequenceContains.SearchBehaviour>(\n    times: Int,\n    containsBuilder: CharSequenceContains.Builder<T, S>\n) : AtMostCheckerOptionBase<T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"${containsBuilder::atMost.name}($it)\" },\n    { \"${containsBuilder::atLeast.name}($it)\" },\n    { \"${containsBuilder::exactly.name}($it)\" }\n), AtMostCheckerOption<T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.atLeast\nimport ch.tutteli.atrium.api.cc.en_GB.atMost\nimport ch.tutteli.atrium.api.cc.en_GB.butAtMost\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.AtLeastCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.ButAtMostCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.exactly\nimport ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders.ButAtMostCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n * Represents the builder of the second step of a `contains at least but at most` check within the\n * fluent API of a sophisticated `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied to the input of the search.\n *\n * @constructor Represents the builder of the second step of a `contains at least but at most` check within the\n *   fluent API of a sophisticated `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n */\ninternal class ButAtMostCheckerOptionImpl<out T : CharSequence, out S : CharSequenceContains.SearchBehaviour>(\n    times: Int,\n    atLeastBuilder: AtLeastCheckerOption<T, S>,\n    containsBuilder: CharSequenceContains.Builder<T, S>\n) : ButAtMostCheckerOptionBase<T, S>(\n    times,\n    atLeastBuilder,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { l, u -> \"${containsBuilder::atLeast.name}($l).${atLeastBuilder::butAtMost.name}($u)\" },\n    { \"${containsBuilder::atMost.name}($it)\" },\n    { \"${containsBuilder::atLeast.name}($it)\" },\n    { \"${atLeastBuilder::butAtMost.name}($it)\" },\n    { \"${containsBuilder::exactly.name}($it)\" }\n), ButAtMostCheckerOption<T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.ExactlyCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.exactly\nimport ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders.ExactlyCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n * Represents the builder of a `contains exactly` check within the fluent API of a sophisticated\n * `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor Represents the builder of a `contains exactly` check within the fluent API of a sophisticated\n *   `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n */\ninternal class ExactlyCheckerOptionImpl<out T : CharSequence, out S : CharSequenceContains.SearchBehaviour>(\n    times: Int,\n    containsBuilder: CharSequenceContains.Builder<T, S>\n) : ExactlyCheckerOptionBase<T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"${containsBuilder::exactly.name}($it)\" }\n), ExactlyCheckerOption<T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.NotCheckerOption\nimport ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders.NotCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n *  Represents the builder of a `contains not at all` check within the fluent API of a sophisticated\n * `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor Represents the builder of a `contains not at all` check within the fluent API of a sophisticated\n *   `contains` assertion for [CharSequence].\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n */\ninternal class NotCheckerOptionImpl<out T : CharSequence, out S : CharSequenceContains.SearchBehaviour>(\n    containsBuilder: CharSequenceContains.Builder<T, S>\n) : NotCheckerOptionBase<T, S>(containsBuilder),\n    NotCheckerOption<T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.NotOrAtMostCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.notOrAtMost\nimport ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders.NotOrAtMostCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n * Represents the builder of a `contains not or at most` check within the fluent API of a\n * sophisticated `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor Represents the builder of a `contains not or at most` check within the fluent API of a\n *   sophisticated `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n */\ninternal class NotOrAtMostCheckerOptionImpl<out T : CharSequence, out S : CharSequenceContains.SearchBehaviour>(\n    times: Int,\n    containsBuilder: CharSequenceContains.Builder<T, S>\n) : NotOrAtMostCheckerOptionBase<T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"${containsBuilder::notOrAtMost.name}($it)\" }\n), NotOrAtMostCheckerOption<T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.containsNot\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport kotlin.reflect.KFunction3\n\ninternal fun nameContainsNotValuesFun(): String {\n    val f: KFunction3<AssertionPlant<CharSequence>, Any, Array<out Any>, AssertionPlant<CharSequence>> = AssertionPlant<CharSequence>::containsNot\n    return f.name\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.atLeast\nimport ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.AtLeastCheckerOption\nimport ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders.AtLeastCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Represents the builder of a `contains at least` check within the fluent API of a sophisticated\n * `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n *\n * @constructor Represents the builder of a `contains at least` check within the fluent API of a sophisticated\n *   `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n */\ninternal class AtLeastCheckerOptionImpl<out E, out T : Iterable<E>, out S : InAnyOrderSearchBehaviour>(\n    times: Int,\n    containsBuilder: IterableContains.Builder<E, T, S>\n) : AtLeastCheckerOptionBase<E, T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"${containsBuilder::atLeast.name}($it)\" }\n), AtLeastCheckerOption<E, T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.atLeast\nimport ch.tutteli.atrium.api.cc.en_GB.atMost\nimport ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.AtMostCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.exactly\nimport ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders.AtMostCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Represents the builder of a `contains at least once but at most` check within the fluent API of a\n * sophisticated `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n *\n * @constructor Represents the builder of a `contains at least once but at most` check within the fluent API of a\n *   sophisticated `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n */\ninternal class AtMostCheckerOptionImpl<out E, out T : Iterable<E>, out S : InAnyOrderSearchBehaviour>(\n    times: Int,\n    containsBuilder: IterableContains.Builder<E, T, S>\n) : AtMostCheckerOptionBase<E, T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"${containsBuilder::atMost.name}($it)\" },\n    { \"${containsBuilder::atLeast.name}($it)\" },\n    { \"${containsBuilder::exactly.name}($it)\" }\n), AtMostCheckerOption<E, T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.atLeast\nimport ch.tutteli.atrium.api.cc.en_GB.atMost\nimport ch.tutteli.atrium.api.cc.en_GB.butAtMost\nimport ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.AtLeastCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.ButAtMostCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.exactly\nimport ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders.ButAtMostCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Represents the builder of the second step of a `contains at least but at most` check within the\n * fluent API of a sophisticated `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n *\n * @constructor Represents the builder of the second step of a `contains at least but at most` check within the\n *   fluent API of a sophisticated `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n */\ninternal class ButAtMostCheckerOptionImpl<out E, out T : Iterable<E>, out S : InAnyOrderSearchBehaviour>(\n    times: Int,\n    atLeastBuilder: AtLeastCheckerOption<E, T, S>,\n    containsBuilder: IterableContains.Builder<E, T, S>\n) : ButAtMostCheckerOptionBase<E, T, S>(\n    times,\n    atLeastBuilder,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { l, u -> \"${containsBuilder::atLeast.name}($l).${atLeastBuilder::butAtMost.name}($u)\" },\n    { \"${containsBuilder::atMost.name}($it)\" },\n    { \"${containsBuilder::atLeast.name}($it)\" },\n    { \"${atLeastBuilder::butAtMost.name}($it)\" },\n    { \"${containsBuilder::exactly.name}($it)\" }\n), ButAtMostCheckerOption<E, T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.ExactlyCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.exactly\nimport ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders.ExactlyCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Represents the builder of a `contains exactly` check within the fluent API of a sophisticated\n * `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n *\n * @constructor Represents the builder of a `contains exactly` check within the fluent API of a sophisticated\n *   `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n */\ninternal class ExactlyCheckerOptionImpl<out E, out T : Iterable<E>, out S : InAnyOrderSearchBehaviour>(\n    times: Int,\n    containsBuilder: IterableContains.Builder<E, T, S>\n) : ExactlyCheckerOptionBase<E, T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"${containsBuilder::exactly.name}($it)\" }\n), ExactlyCheckerOption<E, T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.NotCheckerOption\nimport ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders.NotCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Represents the builder of a `contains not at all` check within the fluent API of a sophisticated\n * `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor Represents the builder of a `contains not at all` check within the fluent API of a sophisticated\n *   `contains not` assertion for [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n */\ninternal class NotCheckerOptionImpl<out E, out T : Iterable<E>, out S : InAnyOrderSearchBehaviour>(\n    containsBuilder: IterableContains.Builder<E, T, S>\n) : NotCheckerOptionBase<E, T, S>(containsBuilder),\n    NotCheckerOption<E, T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.NotOrAtMostCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.notOrAtMost\nimport ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders.NotOrAtMostCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Represents the builder of a `contains not or at most` check within the fluent API of a\n * sophisticated `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n *\n * @constructor Represents the builder of a `contains at least once but at most` check within the fluent API of a\n *   sophisticated `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n */\ninternal class NotOrAtMostCheckerOptionImpl<out E, out T : Iterable<E>, out S : InAnyOrderSearchBehaviour>(\n    times: Int,\n    containsBuilder: IterableContains.Builder<E, T, S>\n) : NotOrAtMostCheckerOptionBase<E, T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"${containsBuilder::notOrAtMost.name}($it)\" }\n), NotOrAtMostCheckerOption<E, T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.containsNot\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport kotlin.reflect.KFunction3\n\ninternal fun nameContainsNotValuesFun(): String {\n    val f: KFunction3<AssertionPlant<Iterable<Double>>, Double, Array<out Double>, AssertionPlant<Iterable<Double>>> =\n        AssertionPlant<Iterable<Double>>::containsNot\n    return f.name\n}\n","// TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"TYPEALIAS_EXPANSION_DEPRECATION\")\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.assertions.AssertionGroup\nimport ch.tutteli.atrium.assertions.FeatureAssertionGroupType\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.CollectingAssertionPlant\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.creating.PleaseUseReplacementException\nimport kotlin.reflect.*\nimport kotlin.jvm.JvmName\n\n/**\n * Creates an [AssertionPlant] for the given [property] which eventually adds [AssertionGroup]s with a\n * [FeatureAssertionGroupType], containing the assertions created for the given [property], to the current plant.\n *\n * @return An [AssertionPlant] for the given [property].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(property) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, TProperty : Any> Assert<T>.property(property: KProperty0<TProperty>): AssertionPlant<TProperty>\n    = AssertImpl.feature.property(this, property)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KProperty1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, TProperty : Any> CollectingAssertionPlant<T>.property(property: KProperty0<TProperty>): AssertionPlant<TProperty>\n    = throw PleaseUseReplacementException(\"Use the overload with KProperty1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant] for the given [property] which eventually adds [AssertionGroup]s with a\n * [FeatureAssertionGroupType], containing the assertions created for the given [property], to the current plant.\n *\n * @return An [AssertionPlant] for the given [property].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature(property).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, TProperty : Any> Assert<T>.property(property: KProperty1<T, TProperty>): AssertionPlant<TProperty>\n    = AssertImpl.feature.property(this, property)\n\n\n/**\n * Creates an [AssertionPlant] for the given [property] which eventually adds [AssertionGroup]s with a\n * [FeatureAssertionGroupType], containing the assertions created for the given [property], to the current plant --\n * starting with a group consisting of the [Assertion]s created by the [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the given [property].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature({ f(property) }, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, TProperty : Any> Assert<T>.property(property: KProperty0<TProperty>, assertionCreator: Assert<TProperty>.() -> Unit): AssertionPlant<TProperty>\n    = AssertImpl.feature.property(this, property, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KProperty1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, TProperty : Any> CollectingAssertionPlant<T>.property(property: KProperty0<TProperty>, assertionCreator: Assert<TProperty>.() -> Unit): AssertionPlant<TProperty>\n    = throw PleaseUseReplacementException(\"Use the overload with KProperty1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant] for the given [property] which eventually adds [AssertionGroup]s with a\n * [FeatureAssertionGroupType], containing the assertions created for the given [property], to the current plant --\n * starting with a group consisting of the [Assertion]s created by the [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the given [property].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature(property, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, TProperty : Any> Assert<T>.property(property: KProperty1<T, TProperty>, assertionCreator: Assert<TProperty>.() -> Unit): AssertionPlant<TProperty>\n    = AssertImpl.feature.property(this, property, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable] for the given [property] which eventually adds [AssertionGroup]s with a\n * [FeatureAssertionGroupType], containing the assertions created for the given [property], to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(property) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, TProperty : Any?> Assert<T>.property(property: KProperty0<TProperty>): AssertionPlantNullable<TProperty>\n    = AssertImpl.feature.property(this, property)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KProperty1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, TProperty : Any?> CollectingAssertionPlant<T>.property(property: KProperty0<TProperty>): AssertionPlantNullable<TProperty>\n    = throw PleaseUseReplacementException(\"Use the overload with KProperty1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable] for the given [property] which eventually adds [AssertionGroup]s with a\n * [FeatureAssertionGroupType], containing the assertions created for the given [property], to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature(property).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, TProperty : Any?> Assert<T>.property(property: KProperty1<T, TProperty>): AssertionPlantNullable<TProperty>\n    = AssertImpl.feature.property(this, property)\n\n\n// Arg 0 ----------------------------------------------------------------------------\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method], which eventually adds [AssertionGroup]s\n * with a [FeatureAssertionGroupType], containing the assertions created for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(method) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, R : Any> Assert<T>.returnValueOf(method: KFunction0<R>): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf0(this, method)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction0<R>): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method], which eventually adds [AssertionGroup]s\n * with a [FeatureAssertionGroupType], containing the assertions created for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature(method).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, R : Any> Assert<T>.returnValueOf(method: KFunction1<T, R>): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf0(this, method)\n\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature({ f(method) }, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, R : Any> Assert<T>.returnValueOf(method: KFunction0<R>, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf0(this, method, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction0<R>, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, R : Any> Assert<T>.returnValueOf(method: KFunction1<T, R>, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf0(this, method, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(method) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, R : Any?> Assert<T>.returnValueOf(method: KFunction0<R>): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf0(this, method)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, R : Any?> CollectingAssertionPlant<T>.returnValueOf(method: KFunction0<R>): AssertionPlantNullable<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature(method).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, R : Any?> Assert<T>.returnValueOf(method: KFunction1<T, R>): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf0(this, method)\n\n\n// Arg 1 ----------------------------------------------------------------------------\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(method, arg1) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, R : Any> Assert<T>.returnValueOf(method: KFunction1<T1, R>, arg1: T1): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf1(this, method, arg1)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction2 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction1<T1, R>, arg1: T1): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction2 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@JvmName(\"safeReturnValueOf\")\n//TODO deprecate as soon as https://youtrack.jetbrains.com/issue/KT-33398 is fixed\n//@Deprecated(\n//    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n//    ReplaceWith(\n//        \"this.asExpect().feature(method, arg1).asAssert()\",\n//        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n//        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n//        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n//    )\n//)\nfun <T : Any, T1, R : Any> Assert<T>.returnValueOf(method: KFunction2<T, T1, R>, arg1: T1): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf1(this, method, arg1)\n\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature({ f(method, arg1) }, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, R : Any> Assert<T>.returnValueOf(method: KFunction1<T1, R>, arg1: T1, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf1(this, method, arg1, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction2 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction1<T1, R>, arg1: T1, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction2 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, R : Any> Assert<T>.returnValueOf(method: KFunction2<T, T1, R>, arg1: T1, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf1(this, method, arg1, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(method, arg1) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, R : Any?> Assert<T>.returnValueOf(method: KFunction1<T1, R>, arg1: T1): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf1(this, method, arg1)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction2 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, R : Any?> CollectingAssertionPlant<T>.returnValueOf(method: KFunction1<T1, R>, arg1: T1): AssertionPlantNullable<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction2 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, R : Any?> Assert<T>.returnValueOf(method: KFunction2<T, T1, R>, arg1: T1): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf1(this, method, arg1)\n\n\n// Arg 2 ----------------------------------------------------------------------------\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1] and [arg2], which eventually\n * adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(method, arg1, arg2) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, R : Any> Assert<T>.returnValueOf(method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf2(this, method, arg1, arg2)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction3 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction3 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1] and [arg2], which eventually\n * adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, arg2).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, R : Any> Assert<T>.returnValueOf(method: KFunction3<T, T1, T2, R>, arg1: T1, arg2: T2): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf2(this, method, arg1, arg2)\n\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1] and [arg2], which eventually\n * adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature({ f(method, arg1, arg2) }, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, R : Any> Assert<T>.returnValueOf(method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf2(this, method, arg1, arg2, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction3 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction3 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1] and [arg2], which eventually\n * adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, arg2, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, R : Any> Assert<T>.returnValueOf(method: KFunction3<T, T1, T2, R>, arg1: T1, arg2: T2, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf2(this, method, arg1, arg2, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1] and [arg2], which\n * eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for\n * the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(method, arg1, arg2) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, R : Any?> Assert<T>.returnValueOf(method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf2(this, method, arg1, arg2)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction3 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, R : Any?> CollectingAssertionPlant<T>.returnValueOf(method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2): AssertionPlantNullable<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction3 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1] and [arg2], which\n * eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for\n * the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, arg2).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, R : Any?> Assert<T>.returnValueOf(method: KFunction3<T, T1, T2, R>, arg1: T1, arg2: T2): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf2(this, method, arg1, arg2)\n\n\n// Arg 3 ----------------------------------------------------------------------------\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2] and [arg3],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(method, arg1, arg2, arg3) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, R : Any> Assert<T>.returnValueOf(method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf3(this, method, arg1, arg2, arg3)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction4 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction4 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2] and [arg3],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, arg2, arg3).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, R : Any> Assert<T>.returnValueOf(method: KFunction4<T, T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf3(this, method, arg1, arg2, arg3)\n\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2] and [arg3],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature({ f(method, arg1, arg2, arg3, arg4) }, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, R : Any> Assert<T>.returnValueOf(method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf3(this, method, arg1, arg2, arg3, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction4 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction4 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2] and [arg3],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, arg2, arg3, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, R : Any> Assert<T>.returnValueOf(method: KFunction4<T, T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf3(this, method, arg1, arg2, arg3, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], [arg2] and [arg3],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for\n * the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(method, arg1, arg2, arg3) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, R : Any?> Assert<T>.returnValueOf(method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf3(this, method, arg1, arg2, arg3)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction4 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, R : Any?> CollectingAssertionPlant<T>.returnValueOf(method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlantNullable<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction4 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], [arg2] and [arg3],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for\n * the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, arg2, arg3).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, R : Any?> Assert<T>.returnValueOf(method: KFunction4<T, T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf3(this, method, arg1, arg2, arg3)\n\n\n// Arg 4 ----------------------------------------------------------------------------\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3] and [arg4],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(method, arg1, arg2, arg3, arg4) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, T4, R : Any> Assert<T>.returnValueOf(method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf4(this, method, arg1, arg2, arg3, arg4)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction5 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, T4, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction5 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3] and [arg4],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, arg2, arg3, arg4).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, T4, R : Any> Assert<T>.returnValueOf(method: KFunction5<T, T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf4(this, method, arg1, arg2, arg3, arg4)\n\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3] and [arg4],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature({ f(method, arg1, arg2, arg3, arg4) }, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, T4, R : Any> Assert<T>.returnValueOf(method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf4(this, method, arg1, arg2, arg3, arg4, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction5 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, T4, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction5 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3] and [arg4],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, arg2, arg3, arg4, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, T4, R : Any> Assert<T>.returnValueOf(method: KFunction5<T, T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf4(this, method, arg1, arg2, arg3, arg4, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], [arg2], [arg3]\n * and [arg4], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions\n * created for the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(method, arg1, arg2, arg3, arg4) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, T4, R : Any?> Assert<T>.returnValueOf(method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf4(this, method, arg1, arg2, arg3, arg4)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction5 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, T4, R : Any?> CollectingAssertionPlant<T>.returnValueOf(method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlantNullable<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction5 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], [arg2], [arg3]\n * and [arg4], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions\n * created for the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, arg2, arg3, arg4).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, T4, R : Any?> Assert<T>.returnValueOf(method: KFunction5<T, T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf4(this, method, arg1, arg2, arg3, arg4)\n\n\n// Arg 5 ----------------------------------------------------------------------------\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3], [arg4]\n * and [arg5], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions\n * created for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(method, arg1, arg2, arg3, arg4, arg5) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, T4, T5, R : Any> Assert<T>.returnValueOf(method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf5(this, method, arg1, arg2, arg3, arg4, arg5)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction6 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, T4, T5, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction6 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3], [arg4]\n * and [arg5], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions\n * created for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, arg2, arg3, arg4, arg5).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, T4, T5, R : Any> Assert<T>.returnValueOf(method: KFunction6<T, T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf5(this, method, arg1, arg2, arg3, arg4, arg5)\n\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3], [arg4]\n * and [arg5], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions\n * created for the return value, to the current plant -- starting with a group consisting of the [Assertion]s created\n * by the [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature({ f(method, arg1, arg2, arg3, arg4, arg5) }, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, T4, T5, R : Any> Assert<T>.returnValueOf(method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf5(this, method, arg1, arg2, arg3, arg4, arg5, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction6 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, T4, T5, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction6 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3], [arg4]\n * and [arg5], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions\n * created for the return value, to the current plant -- starting with a group consisting of the [Assertion]s created\n * by the [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, arg2, arg3, arg4, arg5, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, T4, T5, R : Any> Assert<T>.returnValueOf(method: KFunction6<T, T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf5(this, method, arg1, arg2, arg3, arg4, arg5, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], [arg2], [arg3],\n * [arg4] and [arg5], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the\n * assertions created for the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(method, arg1, arg2, arg3, arg4, arg5) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, T4, T5, R : Any?> Assert<T>.returnValueOf(method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf5(this, method, arg1, arg2, arg3, arg4, arg5)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction6 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, T4, T5, R : Any?> CollectingAssertionPlant<T>.returnValueOf(method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlantNullable<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction6 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], [arg2], [arg3],\n * [arg4] and [arg5], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the\n * assertions created for the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, arg2, arg3, arg4, arg5).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, T4, T5, R : Any?> Assert<T>.returnValueOf(method: KFunction6<T, T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf5(this, method, arg1, arg2, arg3, arg4, arg5)\n","// TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"TYPEALIAS_EXPANSION_DEPRECATION\")\n@file:JvmMultifileClass\n@file:JvmName(\"FloatingPointAssertionsKt\")\n\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is equal to [expected] with an error [tolerance]\n * (range including bounds).\n *\n * It effectively compares the absolute difference between [Assert.subject][SubjectProvider.subject] and [expected] and compares it with\n * the [tolerance]. As long as it is less than or equal the [tolerance] the assertion holds; otherwise it fails.\n * A more mathematical way of expressing the assertion is the following inequality:\n *\n * | [Assert.subject][SubjectProvider.subject] - [expected] | \u2264 [tolerance]\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().toBeWithErrorTolerance(expected, tolerance).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.toBeWithErrorTolerance\"\n    )\n)\nfun Assert<Float>.toBeWithErrorTolerance(expected: Float, tolerance: Float)\n    = addAssertion(AssertImpl.floatingPoint.toBeWithErrorTolerance(this, expected, tolerance))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is equal to [expected] with an error [tolerance]\n * (range including bounds).\n *\n * It effectively compares the absolute difference between [Assert.subject][SubjectProvider.subject] and [expected] and compares it with\n * the [tolerance]. As long as it is less than or equal the [tolerance] the assertion holds; otherwise it fails.\n * A more mathematical way of expressing the assertion is the following inequality:\n *\n * | [Assert.subject][SubjectProvider.subject] - [expected] | \u2264 [tolerance]\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().toBeWithErrorTolerance(expected, tolerance).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.toBeWithErrorTolerance\"\n    )\n)\nfun Assert<Double>.toBeWithErrorTolerance(expected: Double, tolerance: Double)\n    = addAssertion(AssertImpl.floatingPoint.toBeWithErrorTolerance(this, expected, tolerance))\n","//TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.FloatingPointAssertions\nimport ch.tutteli.atrium.domain.creating.floatingPointAssertions\n\n/**\n * Delegates inter alia to the implementation of [FloatingPointAssertions].\n * In detail, it implements [FloatingPointAssertions] by delegating to [floatingPointAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\nactual object FloatingPointAssertionsBuilder : FloatingPointAssertions {\n\n    override inline fun toBeWithErrorTolerance(\n        subjectProvider: SubjectProvider<Float>,\n        expected: Float,\n        tolerance: Float\n    ) = floatingPointAssertions.toBeWithErrorTolerance(subjectProvider, expected, tolerance)\n\n    override inline fun toBeWithErrorTolerance(\n        subjectProvider: SubjectProvider<Double>,\n        expected: Double,\n        tolerance: Double\n    ) = floatingPointAssertions.toBeWithErrorTolerance(subjectProvider, expected, tolerance)\n}\n","// TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"TYPEALIAS_EXPANSION_DEPRECATION\")\n@file:JvmMultifileClass\n@file:JvmName(\"IterableAssertionsKt\")\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.NotCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.impl.NotCheckerOptionImpl\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.NoOpSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.NotSearchBehaviour\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Creates an [IterableContains.Builder] based on this [AssertionPlant] which allows to define\n * more sophisticated `contains` assertions.\n *\n * @return The newly created builder.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().contains\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.contains\"\n    )\n)\nval <E, T : Iterable<E>> Assert<T>.contains: IterableContains.Builder<E, T, NoOpSearchBehaviour>\n    get() = AssertImpl.iterable.containsBuilder(this)\n\n/**\n * Creates an [IterableContains.Builder] based on this [AssertionPlant] which allows to define\n * more sophisticated `contains not` assertions.\n *\n * @return The newly created builder.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().containsNot\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.containsNot\"\n    )\n)\nval <E, T : Iterable<E>> Assert<T>.containsNot: NotCheckerOption<E, T, NotSearchBehaviour>\n    get() = NotCheckerOptionImpl(AssertImpl.iterable.containsNotBuilder(this))\n\n\n/**c\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains the\n * [expected] value and the [otherExpected] values (if given).\n *\n * It is a shortcut for `contains.inAnyOrder.atLeast(1).values(expected, *otherExpected)`\n *\n * Notice, that it does not search for unique matches. Meaning, if the iterable is `setOf('a', 'b')` and [expected] is\n * defined as `'a'` and one [otherExpected] is defined as `'a'` as well, then both match, even though they match the\n * same entry. Use an option such as [atLeast], [atMost] and [exactly] to control the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `contains.inAnyOrder.exactly(2).value('a')`\n * instead of:\n *   `contains('a', 'a')`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().contains(expected, *otherExpected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.contains\"\n    )\n)\nfun <E, T: Iterable<E>> Assert<T>.contains(expected: E, vararg otherExpected: E): AssertionPlant<T>\n    = contains.inAnyOrder.atLeast(1).values(expected, *otherExpected)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains an entry holding the\n * assertions created by [assertionCreatorOrNull] or an entry which is `null` in case [assertionCreatorOrNull]\n * is defined as `null`.\n *\n * It is a shortcut for `contains.inAnyOrder.atLeast(1).entry(assertionCreatorOrNull)`\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking\n *   for has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().contains(asSubExpect(assertionCreatorOrNull)).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.contains\"\n    )\n)\nfun <E: Any, T: Iterable<E?>> Assert<T>.contains(assertionCreatorOrNull: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = contains.inAnyOrder.atLeast(1).entry(assertionCreatorOrNull)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains an entry holding the\n * assertions created by [assertionCreatorOrNull] or an entry which is `null` in case [assertionCreatorOrNull]\n * is defined as `null` -- likewise an entry (can be the same) is searched for each\n * of the [otherAssertionCreatorsOrNulls].\n *\n * It is a shortcut for `contains.inAnyOrder.atLeast(1).entries(assertionCreatorOrNull, *otherAssertionCreatorsOrNulls)`\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking\n *   for has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n * @param otherAssertionCreatorsOrNulls Additional identification lambdas which each identify (separately) an entry\n *   which we are looking for (see [assertionCreatorOrNull] for more information).\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().contains(\\n\" +\n            \"asSubExpect(assertionCreatorOrNull),\\n\" +\n            \"*otherAssertionCreatorsOrNulls.map { asSubExpect(it)}.toTypedArray()\\n\" +\n            \").asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.contains\"\n    )\n)\nfun <E: Any, T: Iterable<E?>> Assert<T>.contains(assertionCreatorOrNull: (Assert<E>.() -> Unit)?, vararg otherAssertionCreatorsOrNulls: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = contains.inAnyOrder.atLeast(1).entries(assertionCreatorOrNull, *otherAssertionCreatorsOrNulls)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains only\n * the [expected] value and the [otherExpected] values (if given) in the defined order.\n *\n * It is a shortcut for `contains.inOrder.only.values(expected, *otherExpected)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().containsExactly(expected, *otherExpected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.containsExactly\"\n    )\n)\nfun <E, T : Iterable<E>> Assert<T>.containsExactly(expected: E, vararg otherExpected: E): AssertionPlant<T>\n    = contains.inOrder.only.values(expected, *otherExpected)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains only an entry holding\n * the assertions created by [assertionCreatorOrNull] or only one entry which is `null` in case [assertionCreatorOrNull]\n * is defined as `null`.\n *\n * It is a shortcut for `contains.inOrder.only.entry(assertionCreatorOrNull)`\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking\n *   for has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().containsExactly(asSubExpect(assertionCreatorOrNull)).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.containsExactly\"\n    )\n)\nfun <E : Any, T : Iterable<E?>> Assert<T>.containsExactly(assertionCreatorOrNull: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = contains.inOrder.only.entry(assertionCreatorOrNull)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains only an entry holding\n * the assertions created by [assertionCreatorOrNull] or `null` in case [assertionCreatorOrNull] is defined as `null`\n * and likewise an additional entry for each [otherAssertionCreatorsOrNulls] (if given)\n * whereas the entries have to appear in the defined order.\n *\n * It is a shortcut for `contains.inOrder.only.entries(assertionCreatorOrNull, *otherAssertionCreatorsOrNulls)`\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking\n *   for has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n * @param otherAssertionCreatorsOrNulls Additional identification lambdas which each identify (separately) an entry\n *   which we are looking for (see [assertionCreatorOrNull] for more information).\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().containsExactly(\\n\" +\n            \"asSubExpect(assertionCreatorOrNull),\\n\" +\n            \"*otherAssertionCreatorsOrNulls.map { asSubExpect(it) }.toTypedArray()\\n\" +\n            \").asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.containsExactly\"\n    )\n)\nfun <E : Any, T : Iterable<E?>> Assert<T>.containsExactly(assertionCreatorOrNull: (Assert<E>.() -> Unit)?, vararg otherAssertionCreatorsOrNulls: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = contains.inOrder.only.entries(assertionCreatorOrNull, *otherAssertionCreatorsOrNulls)\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not contain the [expected] value\n * and neither one of the [otherExpected] values (if given).\n *\n *  It is a shortcut for `containsNot.values(expected, *otherExpected)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().containsNot(expected, *otherExpected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.containsNot\"\n    )\n)\nfun <E, T : Iterable<E>> Assert<T>.containsNot(expected: E, vararg otherExpected: E)\n    = containsNot.values(expected, *otherExpected)\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains an entry holding\n * the assertions created by [assertionCreatorOrNull] or an entry which is `null` in case [assertionCreatorOrNull]\n * is defined as `null`.\n *\n * It is a shortcut for `contains.inAnyOrder.atLeast(1).entry(assertionCreatorOrNull)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().any(asSubExpect(assertionCreatorOrNull)).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.any\"\n    )\n)\nfun <E : Any, T : Iterable<E?>> Assert<T>.any(assertionCreatorOrNull: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = contains.inAnyOrder.atLeast(1).entry(assertionCreatorOrNull)\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not contain a single entry\n * which holds all assertions created by [assertionCreatorOrNull] or does not contain a single entry which is `null`\n * in case [assertionCreatorOrNull] is defined as `null`.\n *\n *  It is a shortcut for `containsNot.entry(assertionCreatorOrNull)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().none(asSubExpect(assertionCreatorOrNull)).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.none\"\n    )\n)\nfun <E : Any, T : Iterable<E?>> Assert<T>.none(assertionCreatorOrNull: (Assert<E>.() -> Unit)?)\n    = containsNot.entry(assertionCreatorOrNull)\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] has at least one element and\n * that every element holds all assertions created by the [assertionCreatorOrNull] or that all elements are `null`\n * in case [assertionCreatorOrNull] is defined as `null`.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().all(asSubExpect(assertionCreatorOrNull)).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.all\"\n    )\n)\nfun <E : Any, T : Iterable<E?>> Assert<T>.all(assertionCreatorOrNull: (Assert<E>.() -> Unit)?)\n    = addAssertion(AssertImpl.iterable.all(this, assertionCreatorOrNull))\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.*\nimport ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.impl.*\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the entry which we are looking\n * for occurs `at least` number of [times] within the [Iterable].\n *\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.atLeast(times)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.atLeast\"\n    )\n)\nfun <E, T : Iterable<E>, S: InAnyOrderSearchBehaviour> IterableContains.Builder<E, T, S>.atLeast(times: Int): AtLeastCheckerOption<E, T, S>\n    = AtLeastCheckerOptionImpl(times, this)\n\n/**\n * Restricts a `contains at least` assertion by specifying that the number of occurrences of the entry which we\n * are looking for occurs `at most` number of [times] within the [Iterable].\n *\n * The resulting restriction will be a `contains at least but at most` assertion.\n *\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n * @throws IllegalArgumentException In case [times] of this `at most` restriction equals to the number of the\n *   `at least` restriction; use the [exactly] restriction instead.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.butAtMost(times)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.butAtMost\"\n    )\n)\nfun <E, T : Iterable<E>, S: InAnyOrderSearchBehaviour> AtLeastCheckerOption<E, T, S>.butAtMost(times: Int): ButAtMostCheckerOption<E, T, S>\n    = ButAtMostCheckerOptionImpl(times, this, containsBuilder)\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the entry which we\n * are looking for occurs `exactly` number of [times] within the [Iterable].\n *\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.exactly(times)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.exactly\"\n    )\n)\nfun <E, T : Iterable<E>, S: InAnyOrderSearchBehaviour> IterableContains.Builder<E, T, S>.exactly(times: Int): ExactlyCheckerOption<E, T, S>\n    = ExactlyCheckerOptionImpl(times, this)\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the entry which we\n * are looking for occurs `at least` once but `at most` number of [times] within the [Iterable].\n *\n * If you want to use a higher lower bound than one, then use `atLeast(2).butAtMost(3)` instead of `atMost(3)`.\n * And in case you want to state that it is either not contained at all or at most a certain number of times,\n * then use `notOrAtMost(2)` instead.\n *\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n * @throws IllegalArgumentException In case [times] equals to one; use [exactly] instead.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.atMost(times)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.atMost\"\n    )\n)\nfun <E, T : Iterable<E>, S: InAnyOrderSearchBehaviour> IterableContains.Builder<E, T, S>.atMost(times: Int): AtMostCheckerOption<E, T, S>\n    = AtMostCheckerOptionImpl(times, this)\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the entry which we\n * are looking for occurs `not at all or at most` number of [times] within the [Iterable].\n *\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.notOrAtMost(times)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.notOrAtMost\"\n    )\n)\nfun <E, T : Iterable<E>, S: InAnyOrderSearchBehaviour> IterableContains.Builder<E, T, S>.notOrAtMost(times: Int): NotOrAtMostCheckerOption<E, T, S>\n    = NotOrAtMostCheckerOptionImpl(times, this)\n","// TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"TYPEALIAS_EXPANSION_DEPRECATION\")\n@file:JvmMultifileClass\n@file:JvmName(\"IterableContainsInAnyOrderCreatorsKt\")\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.creating.basic.contains.addAssertionForAssert\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.kbox.glue\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\n\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected]\n * value shall be searched within the [Iterable].\n *\n * Delegates to `values(expected)`.\n *\n * @param expected The value which is expected to be contained within the [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.value(expected)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.value\"\n    )\n)\nfun <E, T : Iterable<E>> IterableContains.CheckerOption<E, T, InAnyOrderSearchBehaviour>.value(expected: E): AssertionPlant<T>\n    = values(expected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected]\n * value as well as the [otherExpected] values (if given) shall be searched within the [Iterable].\n *\n * Notice, that it does not search for unique matches. Meaning, if the iterable is `setOf('a', 'b')` and\n * [expected] is defined as `'a'` and one [otherExpected] is defined as `'a'` as well, then both match,\n * even though they match the same entry. Use an option such as [atLeast], [atMost] and [exactly] to control the\n * number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `contains.inAnyOrder.exactly(2).values('a')`\n * instead of:\n *   `contains.inAnyOrder.atLeast(1).values('a', 'a')`\n *\n * @param expected The object which is expected to be contained within the [Iterable].\n * @param otherExpected Additional objects which are expected to be contained within [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.values(expected, *otherExpected)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.values\"\n    )\n)\nfun <E, T : Iterable<E>> IterableContains.CheckerOption<E, T, InAnyOrderSearchBehaviour>.values(expected: E, vararg otherExpected: E): AssertionPlant<T>\n    = addAssertion(AssertImpl.iterable.contains.valuesInAnyOrder(this, expected glue otherExpected))\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where an entry shall be searched which either\n * holds all assertions [assertionCreatorOrNull] might create or needs to be `null` in case [assertionCreatorOrNull]\n * is defined as `null`.\n *\n * Delegates to `entries(assertionCreatorOrNull)`.\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking\n *   for has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.entry(asSubExpect(assertionCreatorOrNull))\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.entry\"\n    )\n)\nfun <E : Any, T : Iterable<E?>> IterableContains.CheckerOption<E?, T, InAnyOrderSearchBehaviour>.entry(assertionCreatorOrNull: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = entries(assertionCreatorOrNull)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where an entry shall be searched which either\n * holds all assertions [assertionCreatorOrNull] might create or needs to be `null` in case\n * [assertionCreatorOrNull] is defined as `null` -- likewise an entry (can be the same) is searched for each\n * of the [otherAssertionCreatorsOrNulls].\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking\n *   for has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n * @param otherAssertionCreatorsOrNulls Additional identification lambdas which each identify (separately) an entry\n *   which we are looking for (see [assertionCreatorOrNull] for more information).\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.entries(\\n\" +\n            \"asSubExpect(assertionCreatorOrNull),\\n\" +\n            \"*otherAssertionCreatorsOrNulls.map { asSubExpect(it) }.toTypedArray()\\n\" +\n            \")\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.entries\"\n    )\n)\nfun <E : Any, T : Iterable<E?>> IterableContains.CheckerOption<E?, T, InAnyOrderSearchBehaviour>.entries(\n    assertionCreatorOrNull: (Assert<E>.() -> Unit)?,\n    vararg otherAssertionCreatorsOrNulls: (Assert<E>.() -> Unit)?\n): AssertionPlant<T>\n    = addAssertion(AssertImpl.iterable.contains.entriesInAnyOrderWithAssert(this, assertionCreatorOrNull glue otherAssertionCreatorsOrNulls))\n\n/**\n * Helper method to simplify adding assertions to the plant which itself is stored in\n * [CharSequenceContains.CheckerOption.containsBuilder].\n *\n * @return The plant to support a fluent API.\n */\nprivate fun <E, T : Iterable<E>, S : IterableContains.SearchBehaviour> IterableContains.CheckerOption<E, T, S>.addAssertion(\n    assertion: Assertion\n): AssertionPlant<T> = addAssertionForAssert(assertion)\n","// TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"TYPEALIAS_EXPANSION_DEPRECATION\")\n@file:JvmMultifileClass\n@file:JvmName(\"IterableContainsInAnyOrderOnlyCreatorsKt\")\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.creating.basic.contains.addAssertionForAssert\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.kbox.glue\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderOnlySearchBehaviour\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [Iterable] needs to contain only the\n * [expected] value.\n *\n * Delegates to `values(expected)`.\n *\n * @param expected The value which is expected to be contained within the [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.value(expected)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.value\"\n    )\n)\nfun <E , T : Iterable<E>> IterableContains.Builder<E, T, InAnyOrderOnlySearchBehaviour>.value(expected: E): AssertionPlant<T>\n    = values(expected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected]\n * value as well as the [otherExpected] values (if given) need to be\n * contained in [Iterable] where it does not matter in which order but only as\n * many entries should be returned by the [Iterable] as values defined.\n *\n * @param expected The value which is expected to be contained within the [Iterable].\n * @param otherExpected Additional values which are expected to be contained within [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.values(expected, *otherExpected)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.values\"\n    )\n)\nfun <E , T : Iterable<E>> IterableContains.Builder<E, T, InAnyOrderOnlySearchBehaviour>.values(expected: E, vararg otherExpected: E): AssertionPlant<T>\n    = addAssertion(AssertImpl.iterable.contains.valuesInAnyOrderOnly(this, expected glue otherExpected))\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [Iterable] needs to contain only one\n * entry which holds all assertions created by the given [assertionCreatorOrNull] or is `null` in case\n * [assertionCreatorOrNull] is defined as `null`.\n *\n * Delegates to `entries(assertionCreatorOrNull)`.\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking\n *   for has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.entry(asSubExpect(assertionCreatorOrNull))\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.entry\"\n    )\n)\nfun <E : Any, T : Iterable<E?>> IterableContains.Builder<E?, T, InAnyOrderOnlySearchBehaviour>.entry(assertionCreatorOrNull: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = entries(assertionCreatorOrNull)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where an entry needs to be contained in the\n * [Iterable] which holds all assertions [assertionCreatorOrNull] might create or needs to be `null` in case\n * [assertionCreatorOrNull] is defined as `null` -- likewise an entry for each\n * [otherAssertionCreatorsOrNulls] needs to be contained in the [Iterable] where it does not matter in which order the\n * entries appear but only as many entries should be returned by the [Iterable] as assertion creators are defined.\n *\n * Notice, that a first-wins strategy applies which means your assertion creator lambdas -- which kind of serve as\n * identification lambdas -- should be ordered in such a way that the most specific identification lambda appears\n * first, not that a less specific lambda wins. For instance, given a `setOf(1, 2)` you should not search for\n * `entries({ isGreaterThan(0) }, { toBe(1) })` but for\n * `entries({ toBe(1) }, { isGreaterThan(0) })` otherwise\n * `isGreaterThan(0)` matches `1` before `toBe(1)` would match it. As a consequence `toBe(1)` could only match the\n * entry which is left -- in this case `2` -- and of course this would fail.\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking for\n *   has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n * @param otherAssertionCreatorsOrNulls Additional identification lambdas which each identify (separately) an entry\n *   which we are looking for (see [assertionCreatorOrNull] for more information).\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.entries(\\n\" +\n            \"asSubExpect(assertionCreatorOrNull),\\n\" +\n            \"*otherAssertionCreatorsOrNulls.map { asSubExpect(it) }.toTypedArray()\\n\" +\n            \")\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.entries\"\n    )\n)\nfun <E : Any, T : Iterable<E?>> IterableContains.Builder<E?, T, InAnyOrderOnlySearchBehaviour>.entries(\n    assertionCreatorOrNull: (Assert<E>.() -> Unit)?,\n    vararg otherAssertionCreatorsOrNulls: (Assert<E>.() -> Unit)?\n): AssertionPlant<T>\n    = addAssertion(AssertImpl.iterable.contains.entriesInAnyOrderOnlyWithAssert(this, assertionCreatorOrNull glue otherAssertionCreatorsOrNulls))\n\n/**\n * Helper method to simplify adding assertions to the plant which itself is stored in\n * [CharSequenceContains.CheckerOption.containsBuilder].\n *\n * @return The plant to support a fluent API.\n */\ninternal fun <E, T : Iterable<E>, S : IterableContains.SearchBehaviour> IterableContains.Builder<E, T, S>.addAssertion(\n    assertion: Assertion\n): AssertionPlant<T> = addAssertionForAssert(assertion)\n","// TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"TYPEALIAS_EXPANSION_DEPRECATION\")\n@file:JvmMultifileClass\n@file:JvmName(\"IterableContainsInOrderOnlyCreatorsKt\")\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InOrderOnlySearchBehaviour\nimport ch.tutteli.kbox.glue\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [Iterable] needs to contain only the\n * [expected] value.\n *\n * Delegates to `values(expected)`.\n *\n * @param expected The value which is expected to be contained within the [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.value(expected)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.value\"\n    )\n)\nfun <E , T : Iterable<E>> IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>.value(expected: E): AssertionPlant<T>\n    = values(expected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [Iterable] needs to contain only the\n * [expected] value as well as the [otherExpected] values\n * (if given) in the specified order.\n *\n * @param expected The value which is expected to be contained within the [Iterable].\n * @param otherExpected Additional values which are expected to be contained within [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.values(expected, *otherExpected)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.values\"\n    )\n)\nfun <E , T : Iterable<E>> IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>.values(expected: E, vararg otherExpected: E): AssertionPlant<T>\n    = addAssertion(AssertImpl.iterable.contains.valuesInOrderOnly(this, expected glue otherExpected))\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [Iterable] needs to contain only a\n * single entry which holds all assertions created by the given [assertionCreatorOrNull] or needs to be `null`\n * in case [assertionCreatorOrNull] is defined as `null`.\n *\n * Delegates to `entries(assertionCreatorOrNull)`.\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking\n *   for has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.entry(asSubExpect(assertionCreatorOrNull))\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.entry\"\n    )\n)\nfun <E : Any, T : Iterable<E?>> IterableContains.Builder<E?, T, InOrderOnlySearchBehaviour>.entry(assertionCreatorOrNull: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = entries(assertionCreatorOrNull)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [Iterable] needs to contain only an\n * entry which holds all assertions [assertionCreatorOrNull] might create or is `null` in case [assertionCreatorOrNull]\n * is defined as `null` and likewise a further entry for each\n * [otherAssertionCreatorsOrNulls] (if given) whereas the entries have to appear in the specified order.\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking\n *   for has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n * @param otherAssertionCreatorsOrNulls Additional identification lambdas which each identify (separately) an entry\n *   which we are looking for (see [assertionCreatorOrNull] for more information).\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.entries(\\n\" +\n            \"asSubExpect(assertionCreatorOrNull),\\n\" +\n            \"*otherAssertionCreatorsOrNulls.map { asSubExpect(it) }.toTypedArray()\\n\" +\n            \")\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.entries\"\n    )\n)\nfun <E : Any, T : Iterable<E?>> IterableContains.Builder<E?, T, InOrderOnlySearchBehaviour>.entries(\n    assertionCreatorOrNull: (Assert<E>.() -> Unit)?,\n    vararg otherAssertionCreatorsOrNulls: (Assert<E>.() -> Unit)?\n): AssertionPlant<T>\n    = addAssertion(AssertImpl.iterable.contains.entriesInOrderOnlyWithAssert(this, assertionCreatorOrNull glue otherAssertionCreatorsOrNulls))\n","// TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"TYPEALIAS_EXPANSION_DEPRECATION\")\n@file:JvmMultifileClass\n@file:JvmName(\"IterableContainsInOrderOnlyGroupedCreatorsKt\")\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.utils.Group\nimport ch.tutteli.atrium.domain.builders.utils.groupsToList\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InOrderOnlyGroupedWithinSearchBehaviour\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the expected [firstGroup] as well as\n * the [secondGroup] and optionally [otherExpectedGroups] of values need to be contained in [Iterable]\n * as only elements and in the specified order whereas the values within the groups can occur in any order.\n *\n * This function will be renamed on a JVM level to `inAnyOrder` with v1.0.0\n *\n * @param firstGroup A group of values which have to appear at first within the [Iterable].\n * @param secondGroup A group of values which have to appear after the values of the [firstGroup] within the [Iterable].\n * @param otherExpectedGroups Additional groups of values which are expected to appear after the [secondGroup] within\n *   [Iterable] whereas the groups have to appear in the given order.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.inAnyOrder(firstGroup, secondGroup, *otherExpectedGroups)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.inAnyOrder\"\n    )\n)\n@JvmName(\"inAnyOrderNullableValues\")\nfun <E, T : Iterable<E>> IterableContains.Builder<E, T, InOrderOnlyGroupedWithinSearchBehaviour>.inAnyOrder(\n    firstGroup: Group<E>,\n    secondGroup: Group<E>,\n    vararg otherExpectedGroups: Group<E>\n): AssertionPlant<T> = addAssertion(\n    AssertImpl.iterable.contains.valuesInOrderOnlyGrouped(\n        this,\n        groupsToList(firstGroup, secondGroup, otherExpectedGroups)\n    )\n)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the expected [firstGroup] as well as\n * the [secondGroup] and optionally [otherExpectedGroups] of identification lambdas, identifying an entry,\n * need to be contained in [Iterable] as only elements and in the specified order whereas\n * the identification lambdas within the groups can occur in any order.\n *\n * An identification lambda can also be defined as `null` in which case it matches an entry which is `null` as well.\n * Have a look at [entries] for more information about identification lambdas.\n *\n * This function will be renamed on a JVM level to `inAnyOrderEntries` with v1.0.0\n *\n * @param firstGroup A group of identification lambdas which have to appear at first within the [Iterable].\n * @param secondGroup A group of identification lambdas which have to appear after the values of the [firstGroup] within the [Iterable].\n * @param otherExpectedGroups Additional groups of values which are expected to appear after the [secondGroup] within\n *   [Iterable] whereas the groups have to appear in the given order.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.inAnyOrder(\" +\n            \"asExpectGroup(order.firstGroup),\" +\n            \"asExpectGroup(order.secondGroup), \" +\n            \"*order.otherExpectedGroups.map { asExpectGroup(it) }.toTypedArray())\"+\n            \")\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.inAnyOrder\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpectGroup\"\n    )\n)\n@JvmName(\"inAnyOrderNullableEntries\")\nfun <E : Any, T : Iterable<E?>> IterableContains.Builder<E?, T, InOrderOnlyGroupedWithinSearchBehaviour>.inAnyOrder(\n    firstGroup: Group<(Assert<E>.() -> Unit)?>,\n    secondGroup: Group<(Assert<E>.() -> Unit)?>,\n    vararg otherExpectedGroups: Group<(Assert<E>.() -> Unit)?>\n): AssertionPlant<T> = addAssertion(\n    AssertImpl.iterable.contains.entriesInOrderOnlyGroupedWithAssert(\n        this,\n        groupsToList(firstGroup, secondGroup, otherExpectedGroups)\n    )\n)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.*\nimport kotlin.jvm.JvmName\n\n/**\n * Defines that the search behaviour \"find entries `in any order` in the [Iterable]\" shall be applied to this\n * sophisticated `contains` in [Iterable] assertion.\n *\n * @return The newly created builder.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.inAnyOrder\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.inAnyOrder\"\n    )\n)\nval <E, T : Iterable<E>> IterableContains.Builder<E, T, NoOpSearchBehaviour>.inAnyOrder\n    get() = AssertImpl.iterable.contains.searchBehaviours.inAnyOrder(this)\n\n/**\n * Defines that the constraint \"`only` the specified entries exist in the [Iterable]\" shall be applied to this\n * sophisticated `contains` [Iterable] assertion.\n *\n * @return The newly created builder.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.inAnyOrder\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.only\"\n    )\n)\nval <E, T : Iterable<E>> IterableContains.Builder<E, T, InAnyOrderSearchBehaviour>.only\n    @JvmName(\"butOnly\")\n    get() = AssertImpl.iterable.contains.searchBehaviours.inAnyOrderOnly(this)\n\n\n/**\n * Defines that the search behaviour \"find entries `in order` in the [Iterable]\" shall be applied to this\n * sophisticated `contains` in [Iterable] assertion.\n *\n * @return The newly created builder.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.inAnyOrder\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.inOrder\"\n    )\n)\nval <E, T : Iterable<E>> IterableContains.Builder<E, T, NoOpSearchBehaviour>.inOrder\n    get() = AssertImpl.iterable.contains.searchBehaviours.inOrder(this)\n\n/**\n * Defines that the constraint \"`only` the specified entries exist in the [Iterable]\" shall be applied to this\n * sophisticated `contains in order` [Iterable] assertion.\n *\n * @return The newly created builder.\n */\n//TODO deprecate as soon as https://youtrack.jetbrains.com/issue/KT-33398 is fixed\n//@Deprecated(\n//    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n//    ReplaceWith(\n//        \"this.inAnyOrder\",\n//        \"ch.tutteli.atrium.api.fluent.en_GB.only\"\n//    )\n//)\nval <E, T : Iterable<E>> IterableContains.Builder<E, T, InOrderSearchBehaviour>.only\n    @JvmName(\"andOnly\")\n    get() = AssertImpl.iterable.contains.searchBehaviours.inOrderOnly(this)\n\n/**\n * Defines that the [Iterable] contains `in order only` groups of entries\n * whereas the order within the group is specified as next step.\n *\n * @return The newly created builder.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.inAnyOrder\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.grouped\"\n    )\n)\nval <E, T : Iterable<E>> IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>.grouped\n    get() = AssertImpl.iterable.contains.searchBehaviours.inOrderOnlyGrouped(this)\n\n/**\n * A filler word to emphasis that the next step defines the order within expected groups of values.\n *\n * @return The newly created builder.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.inAnyOrder\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.within\"\n    )\n)\nval <E, T : Iterable<E>> IterableContains.Builder<E, T, InOrderOnlyGroupedSearchBehaviour>.within\n    get() = AssertImpl.iterable.contains.searchBehaviours.inOrderOnlyGroupedWithin(this)\n","// TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"TYPEALIAS_EXPANSION_DEPRECATION\")\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\n\n/**\n * Makes the assertion that the given [index] is within the bounds of [Assert.subject][SubjectProvider.subject],\n * creates a feature assertion plant for the corresponding element and returns the newly created plant.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the given [index] is out of bound.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().get(index).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.get\"\n    )\n)\nfun <E: Any, T: List<E>> Assert<T>.get(index: Int): Assert<E>\n    = AssertImpl.list.get(this, index)\n\n/**\n * Makes the assertion that the given [index] is within the bounds of [Assert.subject][SubjectProvider.subject] and that\n * the corresponding element holds all assertions the given [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.apply { asExpect().get(index).asAssert(assertionCreator) }\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.get\"\n    )\n)\nfun <E: Any, T: List<E>> Assert<T>.get(index: Int, assertionCreator: Assert<E>.() -> Unit)\n    = addAssertion(AssertImpl.list.get(this, index, assertionCreator))\n\n/**\n * Makes the assertion that the given [index] is within the bounds of [Assert.subject][SubjectProvider.subject],\n * creates a feature assertion plant for the corresponding nullable element and returns the newly created plant.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the given [index] is out of bound.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().get(index).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.get\"\n    )\n)\nfun <E, T: List<E>> Assert<T>.get(index: Int): AssertionPlantNullable<E>\n    = AssertImpl.list.getNullable(this, index)\n","//TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.creating.ListAssertions\nimport ch.tutteli.atrium.domain.creating.listAssertions\n\n/**\n * Delegates inter alia to the implementation of [ListAssertions].\n * In detail, it implements [ListAssertions] by delegating to [listAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\nobject ListAssertionsBuilder : ListAssertions {\n\n    override inline fun <E, T : List<E>> get(\n        expect: Expect<T>,\n        index: Int\n    ) = listAssertions.get(expect, index)\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override fun <T : Any> get(plant: AssertionPlant<List<T>>, index: Int): AssertionPlant<T> =\n        listAssertions.get(plant, index)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <T : Any> get(\n        plant: AssertionPlant<List<T>>,\n        index: Int,\n        noinline assertionCreator: AssertionPlant<T>.() -> Unit\n    ) = listAssertions.get(plant, index, assertionCreator)\n\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override fun <T> getNullable(plant: AssertionPlant<List<T>>, index: Int): AssertionPlantNullable<T> =\n        listAssertions.getNullable(plant, index)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <T> getNullable(\n        plant: AssertionPlant<List<T>>,\n        index: Int,\n        noinline assertionCreator: AssertionPlantNullable<T>.() -> Unit\n    ) = listAssertions.getNullable(plant, index, assertionCreator)\n}\n","// TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"TYPEALIAS_EXPANSION_DEPRECATION\")\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.ExpectImpl\nimport ch.tutteli.kbox.glue\nimport kotlin.js.JsName\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains a key as defined by [keyValuePair]'s [Pair.first]\n * with a corresponding value as defined by [keyValuePair]'s [Pair.second] -- optionally the same assertions\n * are created for the [otherPairs].\n *\n * Notice, that it does not search for unique matches. Meaning, if the map is `mapOf('a' to 1)` and [keyValuePair] is\n * defined as `'a' to 1` and one of the [otherPairs] is defined as `'a' to 1` as well, then both match,\n * even though they match the same entry.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().contains(keyValuePair, *otherPairs).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.contains\"\n    )\n)\nfun <K, V, T: Map<out K, V>> Assert<T>.contains(keyValuePair: Pair<K, V>, vararg otherPairs: Pair<K, V>)\n    = addAssertion(AssertImpl.map.contains(this, keyValuePair glue otherPairs))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains a key as defined by [keyValue]'s [KeyValue.key]\n * with a corresponding value which either holds all assertions [keyValue]'s\n * [KeyValue.valueAssertionCreatorOrNull] might create or needs to be `null` in case\n * [KeyValue.valueAssertionCreatorOrNull] is defined as `null`\n * -- optionally the same assertions are created for the [otherKeyValues].\n *\n * Notice, that it does not search for unique matches. Meaning, if the map is `mapOf('a' to 1)` and [keyValue] is\n * defined as `Key('a') { isGreaterThan(0) }` and one of the [otherKeyValues] is defined as `Key('a') { isLessThan(2) }`\n * , then both match, even though they match the same entry.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().contains(keyValue, *otherKeyValues).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.contains\"\n    )\n)\nfun <K, V : Any, T: Map<out K, V?>> Assert<T>.contains(\n    keyValue: KeyValue<K, V>,\n    vararg otherKeyValues: KeyValue<K, V>\n) = addAssertion(AssertImpl.map.containsKeyWithValueAssertions(this, (keyValue glue otherKeyValues).map { it.toPair() }))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains the given [key].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().containsKey(key).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.containsKey\"\n    )\n)\nfun <K> Assert<Map<out K, *>>.containsKey(key: K)\n    = addAssertion(AssertImpl.map.containsKey(this, key))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not contain the given [key].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().containsNotKey(key).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.containsNotKey\"\n    )\n)\nfun <K> Assert<Map<out K, *>>.containsNotKey(key: K)\n    = addAssertion(AssertImpl.map.containsNotKey(this, key))\n\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains the given [key], creates a feature\n * assertion plant for the corresponding value and returns the newly created plant.\n *\n * @return The newly created plant for the feature\n * @throws AssertionError Might throw an [AssertionError] if the given [key] does not exist.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().getExisting(key).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.getExisting\"\n    )\n)\n@JsName(\"getExisting\")\nfun <K, V: Any, T: Map<out K, V>> Assert<T>.getExisting(key: K): Assert<V>\n    = AssertImpl.map.getExisting(this, key)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains the given [key] and that\n * the corresponding value holds all assertions the given [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().apply { getExisting(key).asAssert(assertionCreator) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.getExisting\"\n    )\n)\nfun <K, V: Any, T: Map<out K, V>> Assert<T>.getExisting(key: K, assertionCreator: Assert<V>.() -> Unit)\n    = addAssertion(AssertImpl.map.getExisting(this, key, assertionCreator))\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains the given [key], creates a feature\n * assertion plant for the corresponding nullable value and returns the newly created plant.\n *\n * @return The newly created plant for the feature\n * @throws AssertionError Might throw an [AssertionError] if the given [key] does not exist.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().getExisting(key).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.getExisting\"\n    )\n)\nfun <K, V: Any, T: Map<out K, V?>> Assert<T>.getExisting(key: K): AssertionPlantNullable<V?>\n    = AssertImpl.map.getExistingNullable(this, key)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s [Map.size] is [size].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().apply { feature(Map<*, *>::size).toBe(size) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Map<*, *>> Assert<T>.hasSize(size: Int)\n    = addAssertion(AssertImpl.map.hasSize(this, size))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is an empty [Map].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().isEmpty().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isEmpty\"\n    )\n)\nfun <T : Map<*, *>> Assert<T>.isEmpty()\n    = addAssertion(AssertImpl.map.isEmpty(this))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is not an empty [Map].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().isNotEmpty().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isNotEmpty\"\n    )\n)\nfun <T : Map<*, *>> Assert<T>.isNotEmpty()\n    = addAssertion(AssertImpl.map.isNotEmpty(this))\n\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [keys][Map.keys] so that further\n * fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().keys\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.keys\"\n    )\n)\nval <K> Assert<Map<K, *>>.keys get() : Assert<Set<K>> = property(Map<K, *>::keys)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [keys][Map.keys] holds all assertions the given\n * [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().apply { keys.asAssert(assertionCreator) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.keys\"\n    )\n)\nfun <K, V, T: Map<K, V>> Assert<T>.keys(assertionCreator: Assert<Set<K>>.() -> Unit)\n    = addAssertion(AssertImpl.map.keys(this, assertionCreator))\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [values][Map.values] so that further\n * fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().values\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.values\"\n    )\n)\nval <V> Assert<Map<*, V>>.values get() : Assert<Collection<V>> = property(Map<*, V>::values)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [values][Map.values] holds all assertions the given\n * [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().apply { values.asAssert(assertionCreator) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.values\"\n    )\n)\nfun <K, V, T: Map<K, V>> Assert<T>.values(assertionCreator: Assert<Collection<V>>.() -> Unit)\n    = addAssertion(AssertImpl.map.values(this, assertionCreator))\n\n/**\n * Turns `Assert<Map<K, V>>` into `Assert<Set<Map.Entry<K, V>>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `property(subject::entries)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().asEntries().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asEntries\"\n    )\n)\nfun <K, V> Assert<Map<out K, V>>.asEntries(): Assert<Set<Map.Entry<K, V>>>\n    = ExpectImpl.changeSubject(this).unreported { it.entries }\n\n/**\n * Turns `Assert<Map<K, V>>` into `Assert<Set<Map.Entry<K, V>>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `property(subject::entries)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().apply { asEntries().asAssert(assertionCreator) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asEntries\"\n    )\n)\nfun <K, V> Assert<Map<out K, V>>.asEntries(assertionCreator: Assert<Set<Map.Entry<K, V>>>.() -> Unit): Assert<Set<Map.Entry<K, V>>>\n    = asEntries().addAssertionsCreatedBy(assertionCreator)\n","@file:Suppress(\n    \"DEPRECATION\", \"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\",\n/* TODO remove annotation with 1.0.0 */ \"TYPEALIAS_EXPANSION_DEPRECATION\"\n)\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.*\nimport ch.tutteli.atrium.domain.creating.MapAssertions\nimport ch.tutteli.atrium.domain.creating.MapEntryAssertions\nimport ch.tutteli.atrium.domain.creating.changers.ExtractedFeaturePostStep\nimport ch.tutteli.atrium.domain.creating.mapAssertions\nimport kotlin.reflect.KClass\n\n/**\n * Delegates inter alia to the implementation of [MapAssertions].\n * In detail, it implements [MapAssertions] by delegating to [mapAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\nobject MapAssertionsBuilder : MapAssertions {\n\n    /**\n     * Returns [MapEntryAssertionsBuilder]\n     * which inter alia delegates to the implementation of [MapEntryAssertions].\n     */\n    inline val entry get() : MapEntryAssertionsBuilder = MapEntryAssertionsBuilder\n\n    override inline fun <K, V, T : Map<out K, V>> contains(\n        expect: Expect<T>,\n        keyValuePairs: List<Pair<K, V>>\n    ) = mapAssertions.contains(expect, keyValuePairs)\n\n    override inline fun <K, V : Any, T : Map<out K, V?>> containsKeyWithValueAssertions(\n        expect: Expect<T>,\n        valueType: KClass<V>,\n        keyValues: List<Pair<K, (Expect<V>.() -> Unit)?>>\n    ) = mapAssertions.containsKeyWithValueAssertions(expect, valueType, keyValues)\n\n\n    override inline fun <K> containsKey(subjectProvider: SubjectProvider<Map<out K, *>>, key: K) =\n        mapAssertions.containsKey(subjectProvider, key)\n\n    override inline fun <K> containsNotKey(subjectProvider: SubjectProvider<Map<out K, *>>, key: K) =\n        mapAssertions.containsNotKey(subjectProvider, key)\n\n\n    override inline fun isEmpty(subjectProvider: SubjectProvider<Map<*, *>>) =\n        mapAssertions.isEmpty(subjectProvider)\n\n    override inline fun <K, V, T : Map<out K, V>> getExisting(\n        expect: Expect<T>,\n        key: K\n    ): ExtractedFeaturePostStep<T, V> = mapAssertions.getExisting(expect, key)\n\n    override inline fun isNotEmpty(subjectProvider: SubjectProvider<Map<*, *>>) =\n        mapAssertions.isNotEmpty(subjectProvider)\n\n    override inline fun <T : Map<*, *>> size(expect: Expect<T>) = mapAssertions.size(expect)\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V> contains(\n        plant: AssertionPlant<Map<out K, V>>,\n        keyValuePairs: List<Pair<K, V>>\n    ) = mapAssertions.contains(plant, keyValuePairs)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V : Any> containsKeyWithValueAssertions(\n        plant: AssertionPlant<Map<out K, V?>>,\n        keyValues: List<Pair<K, (Assert<V>.() -> Unit)?>>\n    ) = mapAssertions.containsKeyWithValueAssertions(plant, keyValues)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V : Any> getExisting(plant: AssertionPlant<Map<out K, V>>, key: K) =\n        mapAssertions.getExisting(plant, key)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V : Any> getExisting(\n        plant: AssertionPlant<Map<out K, V>>,\n        key: K,\n        noinline assertionCreator: AssertionPlant<V>.() -> Unit\n    ) = mapAssertions.getExisting(plant, key, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V> getExistingNullable(plant: AssertionPlant<Map<out K, V>>, key: K) =\n        mapAssertions.getExistingNullable(plant, key)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V> getExistingNullable(\n        plant: AssertionPlant<Map<out K, V>>,\n        key: K,\n        noinline assertionCreator: AssertionPlantNullable<V>.() -> Unit\n    ) = mapAssertions.getExistingNullable(plant, key, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun hasSize(plant: AssertionPlant<Map<*, *>>, size: Int) = mapAssertions.hasSize(plant, size)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K> keys(\n        plant: AssertionPlant<Map<out K, *>>,\n        noinline assertionCreator: AssertionPlant<Set<K>>.() -> Unit\n    ): Assertion = mapAssertions.keys(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V> values(\n        plant: AssertionPlant<Map<*, V>>,\n        noinline assertionCreator: AssertionPlant<Collection<V>>.() -> Unit\n    ): Assertion = mapAssertions.values(plant, assertionCreator)\n}\n","// TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"TYPEALIAS_EXPANSION_DEPRECATION\")\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s [Map.Entry.key] is (equal to) the given [key] and\n * [Map.Entry.value] is [value].\n *\n * Kind of a shortcut for `key { toBe(key) }.and.value { toBe(value) }` but should be evaluated in\n * an assertion group block -- which has the effect that the assertion about the value is still evaluated even\n * if the assertion about the key fails. Moreover, it might be that reporting differs compared to using the long form.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().isKeyValue(key, value).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isKeyValue\"\n    )\n)\nfun <K : Any, V : Any> Assert<Map.Entry<K, V>>.isKeyValue(key: K, value: V): Assert<Map.Entry<K, V>>\n    = addAssertion(AssertImpl.map.entry.isKeyValue(this, key, value))\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [key][Map.Entry.key] so that further\n * fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().key\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.key\"\n    )\n)\nval <K : Any> Assert<Map.Entry<K, *>>.key get() : Assert<K> = property(Map.Entry<K, *>::key)\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [key][Map.Entry.key] (which could be `null`)\n * so that further fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n//TODO deprecate as soon as https://youtrack.jetbrains.com/issue/KT-33398 is fixed\n//@Deprecated(\n//    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n//    ReplaceWith(\n//        \"this.asExpect().key\",\n//        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n//        \"ch.tutteli.atrium.api.fluent.en_GB.key\"\n//    )\n//)\nval <K> Assert<Map.Entry<K, *>>.key get() : AssertionPlantNullable<K> = property(Map.Entry<K, *>::key)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [key][Map.Entry.key] holds all assertions the given\n * [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().apply { key.asAssert(assertionCreator) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.key\"\n    )\n)\nfun <K : Any, V> Assert<Map.Entry<K, V>>.key(assertionCreator: Assert<K>.() -> Unit)\n    = addAssertion(AssertImpl.map.entry.key(this, assertionCreator))\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [value][Map.Entry.value] so that further\n * fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().value\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.value\"\n    )\n)\nval <V : Any> Assert<Map.Entry<*, V>>.value get() : Assert<V> = property(Map.Entry<*, V>::value)\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [value][Map.Entry.value]\n * (which could be `null`) so that further fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n//TODO deprecate as soon as https://youtrack.jetbrains.com/issue/KT-33398 is fixed\n//@Deprecated(\n//    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n//    ReplaceWith(\n//        \"this.asExpect().value\",\n//        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n//        \"ch.tutteli.atrium.api.fluent.en_GB.value\"\n//    )\n//)\nval <V> Assert<Map.Entry<*, V>>.value get() : AssertionPlantNullable<V> = property(Map.Entry<*, V>::value)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [value][Map.Entry.value] holds all assertions the given\n * [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().apply { value.asAssert(assertionCreator) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.value\"\n    )\n)\nfun <K, V: Any> Assert<Map.Entry<K, V>>.value(assertionCreator: Assert<V>.() -> Unit)\n    = addAssertion(AssertImpl.map.entry.value(this, assertionCreator))\n","//TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.creating.MapEntryAssertions\nimport ch.tutteli.atrium.domain.creating.mapEntryAssertions\nimport kotlin.reflect.KClass\n\n/**\n * Delegates inter alia to the implementation of [MapEntryAssertions].\n * In detail, it implements [MapEntryAssertions] by delegating to [mapEntryAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\nobject MapEntryAssertionsBuilder : MapEntryAssertions {\n    override inline fun <K, V, T : Map.Entry<K, V>> isKeyValue(\n        expect: Expect<T>,\n        key: K,\n        value: V\n    ) = mapEntryAssertions.isKeyValue(expect, key, value)\n\n    override inline fun <K, T : Map.Entry<K, *>> key(expect: Expect<T>) =\n        mapEntryAssertions.key(expect)\n\n    override inline fun <V, T : Map.Entry<*, V>> value(expect: Expect<T>) =\n        mapEntryAssertions.value(expect)\n\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K : Any, V : Any> isKeyValue(\n        plant: AssertionPlant<Map.Entry<K, V>>,\n        key: K,\n        value: V\n    ): Assertion = mapEntryAssertions.isKeyValue(plant, key, value)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K : Any> key(\n        plant: AssertionPlant<Map.Entry<K, *>>,\n        noinline assertionCreator: AssertionPlant<K>.() -> Unit\n    ): Assertion = mapEntryAssertions.key(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V : Any> value(\n        plant: AssertionPlant<Map.Entry<*, V>>,\n        noinline assertionCreator: AssertionPlant<V>.() -> Unit\n    ): Assertion = mapEntryAssertions.value(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K> nullableKey(\n        plant: AssertionPlant<Map.Entry<K, *>>,\n        noinline assertionCreator: AssertionPlantNullable<K>.() -> Unit\n    ): Assertion = mapEntryAssertions.nullableKey(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V> nullableValue(\n        plant: AssertionPlant<Map.Entry<*, V>>,\n        noinline assertionCreator: AssertionPlantNullable<V>.() -> Unit\n    ): Assertion = mapEntryAssertions.nullableValue(plant, assertionCreator)\n}\n","// TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"TYPEALIAS_EXPANSION_DEPRECATION\")\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [first][Pair.first] so that further\n * fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().first\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.first\"\n    )\n)\nval <K : Any> Assert<Pair<K, *>>.first get() : Assert<K> = property(Pair<K, *>::first)\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [first][Pair.first] (which could be `null`)\n * so that further fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n//TODO deprecate as soon as https://youtrack.jetbrains.com/issue/KT-33398 is fixed\n//@Deprecated(\n//    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n//    ReplaceWith(\n//        \"this.asExpect().first\",\n//        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n//        \"ch.tutteli.atrium.api.fluent.en_GB.first\"\n//    )\n//)\nval <K> Assert<Pair<K, *>>.first get() : AssertionPlantNullable<K> = property(Pair<K, *>::first)\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [first][Pair.first] holds all assertions the given\n * [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().apply { first.asAssert(assertionCreator) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.first\"\n    )\n)\nfun <K : Any, V> Assert<Pair<K, V>>.first(assertionCreator: Assert<K>.() -> Unit)\n    = addAssertion(AssertImpl.pair.first(this, assertionCreator))\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [second][Pair.second] so that further\n * fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().second\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.second\"\n    )\n)\nval <V : Any> Assert<Pair<*, V>>.second get() : Assert<V> = property(Pair<*, V>::second)\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [second][Pair.second]\n * (which could be `null`) so that further fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n//TODO deprecate as soon as https://youtrack.jetbrains.com/issue/KT-33398 is fixed\n//@Deprecated(\n//    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n//    ReplaceWith(\n//        \"this.asExpect().second\",\n//        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n//        \"ch.tutteli.atrium.api.fluent.en_GB.second\"\n//    )\n//)\nval <V> Assert<Pair<*, V>>.second get() : AssertionPlantNullable<V> = property(Pair<*, V>::second)\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [second][Pair.second] holds all assertions the given\n * [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().apply { second.asAssert(assertionCreator) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.second\"\n    )\n)\nfun <K, V: Any> Assert<Pair<K, V>>.second(assertionCreator: Assert<V>.() -> Unit)\n    = addAssertion(AssertImpl.pair.second(this, assertionCreator))\n","//TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.creating.PairAssertions\nimport ch.tutteli.atrium.domain.creating.pairAssertions\n\n/**\n * Delegates inter alia to the implementation of [PairAssertions].\n * In detail, it implements [PairAssertions] by delegating to [pairAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Deprecated(\"Use _logic from ch.tutteli.atrium.logic instead; will be removed with 1.0.0\")\nobject PairAssertionsBuilder : PairAssertions {\n\n    override inline fun <K, T : Pair<K, *>> first(expect: Expect<T>) =\n        pairAssertions.first(expect)\n\n    override inline fun <V, T : Pair<*, V>> second(expect: Expect<T>) =\n        pairAssertions.second(expect)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K : Any> first(\n        plant: AssertionPlant<Pair<K, *>>,\n        noinline assertionCreator: AssertionPlant<K>.() -> Unit\n    ): Assertion = pairAssertions.first(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V : Any> second(\n        plant: AssertionPlant<Pair<*, V>>,\n        noinline assertionCreator: AssertionPlant<V>.() -> Unit\n    ): Assertion = pairAssertions.second(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K> nullableFirst(\n        plant: AssertionPlant<Pair<K, *>>,\n        noinline assertionCreator: AssertionPlantNullable<K>.() -> Unit\n    ): Assertion = pairAssertions.nullableFirst(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V> nullableSecond(\n        plant: AssertionPlant<Pair<*, V>>,\n        noinline assertionCreator: AssertionPlantNullable<V>.() -> Unit\n    ): Assertion = pairAssertions.nullableSecond(plant, assertionCreator)\n}\n","// TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"TYPEALIAS_EXPANSION_DEPRECATION\")\n\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.utils.Group\nimport ch.tutteli.atrium.domain.builders.utils.GroupWithNullableEntries\nimport ch.tutteli.atrium.domain.builders.utils.GroupWithoutNullableEntries\nimport ch.tutteli.atrium.domain.builders.utils.VarArgHelper\nimport ch.tutteli.kbox.glue\n\n/**\n * Parameter object to express a [Group] with a single identification lambda.\n *\nIn case `null` is used for the identification lambda then it is expected that the corresponding entry\n * is `null` as well.\n *\n * @param assertionCreatorOrNull The identification lambda identifying the entry where an entry is considered\n *   to be identified if it holds all [Assertion]s the lambda might create.\n *   In case it is defined as `null`, then an entry is identified if it is `null` as well.\n */\n@Deprecated(\"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\")\nclass Entry<in T: Any>(\n    val assertionCreatorOrNull: (Assert<T>.() -> Unit)?\n): GroupWithoutNullableEntries<(Assert<T>.() -> Unit)?>, GroupWithNullableEntries<(Assert<T>.() -> Unit)?> {\n    override fun toList(): List<(Assert<T>.() -> Unit)?> = listOf(assertionCreatorOrNull)\n}\n\n/**\n * Parameter object to express a [Group] of identification lambdas.\n *\n * In case `null` is used for an identification lambda then it is expected that the corresponding entry\n * is `null` as well.\n *\n * @param assertionCreatorOrNull The identification lambda identifying the entry where an entry is considered\n *   to be identified if it holds all [Assertion]s the lambda might create.\n *   In case it is defined as `null`, then an entry is identified if it is `null` as well.\n * @param otherAssertionCreatorsOrNulls A variable amount of additional identification lambdas or `null`s.\n */\n@Deprecated(\"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\")\nclass Entries<in T : Any>(\n    val assertionCreatorOrNull: (Assert<T>.() -> Unit)?,\n    vararg val otherAssertionCreatorsOrNulls: (Assert<T>.() -> Unit)?\n) : GroupWithoutNullableEntries<(Assert<T>.() -> Unit)?>, GroupWithNullableEntries<(Assert<T>.() -> Unit)?>, VarArgHelper<(Assert<T>.() -> Unit)?> {\n    override val expected get() = assertionCreatorOrNull\n    override val otherExpected get() = otherAssertionCreatorsOrNulls\n\n    override fun toList(): List<(Assert<T>.() -> Unit)?> = assertionCreatorOrNull glue otherAssertionCreatorsOrNulls\n}\n\n\n/**\n * Parameter object to express a key/value [Pair] whose value type is a nullable lambda with an\n * [Assert][AssertionPlant] receiver, which means one can either pass a lambda or `null`.\n */\n@Deprecated(\"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\")\ndata class KeyValue<out K, V : Any>(val key: K, val valueAssertionCreatorOrNull: (Assert<V>.() -> Unit)?) {\n    fun toPair(): Pair<K, (Assert<V>.() -> Unit)?> = key to valueAssertionCreatorOrNull\n    override fun toString(): String\n        = \"KeyValue(key=$key, value=${if (valueAssertionCreatorOrNull == null) \"null\" else \"lambda\"})\"\n}\n\n/**\n * Represents a [Group] with a single value.\n */\n@Deprecated(\"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\")\ndata class Value<out T>(val expected: T) : GroupWithNullableEntries<T>, GroupWithoutNullableEntries<T> {\n    override fun toList() = listOf(expected)\n}\n\n/**\n * Represents a [Group] of multiple values.\n */\n@Deprecated(\"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\")\nclass Values<out T>(\n    override val expected: T,\n    override vararg val otherExpected: T\n) : GroupWithoutNullableEntries<T>, GroupWithNullableEntries<T>, VarArgHelper<T>  {\n    override fun toList() = listOf(expected, *otherExpected)\n}\n","// TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"TYPEALIAS_EXPANSION_DEPRECATION\")\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.ExpectImpl\n\n/**\n * Turns `Assert<Sequence<E>>` into `Assert<Iterable<E>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(Sequence::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().asIterable()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asIterable\"\n    )\n)\nfun <E> Assert<Sequence<E>>.asIterable(): Assert<Iterable<E>>\n    = ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n","// TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"TYPEALIAS_EXPANSION_DEPRECATION\")\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.ThrowableThrown\n\n/**\n *  Makes the assertion that the thrown [Throwable] is of type [TExpected] and holds all assertions the\n * [assertionCreator] might create in addition.\n *\n * @return Notice, that this assertion function cannot provide a fluent API because it depends on whether the first\n *   assertion (a [Throwable] was thrown) holds or not.\n * Define subsequent assertions via the [assertionCreator] lambda.\n *\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.toThrow<TExpected>().asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.toThrow\"\n    )\n)\ninline fun <reified TExpected : Throwable> ThrowableThrown.Builder.toThrow(noinline assertionCreator: Assert<TExpected>.() -> Unit) {\n        AssertImpl.throwable.thrown.toBe(this, TExpected::class, assertionCreator)\n}\n\n/**\n * Makes the assertion that no [Throwable] is thrown at all.\n *\n * @return Notice, that this assertion function cannot provide a fluent API because we assume nothing happens,\n *   so there is nothing we could make assertions on in addition.\n *\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.notToThrow()\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.notToThrow\"\n    )\n)\nfun ThrowableThrown.Builder.notToThrow(){\n        AssertImpl.throwable.thrown.nothingThrown(this)\n}\n\n/**\n * Creates an [AssertionPlantNullable] for the [message][Throwable.message] of the plant's\n * [subject][SubjectProvider.subject] (which is a [Throwable]) and makes the assertion that message [notToBeNull]\n * and uses [assertionCreator] which might create further [Assertion]s which are lazily evaluated at the end.\n *\n * @return Notice, that this assertion function cannot provide a fluent API because it depends on whether the first\n *   assertion [message][Throwable.message] is not null) holds or not.\n * Define subsequent assertions via the [assertionCreator] lambda.\n *\n * @throws AssertionError Might throw an [AssertionError] in case [message][Throwable.message] is `null`\n *   or if an additionally created [Assertion]s (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().message.asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.message\"\n    )\n)\nfun <T : Throwable> Assert<T>.message(assertionCreator: Assert<String>.() -> Unit) {\n    property(Throwable::message).notToBeNull(assertionCreator)\n}\n\n/**\n * Creates the assertion that the [Throwable]'s [message][Throwable.message] is not null (see [message]) contains\n * [expected]'s [toString] representation and the [toString] representation of the [otherExpected] (if given),\n * using a non disjoint search.\n *\n * It is a shortcut for `message { contains.atLeast(1).values(expected, otherExpected) }`\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed\n * (this function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * @return Notice, that this assertion function cannot provide a fluent API because it depends on whether the first\n *   assertion [message][Throwable.message] is not null) holds or not.\n *\n * @throws AssertionError Might throw an [AssertionError] in case [message][Throwable.message] is `null`\n *   or does not contain [expected] or [otherExpected].\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().messageContains(expected, *otherExpected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.messageContains\"\n    )\n)\nfun <T : Throwable> Assert<T>.messageContains(expected: Any, vararg otherExpected: Any) {\n    message { contains(expected, *otherExpected) }\n}\n","// TODO remove file with 1.0.0\n@file:Suppress(\"DEPRECATION\", \"TYPEALIAS_EXPANSION_DEPRECATION\")\n@file:JvmMultifileClass\n@file:JvmName(\"TypeTransformationAssertionsKt\")\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Makes the assertion that [AssertionPlantNullable.subject][SubjectProvider.subject] is not null and if so, uses [assertionCreator]\n * which could create further assertions which are added as a group.\n *\n * @return Notice, that this assertion function cannot provide a fluent API because it depends on whether the first\n *   assertion ([Assert.subject][SubjectProvider.subject] is not null) holds or not. Define subsequent assertions\n *   via the [assertionCreator] lambda.\n *\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().notToBeNull().asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.notToBeNull\"\n    )\n)\ninline fun <reified T : Any> AssertionPlantNullable<T?>.notToBeNull(noinline assertionCreator: Assert<T>.() -> Unit) {\n    addAssertion(AssertImpl.any.isNotNull(this, T::class, assertionCreator))\n}\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] *is a* [TSub] (the same type or a sub-type) and if so,\n * uses [assertionCreator] which could create further assertions which are added as a group.\n *\n * Notice, that asserting a function type is [flawed](https://youtrack.jetbrains.com/issue/KT-27846).\n * The actual types are ignored as function types erase to Function0,\n * Function1 etc. on byte code level, which means the assertion holds as long as the [Assert.subject][SubjectProvider.subject] is a\n * function and has the same amount of arguments regardless if the types differ. For instance\n * `assert({x: Int -> \"hello\"}).isA<String -> Unit>{}` holds, even though `(Int) -> String` is clearly not\n * a `(String) -> Unit`.\n *\n * More generally speaking, the [flaw](https://youtrack.jetbrains.com/issue/KT-27826) applies to all generic types.\n * For instance `isA<List<String>>` would only check if the [Assert.subject][SubjectProvider.subject] is a `List` without checking if\n * the element type is actually `String`. Or in other words\n * `assert(listOf(1, 2)).isA<List<String>>{}` holds, even though `List<Int>` is clearly not a `List<String>`.\n *\n * @return Notice, that this assertion function cannot provide a fluent API because it depends on whether the first\n *   assertion ([Assert.subject][SubjectProvider.subject] *is a* [TSub]) holds or not. Define subsequent assertions\n *   via the [assertionCreator] lambda.\n *\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0 -- see https://github.com/robstoll/atrium/releases/tag/v0.9.0#migration for migration hints and scripts.\",\n    ReplaceWith(\n        \"this.asExpect().isA<TSub>().asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isA\"\n    )\n)\ninline fun <reified TSub : Any> Assert<Any>.isA(noinline assertionCreator: AssertionPlant<TSub>.() -> Unit) {\n        AssertImpl.any.typeTransformation.isA(this, TSub::class, assertionCreator)\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;iBAqC4B,4E;mBCXxB,gH;;;;;;;;;;8BCuBA,2G;;qBChCJ,oD;iBC4DI,+I;gCCiwCJ,yD;uBAAA,gD;mBCp0CA,qC;yBFwHI,uJ;;;;;;;;;;;;;;;;;;;;;;4BGnGA,mI;mBC2CA,2I;;;2BAuFA,mJ;;;;;;;;;;mBCxFA,0I;;;;;;;;;;;;;;;;;;;;;;;;;ECxDJ,mC;IVoBoC,6B;IUFQ,sCTRpC,wBAAc,cSQuD,STRvD,ESQ6D,QTR7D,CSQsB,C;G;EAE5C,sC;IVAoC,6B;IUkBW,sCTzBvC,wBAAc,iBSyB6D,STzB7D,ESyBmE,QTzBnE,CSyByB,C;G;EAE/C,uC;IVpBoC,6B;IUsCY,sCT1CxC,wBAAc,gBS0C6D,ST1C7D,ES0CmE,QT1CnE,CS0C0B,C;G;EAEhD,0C;IVxCoC,6B;IU0De,sCT3D3C,wBAAc,mBS2DmE,ST3DnE,ES2DyE,QT3DzE,CS2D6B,C;G;0GAEnD,yB;IAAA,gC;IV5D4B,6G;ICgBxB,mJ;IS4CJ,gD;MV5DoC,6B;MU6EJ,yB;MAA5B,+BT1DI,wBAAc,oBS0DqB,ST1DrB,EAAkB,IAAlB,ES0DqC,QT1DrC,CS0DlB,C;IACJ,C;GAlBA,C;8IAoBA,yB;IAAA,gC;IVhF4B,6G;ICmCxB,mJ;IS6CJ,8D;MVhFoC,6B;MUyGJ,yB;MAA5B,+BThEI,wBAAc,+BSgEgC,SThEhC,EAA6B,IAA7B,ESgEgD,sBThEhD,CSgElB,C;IACJ,C;GA1BA,C;EAsCuD,4B;IAAQ,gB;G;EAE/D,0C;IAWI,gDAAuB,gBAAvB,C;G;EC7I0C,+B;IAAE,OAAG,WAAH,EAAG,C;EAAa,C;EAlBhE,iC;IAkBI,OTyBI,+BAAsB,gBSzBD,STyBC,CSzBK,oBAAW,iBAAX,C;G;EAEnC,oD;IAmBI,OAAA,uBAAa,gCAAuB,gBAAvB,C;G;EAsB6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAnBhE,kC;IAmBI,OTlBI,+BAAsB,gBSkBD,STlBC,CSkBK,oBAAW,mBAAX,C;G;EAEnC,oD;IAoBI,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAsB6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAnBhE,kC;IAmBI,OT9DI,+BAAsB,gBS8DD,ST9DC,CS8DK,oBAAW,mBAAX,C;G;EAEnC,oD;IAoBI,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAsB6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAnBhE,kC;IAmBI,OT1GI,+BAAsB,gBS0GD,ST1GC,CS0GK,oBAAW,mBAAX,C;G;EAEnC,oD;IAoBI,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAqBoF,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAlBvH,kC;IAkB2D,OTrJnD,+BAAsB,gBSqJsD,STrJtD,CSqJ4D,oBAAW,mBAAX,C;G;EAE1F,oD;IAoBI,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAsB6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAnBhE,kC;IAmBI,OTjMI,+BAAsB,gBSiMD,STjMC,CSiMK,oBAAW,mBAAX,C;G;EAEnC,oD;IAoBI,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAsB6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAnBhE,kC;IAmBI,OT7OI,+BAAsB,gBS6OD,ST7OC,CS6OK,oBAAW,mBAAX,C;G;EAEnC,oD;IAoBI,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAsB6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAnBhE,kC;IAmBI,OTzRI,+BAAsB,gBSyRD,STzRC,CSyRK,oBAAW,mBAAX,C;G;EAEnC,oD;IAoBI,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAsB6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAnBhE,kC;IAmBI,OTrUI,+BAAsB,gBSqUD,STrUC,CSqUK,oBAAW,mBAAX,C;G;EAEnC,oD;IAoBI,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EClXb,iC;IZUyC,sC;IYVjC,ORCJ,iCAAuB,yBQDqB,SRCrB,C;G;EQgB3B,oC;IZPyC,sC;IYOjC,gCRbJ,iCAAuB,4BQa6C,SRb7C,CQanB,C;G;EAEZ,sD;IAoCI,OAAoB,OAAX,QAAT,uBAAS,EAAQ,CAAR,CAAW,EAAO,QAAP,EAAkB,aAAlB,S;G;EAExB,yD;IAsBI,OAAY,OAAZ,0BAAY,EAAO,QAAP,EAAkB,aAAlB,S;G;EAGhB,0D;IAiCI,OAAoB,MAAX,QAAT,uBAAS,EAAQ,CAAR,CAAW,EAAM,OAAN,EAAgB,aAAhB,S;G;EAExB,yC;IZ3G6C,sC;IY2HzC,sCR9HI,iCAAuB,oBQ8HqB,SR9HrB,EQ8H2B,QR9H3B,CQ8H3B,C;G;EAEJ,4C;IZ7H6C,sC;IY6IzC,sCR7II,iCAAuB,uBQ6IwB,SR7IxB,EQ6I8B,QR7I9B,CQ6I3B,C;G;EAGJ,uC;IZhJ6C,sC;IYgKzC,sCR7JI,iCAAuB,kBQ6JmB,SR7JnB,EQ6JyB,QR7JzB,CQ6J3B,C;G;EAEJ,0C;IZlK6C,sC;IYkLzC,sCR5KI,iCAAuB,qBQ4KsB,SR5KtB,EQ4K4B,QR5K5B,CQ4K3B,C;G;EAGJ,4B;IZrL6C,sC;IYoMA,sCR3LrC,iCAAuB,iBQ2L2D,SR3L3D,CQ2Lc,C;G;EAE7C,+B;IZtM6C,sC;IYqNG,sCRzMxC,iCAAuB,oBQyMiE,SRzMjE,CQyMiB,C;G;EAEhD,+B;IZvN6C,sC;IYsOG,sCRvNxC,iCAAuB,oBQuNiE,SRvNjE,CQuNiB,C;G;ECpQhD,mC;IAmBI,oCAAyB,KAAzB,EAAgC,SAAhC,C;G;EAEJ,qC;IAuBI,sCAA2B,KAA3B,EAAkC,SAAlC,EAAwC,yBAAxC,C;G;EAEJ,mC;IAmBI,oCAAyB,KAAzB,EAAgC,SAAhC,C;G;EAEJ,kC;IAwBI,mCAAwB,KAAxB,EAA+B,SAA/B,C;G;EAEJ,uC;IAmBI,wCAA6B,KAA7B,EAAoC,SAApC,C;G;ETtBA,yDAIsC,yB;IE7F1C,sD;WF6F0C,c;MAAE,OEzFA,WFyFA,EEzFA,C;K;GFyFF,C;EUzF1C,oC;IA0BI,yBAAO,QAAP,K;G;EAEJ,oD;IdH6C,sC;II2Bb,8C;IUaqC,iBX1DL,aW0DkB,QX1DlB,EW0DgC,aX1DhC,C;IW0DzC,+BVCf,uCAA+B,gBUDqC,SVCrC,EAAsB,UAAtB,CUDhB,C;G;EAGvB,sC;IA0BI,2BAAO,QAAP,K;G;EAEJ,sD;IdvE6C,sC;II2Bb,8C;IUkFkB,iBX/Hc,aW+HW,QX/HX,EW+HyB,aX/HzB,C;IW+H5D,+BV/DI,uCAA+B,4BU+D8B,SV/D9B,EAAkC,UAAlC,CU+DnC,C;G;EAGJ,sC;IAyBI,OAAW,QAAX,mBAAQ,CAAR,CAAW,EAAM,QAAN,C;G;EAEf,sD;IAiCuB,OAAW,SAAX,mBAAQ,CAAR,CAAW,EAAO,QAAP,EAAkB,aAAlB,S;G;EAElC,kD;Id9K6C,sC;II2Bb,8C;IUkLqC,eX/NL,aW+NiB,OX/NjB,EW+N8B,aX/N9B,C;IEg0CrD,kBAAM,eAAa,wBD9uCD,QC8uCC,EAAwB,EAAxB,CAAb,C;IAqEA,Q;IAAA,ODnzCY,QCmzCZ,W;IAAb,OAAa,cAAb,C;MAAa,sB;MACT,WAAY,WC74CwB,WD64CV,IC74CU,CD64CxB,C;;ISvqCG,+BVxIf,uCAA+B,eUwIoC,SVxIpC,ECgzC5B,WDhzC4B,CUwIhB,C;G;EAEvB,oD;Id/M6C,sC;II2Bb,8C;IUqNkB,eXlQc,aWkQU,OXlQV,EWkQuB,aXlQvB,C;IWkQ5D,+BVtKI,uCAA+B,2BUsK6B,SVtK7B,EAAiC,QAAjC,CUsKnC,C;G;EAEJ,oD;IAkCuB,OAAW,QAAX,mBAAQ,CAAR,CAAW,EAAM,OAAN,EAAgB,aAAhB,S;G;EAElC,4C;IAQuB,wCAAsB,SAAtB,C;G;EC7SnB,qC;IfeyC,sC;II2Bb,8C;IAqDQ,0D;IW9FlC,OX4GE,uCAAuB,sBW5GsC,SX4GtC,C;G;EW7F3B,uC;IACE,gCAAqC,iBAAhB,yBAAgB,CAArC,C;G;EC/BN,kC;IhB+B2C,oC;IgBbrC,sCCUE,+BAAqB,iBDVoB,SCUpB,EDV0B,ICU1B,CDVvB,C;G;EAEN,8B;IhBW2C,oC;IgBKrC,sCCrBE,+BAAqB,iBDqBoB,SCrBpB,CDqBvB,C;G;EAEN,iC;IhBP2C,oC;IgBuBrC,sCCpCE,+BAAqB,oBDoCuB,SCpCvB,CDoCvB,C;G;EAmByB,6B;IAAqB,+DAAS,qB;aAAe,c;KAAxB,E;G;EAEpD,2C;IhB5C2C,oC;IgB+DrC,sCC7DE,+BAAqB,cD6DiB,SC7DjB,ED6DuB,gBC7DvB,CD6DvB,C;G;EEhGN,yC;IlBmC2C,oC;IkBnBrC,sCCFE,+BAAqB,mBDEuB,SCFvB,EDE6B,QCF7B,CDEvB,C;G;EAEN,6C;IlBiB2C,oC;IkBDrC,sCCfE,+BAAqB,uBDe2B,SCf3B,EDeiC,QCfjC,CDevB,C;G;EAEN,4C;IlBD2C,oC;IkBiBrC,sCC5BE,+BAAqB,sBD4B0B,SC5B1B,ED4BgC,QC5BhC,CD4BvB,C;G;EAEN,gD;IlBnB2C,oC;IkBmCrC,sCCzCE,+BAAqB,0BDyC8B,SCzC9B,EDyCoC,QCzCpC,CDyCvB,C;G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EEzDqG,0D;IAGvG,oCACA,KADA,EAEA,eAFA,EAGA,0BAHA,EAIA,qDAJA,C;G;EAIA,uE;IAAA,qB;MAAE,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;;;;;;ECL4D,yD;IAGtG,mCACA,KADA,EAEA,eAFA,EAGA,0BAHA,EAIA,oDAJA,EAKA,sDALA,EAMA,sDANA,C;G;EAIA,sE;IAAA,qB;MAAE,OAA2B,yBAAxB,4B;;OAAwB,YAAxB,uBAAwB,eAA3B,SAAkC,EAAlC,M;IAAuC,C;G;EACzC,wE;IAAA,qB;MAAE,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;EAC1C,wE;IAAA,qB;MAAE,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;;;;;;ECP+D,4E;IAIzG,sCACA,KADA,EAEA,cAFA,EAGA,eAHA,EAIA,0BAJA,EAKA,uEALA,EAMA,yDANA,EAOA,yDAPA,EAQA,wDARA,EASA,yDATA,C;G;EAKA,iG;IAAA,uB;MAAU,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,CAAnC,UAAkE,4BAA1B,4B;;OAA0B,YAA1B,sBAA0B,eAAlE,SAAyE,CAAzE,M;IAA6E,C;G;EACvF,2E;IAAA,qB;MAAE,OAA2B,yBAAxB,4B;;OAAwB,YAAxB,uBAAwB,eAA3B,SAAkC,EAAlC,M;IAAuC,C;G;EACzC,2E;IAAA,qB;MAAE,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;EAC1C,0E;IAAA,qB;MAAE,OAA6B,4BAA1B,4B;;OAA0B,YAA1B,sBAA0B,eAA7B,SAAoC,EAApC,M;IAAyC,C;G;EAC3C,2E;IAAA,qB;MAAE,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;;;;;;ECjB6D,0D;IAGvG,oCACA,KADA,EAEA,eAFA,EAGA,0BAHA,EAIA,qDAJA,C;G;EAIA,uE;IAAA,qB;MAAE,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;;;;;;ECVyD,+C;IAEnG,gCAA2B,eAA3B,C;G;;;;;;ECC2G,8D;IAG3G,wCACA,KADA,EAEA,eAFA,EAGA,0BAHA,EAIA,yDAJA,C;G;EAIA,2E;IAAA,qB;MAAE,OAAgC,8BAA7B,4B;;OAA6B,YAA7B,uBAA6B,eAAhC,SAAuC,EAAvC,M;IAA4C,C;G;;;;;;ECrBlD,oC;IACI,sCAAqG,8C;;KAArG,C;IACA,OAAO,CAAE,a;EACb,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECWsG,4D;IAGlG,sCACA,KADA,EAEA,eAFA,EAGA,4BAHA,EAIA,uDAJA,C;G;EAIA,yE;IAAA,qB;MAAE,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;;;;;;ECLuD,2D;IAGjG,qCACA,KADA,EAEA,eAFA,EAGA,4BAHA,EAIA,sDAJA,EAKA,sDALA,EAMA,sDANA,C;G;EAIA,wE;IAAA,qB;MAAE,OAA2B,yBAAxB,4B;;OAAwB,YAAxB,uBAAwB,eAA3B,SAAkC,EAAlC,M;IAAuC,C;G;EACzC,wE;IAAA,qB;MAAE,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;EAC1C,wE;IAAA,qB;MAAE,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;;;;;;ECP0D,8E;IAIpG,wCACA,KADA,EAEA,cAFA,EAGA,eAHA,EAIA,4BAJA,EAKA,yEALA,EAMA,yDANA,EAOA,yDAPA,EAQA,wDARA,EASA,yDATA,C;G;EAKA,mG;IAAA,uB;MAAU,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,CAAnC,UAAkE,4BAA1B,4B;;OAA0B,YAA1B,sBAA0B,eAAlE,SAAyE,CAAzE,M;IAA6E,C;G;EACvF,2E;IAAA,qB;MAAE,OAA2B,yBAAxB,4B;;OAAwB,YAAxB,uBAAwB,eAA3B,SAAkC,EAAlC,M;IAAuC,C;G;EACzC,2E;IAAA,qB;MAAE,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;EAC1C,0E;IAAA,qB;MAAE,OAA6B,4BAA1B,4B;;OAA0B,YAA1B,sBAA0B,eAA7B,SAAoC,EAApC,M;IAAyC,C;G;EAC3C,2E;IAAA,qB;MAAE,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;;;;;;ECjBwD,4D;IAGlG,sCACA,KADA,EAEA,eAFA,EAGA,4BAHA,EAIA,uDAJA,C;G;EAIA,yE;IAAA,qB;MAAE,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;;;;;;ECToD,iD;IAE9F,kCAA8B,eAA9B,C;G;;;;;;ECAsG,gE;IAGtG,0CACA,KADA,EAEA,eAFA,EAGA,4BAHA,EAIA,2DAJA,C;G;EAIA,6E;IAAA,qB;MAAE,OAAgC,8BAA7B,4B;;OAA6B,YAA7B,uBAA6B,eAAhC,SAAuC,EAAvC,M;IAA4C,C;G;;;;;;ECrBlD,sC;IACI,sCACI,8C;;KADJ,C;IAEA,OAAO,CAAE,a;EACb,C;E1BkBwB,mF;IAAA,mB;MAAE,OAAyB,gBAAS,CAAO,aAAM,QAAb,C;K;G;EAyBpD,qF;IAAA,mB;MAAE,OAAyB,gBAAS,CAAO,aAAM,QAAb,C;K;G;EAiC5B,qF;IAAA,mB;MAAE,OAAyB,gBAAS,CAAO,aAAM,QAAb,C;K;G;EA2BH,uF;IAAA,mB;MAAE,OAAyB,eAAO,aAAM,QAAb,C;K;G;EAyB9C,yF;IAAA,mB;MAAE,OAAyB,eAAO,aAAM,QAAb,C;K;G;EA+BzC,yF;IAAA,mB;MAAE,OAAyB,eAAO,aAAM,QAAb,C;K;G;EA8Bb,uF;IAAA,qB;MAAQ,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,C;K;G;EAgCvD,yF;IAAA,qB;MAAQ,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,C;K;G;EAuCd,yF;IAAA,qB;MAAQ,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,C;K;G;EAmCpD,uF;IAAA,yB;MAAY,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,C;K;G;EAwCrC,yF;IAAA,yB;MAAY,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,C;K;G;EA4Cd,yF;IAAA,yB;MAAY,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,C;K;G;EAwC5D,uF;IAAA,6B;MAAgB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,C;K;G;EA8CzC,yF;IAAA,6B;MAAgB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,C;K;G;EAoDd,yF;IAAA,6B;MAAgB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,C;K;G;EA4CpE,uF;IAAA,iC;MAAoB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,C;K;G;EAmD7C,yF;IAAA,iC;MAAoB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,C;K;G;EA0DzC,yF;IAAA,iC;MAAoB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,C;K;G;EAgDjD,uF;IAAA,qC;MAAwB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,EAAsC,EAAtC,C;K;G;EAwDjD,yF;IAAA,qC;MAAwB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,EAAsC,EAAtC,C;K;G;EAsE7C,yF;IAAA,qC;MAAwB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,EAAsC,EAAtC,C;K;G;E2Bv0B7D,uC;IlC8BwC,iC;IkCdlC,O3BM6B,4BAAkB,kB2BNnB,S3BMmB,E2BNb,Q3BMa,EANnB,wB2BAM,Q3BAkB,aAAxB,CAMmB,C;G;E2BJrD,yC;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,yC;IlCOwC,iC;IkCSlC,O3BjB6B,4BAAkB,kB2BiBnB,S3BjBmB,EAT7B,yC2B0BgB,Q3B1BhB,E2B0BU,S3B1BV,CAS6B,EATgC,wB2B0B7C,Q3B1BqE,aAAxB,CAShC,C;G;E2BoBrD,2D;IlCZwC,iC;IkCgClC,O3BxC6B,4BAAkB,kB2BwCnB,S3BxCmB,E2BwCb,Q3BxCa,EAyBnB,wB2BeM,Q3BfkB,aAAxB,CAzBmB,CAgCqB,gC2BQxB,gB3BRwB,C;G;E2BU1E,2D;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,2D;IlCvCwC,iC;IkC2DlC,O3BnE6B,4BAAkB,kB2BmEnB,S3BnEmB,EAgB7C,2C2BmDgC,Q3BnDhC,E2BmD0B,S3BnD1B,CAhB6C,EAiB7C,wB2BkDgC,Q3BlDR,aAAxB,CAjB6C,CAgCqB,gC2BmCxB,gB3BnCwB,C;G;E2BsC1E,yC;IlC9DwC,iC;IkC8ElC,O3B1BqC,4BAAkB,kB2B0B3B,S3B1B2B,E2B0BrB,Q3B1BqB,EAN3B,wB2BgCM,Q3BhCkB,aAAxB,CAM2B,C;G;E2B4B7D,yC;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,yC;IlCrFwC,iC;IOyChC,QAAQ,2C2B4DwB,Q3B5DxB,E2B4DkB,S3B5DlB,C;I2B4DV,O3BjDqC,4BAAkB,kB2BiD3B,S3BjD2B,EAV9B,CAU8B,EAV3B,wB2B2DM,Q3B3DkB,aAAxB,CAU2B,C;G;E2BsD7D,0C;IlC1GwC,iC;IkC0HlC,O3B7CqB,4BAAkB,wB2B6CL,S3B7CK,E2B6CC,M3B7CD,E2B6CC,M3BnDD,aAMA,C;G;E2B+C7C,4C;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,4C;IlCjIwC,iC;IkCkJlC,O3BrEqB,4BAAkB,wB2BqEL,S3BrEK,EATI,+C2B8EH,M3B9EG,E2B8ET,S3B9ES,CASJ,E2BqEC,M3B9E8D,aAS/D,C;G;E2BwE7C,8D;IlCrJwC,iC;IkC0KlC,O3B7FqB,4BAAkB,wB2B6FL,S3B7FK,E2B6FC,M3B7FD,E2B6FC,M3BvEkB,aAtBnB,CA6BkB,gC2BgET,gB3BhES,C;G;E2BkE/D,8D;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,8D;IlCjLwC,iC;IkCuMlC,O3B1HqB,4BAAkB,wB2B0HL,S3B1HK,EAgBf,iD2B0GgB,M3B1GhB,E2B0GU,S3B1GV,CAhBe,E2B0HC,M3B1G2C,aAhB5C,CA6BkB,gC2B6FT,gB3B7FS,C;G;E2BgG/D,4C;IlC1MwC,iC;IkC2NlC,O3BlF6B,4BAAkB,wB2BkFb,S3BlFa,E2BkFP,M3BlFO,E2BkFP,M3BxF0B,aAMnB,C;G;E2BoFrD,4C;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,4C;IlClOwC,iC;IO4HhC,QAAQ,iD2BwH8B,M3BxH9B,E2BwHwB,S3BxHxB,C;I2BwHV,O3BpG6B,4BAAkB,wB2BoGb,S3BpGa,EAnBhB,CAmBgB,EAnBb,CAmBa,E2BoGP,M3BvHI,aAmBG,C;G;E2ByGrD,kD;IlCzPwC,iC;IkC0QlC,O3BnGqB,4BAAkB,wB2BmGL,S3BnGK,E2BmGC,M3BnGD,E2BmGS,I3BnGT,E2BmGC,M3B1GwB,aAOzB,C;G;E2BqG7C,kD;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,mD;IlCjRwC,iC;IkCoSlC,O3B7HqB,4BAAkB,wB2B6HL,S3B7HK,EAbf,+C2B0IgB,M3B1IhB,E2B0IU,S3B1IV,CAae,E2B6HS,I3B7HT,E2B6HC,M3B1I2D,aAa5D,C;G;E2BgI7C,qE;IlCvSwC,iC;IkC4TlC,O3BrJqB,4BAAkB,wB2BqJL,S3BrJK,E2BqJC,M3BrJD,E2BqJS,I3BrJT,E2BqJC,M3BvHwB,aA9BzB,CAsCwB,gC2B+GT,gB3B/GS,C;G;E2BiHrE,qE;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,qE;IlCnUwC,iC;IkCyVlC,O3BlLqB,4BAAkB,wB2BkLL,S3BlLK,EAmBrC,iD2B+JsC,M3B/JtC,E2B+JgC,S3B/JhC,CAnBqC,E2BkLS,I3BlLT,E2BkLC,M3B7J/B,aArB8B,CAsCwB,gC2B4IT,gB3B5IS,C;G;E2B+IrE,mD;IlC5VwC,iC;IkC6WlC,O3B7H6B,4BAAkB,wB2B6Hb,S3B7Ha,E2B6HP,M3B7HO,E2B6HC,I3B7HD,E2B6HP,M3BpIgC,aAOzB,C;G;E2B+HrD,mD;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,mD;IlCpXwC,iC;IOiOhC,QAAmB,iD2BqKmB,M3BrKnB,E2BqKa,S3BrKb,C;I2BqKrB,O3BtJ6B,4BAAkB,wB2BsJb,S3BtJa,EAdhB,CAcgB,E2BsJC,I3BtJD,E2BsJP,M3BpKO,aAcA,C;G;E2B2JrD,yD;IlC3YwC,iC;IkC4ZlC,O3BrIqB,4BAAkB,wB2BqIL,S3BrIK,E2BqIC,M3BrID,E2BqIS,I3BrIT,E2BqIe,I3BrIf,E2BqIC,M3B7I8B,aAQ/B,C;G;E2BuI7C,yD;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,yD;IlCnawC,iC;IkCqblC,O3B9JqB,4BAAkB,wB2B8JL,S3B9JK,EAnBrC,+C2BiLsC,M3BjLtC,E2BiLgC,S3BjLhC,CAmBqC,E2B8JS,I3B9JT,E2B8Je,I3B9Jf,E2B8JC,M3B9K/B,aAgB8B,C;G;E2BiK7C,2E;IlCxbwC,iC;IkC6clC,O3BtLqB,4BAAkB,wB2BsLL,S3BtLK,E2BsLC,M3BtLD,E2BsLS,I3BtLT,E2BsLe,I3BtLf,E2BsLC,M3BpJ8B,aAlC/B,CA2C8B,gC2B2IT,gB3B3IS,C;G;E2B6I3E,2E;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,2E;IlCpdwC,iC;IkC0elC,O3BnNqB,4BAAkB,wB2BmNL,S3BnNK,EAqBrC,iD2B8LsC,M3B9LtC,E2B8LgC,S3B9LhC,CArBqC,E2BmNS,I3BnNT,E2BmNe,I3BnNf,E2BmNC,M3B3L/B,aAxB8B,CA2C8B,gC2BwKT,gB3BxKS,C;G;E2B2K3E,yD;IlC7ewC,iC;IkC8flC,O3BrJ6B,4BAAkB,wB2BqJb,S3BrJa,E2BqJP,M3BrJO,E2BqJC,I3BrJD,E2BqJO,I3BrJP,E2BqJP,M3B7JsC,aAQ/B,C;G;E2BuJrD,yD;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,yD;IlCrgBwC,iC;IOwVhC,QAAuB,iD2B+Le,M3B/Lf,E2B+LS,S3B/LT,C;I2B+LzB,O3B9K6B,4BAAkB,wB2B8Kb,S3B9Ka,EAhBhB,CAgBgB,E2B8KC,I3B9KD,E2B8KO,I3B9KP,E2B8KP,M3B9La,aAgBN,C;G;E2BmLrD,+D;IlC5hBwC,iC;IkC6iBlC,O3BvJqB,4BAAkB,wB2BuJL,S3BvJK,E2BuJC,M3BvJD,E2BuJS,I3BvJT,E2BuJe,I3BvJf,E2BuJqB,I3BvJrB,E2BuJC,M3BhKoC,aASrC,C;G;E2ByJ7C,+D;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,+D;IlCpjBwC,iC;IkCskBlC,O3BhLqB,4BAAkB,wB2BgLL,S3BhLK,EAtBrC,+C2BsMsC,M3BtMtC,E2BsMgC,S3BtMhC,CAsBqC,E2BgLS,I3BhLT,E2BgLe,I3BhLf,E2BgLqB,I3BhLrB,E2BgLC,M3BlM/B,aAkB8B,C;G;E2BmL7C,iF;IlCzkBwC,iC;IkC8lBlC,O3BxMqB,4BAAkB,wB2BwML,S3BxMK,E2BwMC,M3BxMD,E2BwMS,I3BxMT,E2BwMe,I3BxMf,E2BwMqB,I3BxMrB,E2BwMC,M3BjKoC,aAvCrC,CAkDiB,gC2BsJU,gB3BtJV,C;G;E2BwJ9D,iF;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,iF;IlCrmBwC,iC;IkC2nBlC,O3BrOqB,4BAAkB,wB2BqOL,S3BrOK,EAwBrC,iD2B6MsC,M3B7MtC,E2B6MgC,S3B7MhC,CAxBqC,E2BqOS,I3BrOT,E2BqOe,I3BrOf,E2BqOqB,I3BrOrB,E2BqOC,M3BzM/B,aA5B8B,CAkDiB,gC2BmLU,gB3BnLV,C;G;E2BsL9D,+D;IlC9nBwC,iC;IkC+oBlC,O3B1J6B,4BAAkB,wB2B0Jb,S3B1Ja,E2B0JP,M3B1JO,E2B0JC,I3B1JD,E2B0JO,I3B1JP,E2B0Ja,I3B1Jb,E2B0JP,M3BnK4C,aASrC,C;G;E2B4JrD,+D;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,+D;IlCtpBwC,iC;IOkehC,QAA2B,iD2BsMW,M3BtMX,E2BsMK,S3BtML,C;I2BsM7B,O3BnL6B,4BAAkB,wB2BmLb,S3BnLa,EAlBhB,CAkBgB,E2BmLC,I3BnLD,E2BmLO,I3BnLP,E2BmLa,I3BnLb,E2BmLP,M3BrMmB,aAkBZ,C;G;E2BwLrD,qE;IlC7qBwC,iC;IkC8rBlC,O3BvJqB,4BAAkB,wB2BuJL,S3BvJK,E2BuJC,M3BvJD,E2BuJS,I3BvJT,E2BuJe,I3BvJf,E2BuJqB,I3BvJrB,E2BuJ2B,I3BvJ3B,E2BuJC,M3BjK0C,aAU3C,C;G;E2ByJ7C,qE;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,qE;IlCrsBwC,iC;IkCutBlC,O3BhLqB,4BAAkB,wB2BgLL,S3BhLK,EAzBrC,+C2ByMsC,M3BzMtC,E2ByMgC,S3BzMhC,CAyBqC,E2BgLS,I3BhLT,E2BgLe,I3BhLf,E2BgLqB,I3BhLrB,E2BgL2B,I3BhL3B,E2BgLC,M3BpM/B,aAoB8B,C;G;E2BmL7C,uF;IlC1tBwC,iC;IkC+uBlC,O3BxMqB,4BAAkB,wB2BwML,S3BxMK,E2BwMC,M3BxMD,E2BwMS,I3BxMT,E2BwMe,I3BxMf,E2BwMqB,I3BxMrB,E2BwM2B,I3BxM3B,E2BwMC,M3B7J0C,aA3C3C,CAuDuB,gC2BiJU,gB3BjJV,C;G;E2BmJpE,uF;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,uF;IlCtvBwC,iC;IkC4wBlC,O3BrOqB,4BAAkB,wB2BqOL,S3BrOK,EA0BrC,iD2B2MsC,M3B3MtC,E2B2MgC,S3B3MhC,CA1BqC,E2BqOS,I3BrOT,E2BqOe,I3BrOf,E2BqOqB,I3BrOrB,E2BqO2B,I3BrO3B,E2BqOC,M3BtM/B,aA/B8B,CAuDuB,gC2B8KU,gB3B9KV,C;G;E2BiLpE,qE;IlC/wBwC,iC;IkCgyBlC,O3BhJ6B,4BAAkB,wB2BgJb,S3BhJa,E2BgJP,M3BhJO,E2BgJC,I3BhJD,E2BgJO,I3BhJP,E2BgJa,I3BhJb,E2BgJmB,I3BhJnB,E2BgJP,M3B1JkD,aAU3C,C;G;E2BkJrD,qE;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,qE;IlCvyBwC,iC;IO0nBhC,QACI,iD2B8LkC,M3B9LlC,E2B8L4B,S3B9L5B,C;I2B8LN,O3BzK6B,4BAAkB,wB2ByKb,S3BzKa,EApBhB,CAoBgB,E2ByKC,I3BzKD,E2ByKO,I3BzKP,E2ByKa,I3BzKb,E2ByKmB,I3BzKnB,E2ByKP,M3B7LyB,aAoBlB,C;G;E2B8KrD,2E;IlC9zBwC,iC;IkC+0BlC,O3BxIqB,4BAAkB,wB2BwIL,S3BxIK,E2BwIC,M3BxID,E2BwIS,I3BxIT,E2BwIe,I3BxIf,E2BwIqB,I3BxIrB,E2BwI2B,I3BxI3B,E2BwIiC,I3BxIjC,E2BwIC,M3BnJgD,aAWjD,C;G;E2B0I7C,2E;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,2E;IlCt1BwC,iC;IkCw2BlC,O3BjKqB,4BAAkB,wB2BiKL,S3BjKK,EA5BrC,+C2B6LsC,M3B7LtC,E2B6LgC,S3B7LhC,CA4BqC,E2BiKS,I3BjKT,E2BiKe,I3BjKf,E2BiKqB,I3BjKrB,E2BiK2B,I3BjK3B,E2BiKiC,I3BjKjC,E2BiKC,M3BvL/B,aAsB8B,C;G;E2BoK7C,6F;IlC32BwC,iC;IkCg4BlC,O3BzLqB,4BAAkB,wB2ByLL,S3BzLK,E2ByLC,M3BzLD,E2ByLS,I3BzLT,E2ByLe,I3BzLf,E2ByLqB,I3BzLrB,E2ByL2B,I3BzL3B,E2ByLiC,I3BzLjC,E2ByLC,M3B1IgD,aA/CjD,CA4D6B,gC2B6HU,gB3B7HV,C;G;E2B+H1E,6F;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,6F;IlCv4BwC,iC;IkC65BlC,O3BtNqB,4BAAkB,wB2BsNL,S3BtNK,EA4BrC,iD2B0LsC,M3B1LtC,E2B0LgC,S3B1LhC,CA5BqC,E2BsNS,I3BtNT,E2BsNe,I3BtNf,E2BsNqB,I3BtNrB,E2BsN2B,I3BtN3B,E2BsNiC,I3BtNjC,E2BsNC,M3BpL/B,aAlC8B,CA4D6B,gC2B0JU,gB3B1JV,C;G;E2B6J1E,2E;IlCh6BwC,iC;IkCi7BlC,O3BjH6B,4BAAkB,wB2BiHb,S3BjHa,E2BiHP,M3BjHO,E2BiHC,I3BjHD,E2BiHO,I3BjHP,E2BiHa,I3BjHb,E2BiHmB,I3BjHnB,E2BiHyB,I3BjHzB,E2BiHP,M3B5HwD,aAWjD,C;G;E2BmHrD,2E;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,2E;IlCx7BwC,iC;IOwyBhC,QACI,iD2BiKkC,M3BjKlC,E2BiK4B,S3BjK5B,C;I2BiKN,O3B1I6B,4BAAkB,wB2B0Ib,S3B1Ia,EAtBhB,CAsBgB,E2B0IC,I3B1ID,E2B0IO,I3B1IP,E2B0Ia,I3B1Ib,E2B0ImB,I3B1InB,E2B0IyB,I3B1IzB,E2B0IP,M3BhK+B,aAsBxB,C;G;E4Bj2BrD,gE;InCmC8C,uC;ImCZxC,sCCdE,kCAAwB,gCDcmC,SCdnC,EDcyC,QCdzC,EDcmD,SCdnD,CDc1B,C;G;EAEN,kE;InCU8C,uC;ImCaxC,sCCjCE,kCAAwB,gCDiCmC,SCjCnC,EDiCyC,QCjCzC,EDiCmD,SCjCnD,CDiC1B,C;G;EE5BF,mC;IrCiBqC,kC;IqCjB7B,O7BNJ,6BAAmB,yB6BMqB,S7BNrB,C;G;E6BuBvB,sC;IrCAqC,kC;IqCA7B,kC7BpBJ,6BAAmB,4B6BoB6C,S7BpB7C,C6BoBf,C;G;EAGZ,wD;IA4BM,OAA+B,SAAX,UAAX,eAAT,yBAAS,CAAW,EAAQ,CAAR,CAAW,EAAO,QAAP,EAAkB,aAAlB,S;G;EAErC,uD;IAyBM,OAA+B,MAAX,UAAX,eAAT,yBAAS,CAAW,EAAQ,CAAR,CAAW,EAAM,sBAAN,C;G;EAErC,sF;IA+BM,OAA+B,QAAX,UAAX,eAAT,yBAAS,CAAW,EAAQ,CAAR,CAAW,EAAQ,sBAAR,EAAiC,6BAAjC,S;G;EAErC,6D;IAmBM,OAAsB,SAAL,WAAR,YAAT,yBAAS,CAAQ,CAAK,EAAO,QAAP,EAAkB,aAAlB,S;G;EAE5B,8D;IAyBM,OAAsB,QAAL,WAAR,YAAT,yBAAS,CAAQ,CAAK,EAAM,sBAAN,C;G;EAE5B,6F;IA+BM,OAAsB,UAAL,WAAR,YAAT,yBAAS,CAAQ,CAAK,EAAQ,sBAAR,EAAiC,6BAAjC,S;G;EAG5B,2D;IAmBM,OAAY,SAAZ,4BAAY,EAAO,QAAP,EAAkB,aAAlB,S;G;EAGlB,gD;IAqBM,OAA+B,MAAX,UAAX,eAAT,yBAAS,CAAW,EAAQ,CAAR,CAAW,EAAM,sBAAN,C;G;EAGrC,iD;IAqBM,OAAY,MAAZ,4BAAY,EAAM,sBAAN,C;G;EAGlB,gD;IrCrPyC,kC;IqCwQnC,sC7B3Pa,6BAAmB,a6B2PK,S7B3PL,E6B2PW,sB7B3PX,C6B2PhC,C;G;EClTN,qC;IAmBM,sCAAyB,KAAzB,EAAgC,SAAhC,C;G;EAEN,uC;IAuBM,wCAA2B,KAA3B,EAAkC,SAAlC,EAAwC,yBAAxC,C;G;EAEN,qC;IAmBM,sCAAyB,KAAzB,EAAgC,SAAhC,C;G;EAEN,oC;IAwBM,qCAAwB,KAAxB,EAA+B,SAA/B,C;G;EAEN,yC;IAmBM,0CAA6B,KAA7B,EAAoC,SAApC,C;G;ECrGN,sC;IAmBM,2BAAO,QAAP,K;G;EAEN,sD;IvCUyC,kC;IQIT,0C;I+BcgB,iBpC/CgB,aoC+CO,QpC/CP,EoC+CqB,apC/CrB,C;IoC+C1D,iC/BSE,qCAA2B,0B+BT8B,S/BS9B,EAAgC,UAAhC,C+BT7B,C;G;EAEN,kD;IAuBM,0BAAQ,sBAAR,K;G;EAEN,mF;IvC7CyC,kC;IQIT,0C;I+BuEgB,wBpCxGgB,aoCwGkB,sBpCxGlB,EoCwG8C,6BpCxG9C,C;IoCwG1D,iC/BGE,qCAA2B,qC+BHyC,S/BGzC,EAA2C,iBAA3C,C+BH7B,C;G;EAEN,8C;IAQuB,wCAAsB,SAAtB,C;G;ECpHvB,sC;IAmBM,2BAAO,QAAP,K;G;EAEN,sD;IxCUyC,kC;IQIT,0C;IgCMgB,iBrCvCgB,aqCuCW,QrCvCX,EqCuCyB,arCvCzB,C;IqCuC1D,iChC2BE,qCAA2B,8BgC3BkC,ShC2BlC,EAA8B,UAA9B,CgC3B7B,C;G;EAEN,oD;IAuBM,4BAAQ,sBAAR,K;G;EAEN,qF;IxCrCyC,kC;IQIT,0C;IgCwEgB,wBrCzGgB,aqCyGsB,sBrCzGtB,EqCyGkD,6BrCzGlD,C;IqCyG1D,iChCUE,qCAA2B,yCgCV6C,ShCU7C,EAAyC,iBAAzC,CgCV7B,C;G;EAEN,8C;IAQuB,0CAAsB,SAAtB,C;G;ECzHvB,sC;IAmBM,2BAAO,QAAP,K;G;EAEN,sD;IzCcyC,kC;IQIT,0C;IiCCgB,iBtClCgB,asCkCQ,QtClCR,EsCkCsB,atClCtB,C;IsCkC1D,iCjC0CE,qCAA2B,2BiC1C+B,SjC0C/B,EAA2B,UAA3B,CiC1C7B,C;G;EAEN,oD;IAuBM,4BAAQ,sBAAR,K;G;EAEN,qF;IzChCyC,kC;IQIT,0C;IiC0DgB,wBtC3FgB,asC2FmB,sBtC3FnB,EsC2F+C,6BtC3F/C,C;IsC2F1D,iCjC+BE,qCAA2B,sCiC/B0C,SjC+B1C,EAAsC,iBAAtC,CiC/B7B,C;G;EChGN,6E;I1CkCyC,kC;IQIT,0C;IkCVC,aAEzB,aAAa,UAAb,EAAyB,WAAzB,EAAsC,mBAAtC,C;IAHe,iClCgEJ,qCAA2B,kCkC9DtC,SlC8DsC,EAAkC,MAAlC,CkChEvB,C;G;EAOvB,+E;I1CAyC,kC;IQIT,0C;IkCiCC,aAEzB,aAAa,UAAb,EAAyB,WAAzB,EAAsC,mBAAtC,C;IAHe,iClCgEJ,qCAA2B,6CkC9DtC,SlC8DsC,EAA6C,MAA7C,CkChEvB,C;G;EChEnB,mC;I3C4BqC,kC;IQIT,0C;IAiEQ,sD;ImCjG5B,OnC4IJ,yCAAuB,oBmC5IsC,SnC4ItC,C;G;EmC5H3B,6B;I3CYqC,kC;IQIT,0C;IAiEQ,sD;ImChF5B,OnC8HJ,yCAAuB,wBmC9H0C,SnC8H1C,C;G;EmC7G3B,gC;I3CNqC,kC;IQIT,0C;IAiEQ,sD;ImC/D5B,OnCgHJ,yCAAuB,iBmChHmC,SnCgHnC,C;G;EmC/F3B,+B;I3CvBqC,kC;IQIT,0C;IAiEQ,sD;ImC7C5B,OnCiGJ,yCAAuB,qBmCjGuC,SnCiGvC,C;G;EmCjF3B,gC;I3CxCqC,kC;IQIT,0C;IAiEQ,sD;ImC7B5B,OnCoFJ,yCAAuB,4BmCpF8C,SnCoF9C,C;G;EmCrE3B,+B;I3CvDqC,kC;IQIT,0C;IAiEQ,sD;ImCd5B,OnCwEJ,yCAAuB,kCmCxEoD,SnCwEpD,C;G;EoCvK/B,+B;IAiBM,O5CyB+B,8B4CzBf,aAAI,SAAJ,EAAU,KAAV,C;G;EAEtB,mD;I5CuBqC,8B;I4CJ/B,sCCVE,yBAAe,aDUgB,SCVhB,EDUsB,KCVtB,EDU6B,gBCV7B,CDUjB,C;G;EAEN,iC;IAiBM,O5Cf+B,8B4Cef,qBAAY,SAAZ,EAAkB,KAAlB,C;G;EErDtB,yD;I9CwCoC,6B;I8ClBF,oB3Cf8B,a2Cef,Y3Cfe,E2CeG,U3CfH,C;I2Ce1D,sCCiCE,wBAAc,kBDjCqB,SCiCrB,EAAgB,aAAhB,CDjChB,C;G;EAEN,yD;I9CgBoC,6B;I8CUgE,kB3C3CpC,a2C2CM,Q3C3CN,E2C2CoB,c3C3CpB,C;IEg0CrD,kBAAM,eAAa,qCAAwB,EAAxB,CAAb,C;IAqEA,Q;IAAA,6B;IAAb,OAAa,cAAb,C;MAAa,sB;MACT,WAAY,WAAc,IyC31C2E,SzC21CzF,C;;IyC31ChB,sCCYI,wBAAc,wCDZyC,SCYzC,E1Cg1CX,W0Ch1CW,CDZlB,C;G;EAEJ,qC;I9CZoC,6B;I8C4B9B,sCCvCE,wBAAc,qBDuCwB,SCvCxB,EDuC8B,GCvC9B,CDuChB,C;G;EAEN,wC;I9C9BoC,6B;I8C8C9B,sCCtDE,wBAAc,wBDsD2B,SCtD3B,EDsDiC,GCtDjC,CDsDhB,C;G;EAIN,qC;I9ClDoC,6B;I8CoE9B,OCzCE,wBAAc,qBDyCW,SCzCX,EDyCiB,GCzCjB,C;G;ED2CtB,yD;I9CtEoC,6B;I8CyF9B,sCCtDE,wBAAc,qBDsDwB,SCtDxB,EDsD8B,GCtD9B,EDsDmC,gBCtDnC,CDsDhB,C;G;EAGN,qC;I9C5FoC,6B;I8C6G9B,OCrEE,wBAAc,6BDqEmB,SCrEnB,EDqEyB,GCrEzB,C;G;EDuEtB,oC;I9C/GoC,6B;I8C+H9B,sCC3EyE,wBAAc,iBD2EnD,SC3EmD,ED2E7C,IC3E6C,CD2EvF,C;G;EAEN,8B;I9CjIoC,6B;I8CiJ9B,sCCrJE,wBAAc,iBDqJoB,SCrJpB,CDqJhB,C;G;EAEN,iC;I9CnJoC,6B;I8CmK9B,sCC/JE,wBAAc,oBD+JuB,SC/JvB,CD+JhB,C;G;EAoByB,6B;IAAyB,+DAAS,qB;aAAW,c;KAApB,E;G;EAExD,2C;I9CzLoC,6B;I8C4M9B,sCCjJa,wBAAc,cDiJM,SCjJN,EDiJY,gBCjJZ,CDiJ3B,C;G;EAmB2B,+B;IAAgC,iEAAS,qB;aAAW,gB;KAApB,E;G;EAEjE,+C;I9CjOoC,6B;I8CoP9B,sCClLa,wBAAc,gBDkLQ,SClLR,EDkLc,gBClLd,CDkL3B,C;G;EAoB0C,8B;IAAE,OAAA,EAAG,Q;EAAQ,C;EAlB7D,8B;IAkBM,O5C1QE,+BAAsB,gB4C0QC,S5C1QD,C4C0QO,oBAAW,gBAAX,C;G;EAErC,kD;IAmBM,OAAA,oBAAY,gCAAuB,gBAAvB,C;G;EExUlB,2C;IhD2CoC,6B;I+C1BqB,kC;ICInD,sCCQa,6BAAmB,oBDRa,SCQb,EDRmB,GCQnB,EDRwB,KCQxB,CDRhC,C;G;EAmBoC,4B;IAAoB,8DAAS,qB;aAAiB,a;KAA1B,E;G;EAoB1B,8B;IAAoC,8DAAS,qB;aAAiB,a;KAA1B,E;G;EAExE,0C;IhDnBoC,6B;I+C1BqB,kC;ICgEnD,sCC7Ca,6BAAmB,aD6CM,SC7CN,ED6CY,gBC7CZ,CD6ChC,C;G;EAmBsC,8B;IAAoB,gEAAS,qB;aAAiB,e;KAA1B,E;G;EAoB1B,gC;IAAoC,gEAAS,qB;aAAiB,e;KAA1B,E;G;EAE1E,8C;IhD/EoC,6B;I+C1BqB,kC;IC4HnD,sCClGa,6BAAmB,eDkGQ,SClGR,EDkGc,gBClGd,CDkGhC,C;G;EE5HiC,8B;IAAoB,gEAAS,qB;aAAY,e;KAArB,E;G;EAoB1B,gC;IAAoC,gEAAS,qB;aAAY,e;KAArB,E;G;EAGrE,4C;IlDKqC,8B;IkDc/B,sCCtCa,yBAAe,eDsCO,SCtCP,EDsCa,gBCtCb,CDsC5B,C;G;EAmBkC,+B;IAAoB,iEAAS,qB;aAAY,gB;KAArB,E;G;EAoB1B,iC;IAAoC,iEAAS,qB;aAAY,gB;KAArB,E;G;EAGtE,6C;IlDxDqC,8B;IkD2E/B,sCC5Fa,yBAAe,gBD4FQ,SC5FR,ED4Fc,gBC5Fd,CD4F5B,C;G;EE1GgB,uC;IAClB,oD;G;2BAEA,Y;IAAuD,cAAO,2BAAP,C;G;;;;;;EAelC,wE;IACrB,oD;IACA,kE;G;;SAEsB,Y;MAAQ,kC;K;;;SACH,Y;MAAQ,yC;K;;6BAEnC,Y;IAAuD,OjD7BK,aiD6BL,2BjD7BK,EiD6BuB,kCjD7BvB,C;G;;;;;;EiDsC7B,oD;IAAC,c;IAAY,8D;G;8BAC5C,Y;IAAiD,oBAAO,gCAAP,C;G;gCACjD,Y;IACM,yBAAe,QAAf,iBAAgC,wCAAJ,GAAyC,MAAzC,GAAqD,QAAjF,O;G;;;;;;kCARV,Y;IAKoC,e;G;kCALpC,Y;IAKgD,uC;G;oCALhD,4C;IAAA,oBAKoC,+BALpC,EAKgD,uGALhD,C;G;gCAAA,Y;IAAA,c;IAKoC,oD;IAAY,4E;IALhD,a;G;8BAAA,iB;IAAA,4IAKoC,kCALpC,IAKgD,kFALhD,I;G;EAeuB,yB;IAAC,wB;G;2BACpB,Y;IAAwB,cAAO,aAAP,C;G;;;;;;+BAL5B,Y;IAIwB,oB;G;+BAJxB,oB;IAAA,iBAIwB,8CAJxB,C;G;6BAAA,Y;IAAA,OAIwB,kDAJxB,M;G;6BAAA,Y;IAAA,c;IAIwB,yD;IAJxB,a;G;2BAAA,iB;IAAA,2IAIwB,4CAJxB,G;G;EAYmB,yC;IACf,kC;IACA,4C;G;;SADA,Y;MAAA,8B;K;;;SACA,Y;MAAA,mC;K;;4BAEA,Y;IAAwB,iBAAO,aAAP,SAAkB,kBAAlB,E;G;;;;;;ECxDoB,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAjBlE,kC;IAiBM,OnD2BE,+BAAsB,gBmD3BC,SnD2BD,CmD3BO,oBAAW,mBAAX,C;G;8GCdrC,yB;IAAA,gC;ItD+CkC,6G;ISO9B,2K;I6CtDJ,wE;MtD+C0C,mC;MSJ1B,yC;M6CxBoB,yC;M7CyC5B,kCAA0B,c6CzCO,S7CyCP,EAA6B,YAA7B,E6CzC+B,gB7CyC/B,C;I6CxClC,C;GApBA,C;EAsBA,+B;ItDyB0C,mC;ISJ1B,yC;IAsBR,oCAA0B,uB6C3BgB,S7C2BhB,C;E6C1BlC,C;EAEA,8C;IAqBiC,kBAA7B,2DAAS,qB;aAAW,iB;KAApB,E;ItDpCgC,6B;IuDHJ,uC;IAA5B,iCtD+BI,wBAAc,mBsD/BoB,WtD+BpB,EAAiB,IAAjB,EqDQuB,gBrDRvB,CsD/BlB,C;EDwCJ,C;EA4BY,yE;IAAA,4B;MAAE,oBAAS,gBAAT,EAAoB,qBAApB,S;MAAmC,W;IAAA,C;G;EA1BjD,6D;IA0BI,mBAAQ,+CAAR,C;EACJ,C;sHCzFA,yB;IAAA,gC;IvDuB4B,6G;ICsBxB,mJ;IsD7CJ,wD;MvDuBoC,6B;MuDHJ,yB;MAA5B,+BtD+BI,wBAAc,mBsD/BoB,StD+BpB,EAAiB,IAAjB,EsD/BoC,gBtD+BpC,CsD/BlB,C;IACJ,C;GArBA,C;sGAuBA,yB;IAAA,gC;IvDA4B,6G;IC4ExB,iL;IsD5EJ,8D;MvDAoC,6B;MCmDpB,+C;MsDnB0B,+B;MtDgDlC,wCAAgC,asDhDM,StDgDN,EAAW,OAAX,EsDhDyB,gBtDgDzB,C;IsD/CxC,C;GAjCA,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}