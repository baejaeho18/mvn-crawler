Compiled from "Vector.scala"
public final class scalaz.std.vector$ implements scalaz.std.VectorInstances,scalaz.std.VectorFunctions {
  public static scalaz.std.vector$ MODULE$;

  private final scalaz.Traverse<scala.collection.immutable.Vector> vectorInstance;

  public static {};
    Code:
       0: new           #2                  // class scalaz/std/vector$
       3: invokespecial #19                 // Method "<init>":()V
       6: return

  public <A> scala.collection.immutable.Vector<A> empty();
    Code:
       0: aload_0
       1: invokestatic  #26                 // InterfaceMethod scalaz/std/VectorFunctions.empty$:(Lscalaz/std/VectorFunctions;)Lscala/collection/immutable/Vector;
       4: areturn

  public final <A> scala.collection.immutable.Vector<A> intersperse(scala.collection.immutable.Vector<A>, A);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: invokestatic  #36                 // InterfaceMethod scalaz/std/VectorFunctions.intersperse$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Ljava/lang/Object;)Lscala/collection/immutable/Vector;
       6: areturn

  public final <A> scalaz.Maybe<scalaz.NonEmptyList<A>> toNel(scala.collection.immutable.Vector<A>);
    Code:
       0: aload_0
       1: aload_1
       2: invokestatic  #45                 // InterfaceMethod scalaz/std/VectorFunctions.toNel$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;)Lscalaz/Maybe;
       5: areturn

  public final <A> scalaz.Maybe<scalaz.Zipper<A>> toZipper(scala.collection.immutable.Vector<A>);
    Code:
       0: aload_0
       1: aload_1
       2: invokestatic  #50                 // InterfaceMethod scalaz/std/VectorFunctions.toZipper$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;)Lscalaz/Maybe;
       5: areturn

  public final <A> scalaz.Maybe<scalaz.Zipper<A>> zipperEnd(scala.collection.immutable.Vector<A>);
    Code:
       0: aload_0
       1: aload_1
       2: invokestatic  #54                 // InterfaceMethod scalaz/std/VectorFunctions.zipperEnd$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;)Lscalaz/Maybe;
       5: areturn

  public final <A, B> B $less$up$greater(scala.collection.immutable.Vector<A>, scala.Function1<scalaz.NonEmptyList<A>, B>, scalaz.Monoid<B>);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: aload_3
       4: invokestatic  #63                 // InterfaceMethod scalaz/std/VectorFunctions.$less$up$greater$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Lscala/Function1;Lscalaz/Monoid;)Ljava/lang/Object;
       7: areturn

  public final <A, M> M takeWhileM(scala.collection.immutable.Vector<A>, scala.Function1<A, M>, scalaz.Monad<M>);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: aload_3
       4: invokestatic  #74                 // InterfaceMethod scalaz/std/VectorFunctions.takeWhileM$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Lscala/Function1;Lscalaz/Monad;)Ljava/lang/Object;
       7: areturn

  public final <A, M> M takeUntilM(scala.collection.immutable.Vector<A>, scala.Function1<A, M>, scalaz.Monad<M>);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: aload_3
       4: invokestatic  #80                 // InterfaceMethod scalaz/std/VectorFunctions.takeUntilM$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Lscala/Function1;Lscalaz/Monad;)Ljava/lang/Object;
       7: areturn

  public final <A, M> M filterM(scala.collection.immutable.Vector<A>, scala.Function1<A, M>, scalaz.Applicative<M>);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: aload_3
       4: invokestatic  #88                 // InterfaceMethod scalaz/std/VectorFunctions.filterM$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Lscala/Function1;Lscalaz/Applicative;)Ljava/lang/Object;
       7: areturn

  public final <A, M> M findM(scala.collection.immutable.Vector<A>, scala.Function1<A, M>, scalaz.Monad<M>);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: aload_3
       4: invokestatic  #94                 // InterfaceMethod scalaz/std/VectorFunctions.findM$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Lscala/Function1;Lscalaz/Monad;)Ljava/lang/Object;
       7: areturn

  public final <A> scala.collection.immutable.Vector<scala.collection.immutable.Vector<A>> powerset(scala.collection.immutable.Vector<A>);
    Code:
       0: aload_0
       1: aload_1
       2: invokestatic  #101                // InterfaceMethod scalaz/std/VectorFunctions.powerset$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;)Lscala/collection/immutable/Vector;
       5: areturn

  public final <A, M> M partitionM(scala.collection.immutable.Vector<A>, scala.Function1<A, M>, scalaz.Applicative<M>);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: aload_3
       4: invokestatic  #105                // InterfaceMethod scalaz/std/VectorFunctions.partitionM$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Lscala/Function1;Lscalaz/Applicative;)Ljava/lang/Object;
       7: areturn

  public final <A, M> M spanM(scala.collection.immutable.Vector<A>, scala.Function1<A, M>, scalaz.Monad<M>);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: aload_3
       4: invokestatic  #110                // InterfaceMethod scalaz/std/VectorFunctions.spanM$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Lscala/Function1;Lscalaz/Monad;)Ljava/lang/Object;
       7: areturn

  public final <A, M> M breakM(scala.collection.immutable.Vector<A>, scala.Function1<A, M>, scalaz.Monad<M>);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: aload_3
       4: invokestatic  #115                // InterfaceMethod scalaz/std/VectorFunctions.breakM$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Lscala/Function1;Lscalaz/Monad;)Ljava/lang/Object;
       7: areturn

  public final <A, M> M groupWhenM(scala.collection.immutable.Vector<A>, scala.Function2<A, A, M>, scalaz.Monad<M>);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: aload_3
       4: invokestatic  #123                // InterfaceMethod scalaz/std/VectorFunctions.groupWhenM$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Lscala/Function2;Lscalaz/Monad;)Ljava/lang/Object;
       7: areturn

  public final <A> scala.collection.immutable.Vector<scala.collection.immutable.Vector<A>> groupWhen(scala.collection.immutable.Vector<A>, scala.Function2<A, A, java.lang.Object>);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: invokestatic  #131                // InterfaceMethod scalaz/std/VectorFunctions.groupWhen$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Lscala/Function2;)Lscala/collection/immutable/Vector;
       6: areturn

  public final <A, B, C> scala.Tuple2<C, scala.collection.immutable.Vector<B>> mapAccumLeft(scala.collection.immutable.Vector<A>, C, scala.Function2<C, A, scala.Tuple2<C, B>>);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: aload_3
       4: invokestatic  #139                // InterfaceMethod scalaz/std/VectorFunctions.mapAccumLeft$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Ljava/lang/Object;Lscala/Function2;)Lscala/Tuple2;
       7: areturn

  public final <A, B, C> scala.Tuple2<C, scala.collection.immutable.Vector<B>> mapAccumRight(scala.collection.immutable.Vector<A>, C, scala.Function2<C, A, scala.Tuple2<C, B>>);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: aload_3
       4: invokestatic  #143                // InterfaceMethod scalaz/std/VectorFunctions.mapAccumRight$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Ljava/lang/Object;Lscala/Function2;)Lscala/Tuple2;
       7: areturn

  public final <A> scala.collection.immutable.Vector<scala.collection.immutable.Vector<A>> tailz(scala.collection.immutable.Vector<A>);
    Code:
       0: aload_0
       1: aload_1
       2: invokestatic  #147                // InterfaceMethod scalaz/std/VectorFunctions.tailz$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;)Lscala/collection/immutable/Vector;
       5: areturn

  public final <A> scala.collection.immutable.Vector<scala.collection.immutable.Vector<A>> initz(scala.collection.immutable.Vector<A>);
    Code:
       0: aload_0
       1: aload_1
       2: invokestatic  #151                // InterfaceMethod scalaz/std/VectorFunctions.initz$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;)Lscala/collection/immutable/Vector;
       5: areturn

  public final <A> scala.collection.immutable.Vector<scala.Tuple2<A, A>> allPairs(scala.collection.immutable.Vector<A>);
    Code:
       0: aload_0
       1: aload_1
       2: invokestatic  #156                // InterfaceMethod scalaz/std/VectorFunctions.allPairs$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;)Lscala/collection/immutable/Vector;
       5: areturn

  public final <A> scala.collection.immutable.Vector<scala.Tuple2<A, A>> adjacentPairs(scala.collection.immutable.Vector<A>);
    Code:
       0: aload_0
       1: aload_1
       2: invokestatic  #160                // InterfaceMethod scalaz/std/VectorFunctions.adjacentPairs$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;)Lscala/collection/immutable/Vector;
       5: areturn

  public <A> scalaz.Monoid<scala.collection.immutable.Vector<A>> vectorMonoid();
    Code:
       0: aload_0
       1: invokestatic  #167                // InterfaceMethod scalaz/std/VectorInstances.vectorMonoid$:(Lscalaz/std/VectorInstances;)Lscalaz/Monoid;
       4: areturn

  public <A> scalaz.Show<scala.collection.immutable.Vector<A>> vectorShow(scalaz.Show<A>);
    Code:
       0: aload_0
       1: aload_1
       2: invokestatic  #175                // InterfaceMethod scalaz/std/VectorInstances.vectorShow$:(Lscalaz/std/VectorInstances;Lscalaz/Show;)Lscalaz/Show;
       5: areturn

  public <A> scalaz.Order<scala.collection.immutable.Vector<A>> vectorOrder(scalaz.Order<A>);
    Code:
       0: aload_0
       1: aload_1
       2: invokestatic  #184                // InterfaceMethod scalaz/std/VectorInstances.vectorOrder$:(Lscalaz/std/VectorInstances;Lscalaz/Order;)Lscalaz/Order;
       5: areturn

  public <A> scalaz.Equal<scala.collection.immutable.Vector<A>> vectorEqual(scalaz.Equal<A>);
    Code:
       0: aload_0
       1: aload_1
       2: invokestatic  #194                // InterfaceMethod scalaz/std/VectorInstances0.vectorEqual$:(Lscalaz/std/VectorInstances0;Lscalaz/Equal;)Lscalaz/Equal;
       5: areturn

  public scalaz.Traverse<scala.collection.immutable.Vector> vectorInstance();
    Code:
       0: aload_0
       1: getfield      #199                // Field vectorInstance:Lscalaz/Traverse;
       4: areturn

  public void scalaz$std$VectorInstances$_setter_$vectorInstance_$eq(scalaz.Traverse<scala.collection.immutable.Vector>);
    Code:
       0: aload_0
       1: aload_1
       2: putfield      #199                // Field vectorInstance:Lscalaz/Traverse;
       5: return

  private scalaz.std.vector$();
    Code:
       0: aload_0
       1: invokespecial #204                // Method java/lang/Object."<init>":()V
       4: aload_0
       5: putstatic     #206                // Field MODULE$:Lscalaz/std/vector$;
       8: aload_0
       9: invokestatic  #210                // InterfaceMethod scalaz/std/VectorInstances0.$init$:(Lscalaz/std/VectorInstances0;)V
      12: aload_0
      13: invokestatic  #213                // InterfaceMethod scalaz/std/VectorInstances.$init$:(Lscalaz/std/VectorInstances;)V
      16: aload_0
      17: invokestatic  #216                // InterfaceMethod scalaz/std/VectorFunctions.$init$:(Lscalaz/std/VectorFunctions;)V
      20: return
}
