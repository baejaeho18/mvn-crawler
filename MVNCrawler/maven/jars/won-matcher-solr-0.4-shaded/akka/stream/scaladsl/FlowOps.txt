Compiled from "Flow.scala"
public interface akka.stream.scaladsl.FlowOps<Out, Mat> {
  public abstract <T, Mat2> akka.stream.scaladsl.FlowOps via(akka.stream.Graph<akka.stream.FlowShape<Out, T>, Mat2>);

  public abstract <T> akka.stream.scaladsl.FlowOps recover(scala.PartialFunction<java.lang.Throwable, T>);

  public abstract <T> akka.stream.scaladsl.FlowOps recoverWith(scala.PartialFunction<java.lang.Throwable, akka.stream.Graph<akka.stream.SourceShape<T>, akka.NotUsed>>);

  public abstract <T> akka.stream.scaladsl.FlowOps recoverWithRetries(int, scala.PartialFunction<java.lang.Throwable, akka.stream.Graph<akka.stream.SourceShape<T>, akka.NotUsed>>);

  public abstract <T> akka.stream.scaladsl.FlowOps map(scala.Function1<Out, T>);

  public abstract <T> akka.stream.scaladsl.FlowOps mapConcat(scala.Function1<Out, scala.collection.immutable.Iterable<T>>);

  public abstract <T> akka.stream.scaladsl.FlowOps statefulMapConcat(scala.Function0<scala.Function1<Out, scala.collection.immutable.Iterable<T>>>);

  public abstract <T> akka.stream.scaladsl.FlowOps mapAsync(int, scala.Function1<Out, scala.concurrent.Future<T>>);

  public abstract <T> akka.stream.scaladsl.FlowOps mapAsyncUnordered(int, scala.Function1<Out, scala.concurrent.Future<T>>);

  public abstract akka.stream.scaladsl.FlowOps filter(scala.Function1<Out, java.lang.Object>);

  public abstract akka.stream.scaladsl.FlowOps filterNot(scala.Function1<Out, java.lang.Object>);

  public abstract akka.stream.scaladsl.FlowOps takeWhile(scala.Function1<Out, java.lang.Object>);

  public abstract akka.stream.scaladsl.FlowOps dropWhile(scala.Function1<Out, java.lang.Object>);

  public abstract <T> akka.stream.scaladsl.FlowOps collect(scala.PartialFunction<Out, T>);

  public abstract akka.stream.scaladsl.FlowOps grouped(int);

  public abstract akka.stream.scaladsl.FlowOps limit(long);

  public abstract <T> akka.stream.scaladsl.FlowOps limitWeighted(long, scala.Function1<Out, java.lang.Object>);

  public abstract akka.stream.scaladsl.FlowOps sliding(int, int);

  public abstract int sliding$default$2();

  public abstract <T> akka.stream.scaladsl.FlowOps scan(T, scala.Function2<T, Out, T>);

  public abstract <T> akka.stream.scaladsl.FlowOps fold(T, scala.Function2<T, Out, T>);

  public abstract <T> akka.stream.scaladsl.FlowOps foldAsync(T, scala.Function2<T, Out, scala.concurrent.Future<T>>);

  public abstract <T> akka.stream.scaladsl.FlowOps reduce(scala.Function2<T, T, T>);

  public abstract <T> akka.stream.scaladsl.FlowOps intersperse(T, T, T);

  public abstract <T> akka.stream.scaladsl.FlowOps intersperse(T);

  public abstract akka.stream.scaladsl.FlowOps groupedWithin(int, scala.concurrent.duration.FiniteDuration);

  public abstract akka.stream.scaladsl.FlowOps delay(scala.concurrent.duration.FiniteDuration, akka.stream.DelayOverflowStrategy);

  public abstract akka.stream.DelayOverflowStrategy delay$default$2();

  public abstract akka.stream.scaladsl.FlowOps drop(long);

  public abstract akka.stream.scaladsl.FlowOps dropWithin(scala.concurrent.duration.FiniteDuration);

  public abstract akka.stream.scaladsl.FlowOps take(long);

  public abstract akka.stream.scaladsl.FlowOps takeWithin(scala.concurrent.duration.FiniteDuration);

  public abstract <S> akka.stream.scaladsl.FlowOps conflateWithSeed(scala.Function1<Out, S>, scala.Function2<S, Out, S>);

  public abstract <O2> akka.stream.scaladsl.FlowOps conflate(scala.Function2<O2, O2, O2>);

  public abstract <S> akka.stream.scaladsl.FlowOps batch(long, scala.Function1<Out, S>, scala.Function2<S, Out, S>);

  public abstract <S> akka.stream.scaladsl.FlowOps batchWeighted(long, scala.Function1<Out, java.lang.Object>, scala.Function1<Out, S>, scala.Function2<S, Out, S>);

  public abstract <U> akka.stream.scaladsl.FlowOps expand(scala.Function1<Out, scala.collection.Iterator<U>>);

  public abstract akka.stream.scaladsl.FlowOps buffer(int, akka.stream.OverflowStrategy);

  public abstract <T> akka.stream.scaladsl.FlowOps transform(scala.Function0<akka.stream.stage.Stage<Out, T>>);

  public abstract <U> akka.stream.scaladsl.FlowOps prefixAndTail(int);

  public abstract <K> akka.stream.scaladsl.SubFlow<Out, Mat, akka.stream.scaladsl.FlowOps, java.lang.Object> groupBy(int, scala.Function1<Out, K>);

  public abstract akka.stream.scaladsl.SubFlow<Out, Mat, akka.stream.scaladsl.FlowOps, java.lang.Object> splitWhen(akka.stream.SubstreamCancelStrategy, scala.Function1<Out, java.lang.Object>);

  public abstract akka.stream.scaladsl.SubFlow<Out, Mat, akka.stream.scaladsl.FlowOps, java.lang.Object> splitWhen(scala.Function1<Out, java.lang.Object>);

  public abstract akka.stream.scaladsl.SubFlow<Out, Mat, akka.stream.scaladsl.FlowOps, java.lang.Object> splitAfter(akka.stream.SubstreamCancelStrategy, scala.Function1<Out, java.lang.Object>);

  public abstract akka.stream.scaladsl.SubFlow<Out, Mat, akka.stream.scaladsl.FlowOps, java.lang.Object> splitAfter(scala.Function1<Out, java.lang.Object>);

  public abstract <T, M> akka.stream.scaladsl.FlowOps flatMapConcat(scala.Function1<Out, akka.stream.Graph<akka.stream.SourceShape<T>, M>>);

  public abstract <T, M> akka.stream.scaladsl.FlowOps flatMapMerge(int, scala.Function1<Out, akka.stream.Graph<akka.stream.SourceShape<T>, M>>);

  public abstract akka.stream.scaladsl.FlowOps initialTimeout(scala.concurrent.duration.FiniteDuration);

  public abstract akka.stream.scaladsl.FlowOps completionTimeout(scala.concurrent.duration.FiniteDuration);

  public abstract akka.stream.scaladsl.FlowOps idleTimeout(scala.concurrent.duration.FiniteDuration);

  public abstract akka.stream.scaladsl.FlowOps backpressureTimeout(scala.concurrent.duration.FiniteDuration);

  public abstract <U> akka.stream.scaladsl.FlowOps keepAlive(scala.concurrent.duration.FiniteDuration, scala.Function0<U>);

  public abstract akka.stream.scaladsl.FlowOps throttle(int, scala.concurrent.duration.FiniteDuration, int, akka.stream.ThrottleMode);

  public abstract akka.stream.scaladsl.FlowOps throttle(int, scala.concurrent.duration.FiniteDuration, int, scala.Function1<Out, java.lang.Object>, akka.stream.ThrottleMode);

  public abstract akka.stream.scaladsl.FlowOps detach();

  public abstract akka.stream.scaladsl.FlowOps initialDelay(scala.concurrent.duration.FiniteDuration);

  public abstract akka.stream.scaladsl.FlowOps log(java.lang.String, scala.Function1<Out, java.lang.Object>, akka.event.LoggingAdapter);

  public abstract scala.Function1<Out, java.lang.Object> log$default$2();

  public abstract akka.event.LoggingAdapter log$default$3(java.lang.String, scala.Function1<Out, java.lang.Object>);

  public abstract <U> akka.stream.scaladsl.FlowOps zip(akka.stream.Graph<akka.stream.SourceShape<U>, ?>);

  public abstract <U, M> akka.stream.Graph<akka.stream.FlowShape<Out, scala.Tuple2<Out, U>>, M> zipGraph(akka.stream.Graph<akka.stream.SourceShape<U>, M>);

  public abstract <Out2, Out3> akka.stream.scaladsl.FlowOps zipWith(akka.stream.Graph<akka.stream.SourceShape<Out2>, ?>, scala.Function2<Out, Out2, Out3>);

  public abstract <Out2, Out3, M> akka.stream.Graph<akka.stream.FlowShape<Out, Out3>, M> zipWithGraph(akka.stream.Graph<akka.stream.SourceShape<Out2>, M>, scala.Function2<Out, Out2, Out3>);

  public abstract akka.stream.scaladsl.FlowOps zipWithIndex();

  public abstract <U> akka.stream.scaladsl.FlowOps interleave(akka.stream.Graph<akka.stream.SourceShape<U>, ?>, int);

  public abstract <U, M> akka.stream.Graph<akka.stream.FlowShape<Out, U>, M> interleaveGraph(akka.stream.Graph<akka.stream.SourceShape<U>, M>, int);

  public abstract <U, M> akka.stream.scaladsl.FlowOps merge(akka.stream.Graph<akka.stream.SourceShape<U>, M>, boolean);

  public abstract <U, M> boolean merge$default$2();

  public abstract <U, M> akka.stream.Graph<akka.stream.FlowShape<Out, U>, M> mergeGraph(akka.stream.Graph<akka.stream.SourceShape<U>, M>, boolean);

  public abstract <U, M> akka.stream.scaladsl.FlowOps mergeSorted(akka.stream.Graph<akka.stream.SourceShape<U>, M>, scala.math.Ordering<U>);

  public abstract <U, M> akka.stream.Graph<akka.stream.FlowShape<Out, U>, M> mergeSortedGraph(akka.stream.Graph<akka.stream.SourceShape<U>, M>, scala.math.Ordering<U>);

  public abstract <U, Mat2> akka.stream.scaladsl.FlowOps concat(akka.stream.Graph<akka.stream.SourceShape<U>, Mat2>);

  public abstract <U, Mat2> akka.stream.Graph<akka.stream.FlowShape<Out, U>, Mat2> concatGraph(akka.stream.Graph<akka.stream.SourceShape<U>, Mat2>);

  public abstract <U, Mat2> akka.stream.scaladsl.FlowOps prepend(akka.stream.Graph<akka.stream.SourceShape<U>, Mat2>);

  public abstract <U, Mat2> akka.stream.Graph<akka.stream.FlowShape<Out, U>, Mat2> prependGraph(akka.stream.Graph<akka.stream.SourceShape<U>, Mat2>);

  public abstract <U, Mat2> akka.stream.scaladsl.FlowOps orElse(akka.stream.Graph<akka.stream.SourceShape<U>, Mat2>);

  public abstract <U, Mat2> akka.stream.Graph<akka.stream.FlowShape<Out, U>, Mat2> orElseGraph(akka.stream.Graph<akka.stream.SourceShape<U>, Mat2>);

  public abstract <U, M> akka.stream.scaladsl.FlowOps $plus$plus(akka.stream.Graph<akka.stream.SourceShape<U>, M>);

  public abstract <Mat2> java.lang.Object to(akka.stream.Graph<akka.stream.SinkShape<Out>, Mat2>);

  public abstract akka.stream.scaladsl.FlowOps alsoTo(akka.stream.Graph<akka.stream.SinkShape<Out>, ?>);

  public abstract <M> akka.stream.Graph<akka.stream.FlowShape<Out, Out>, M> alsoToGraph(akka.stream.Graph<akka.stream.SinkShape<Out>, M>);

  public abstract akka.stream.scaladsl.FlowOps withAttributes(akka.stream.Attributes);

  public abstract akka.stream.scaladsl.FlowOps addAttributes(akka.stream.Attributes);

  public abstract akka.stream.scaladsl.FlowOps named(java.lang.String);

  public abstract akka.stream.scaladsl.FlowOps async();

  public abstract <T> akka.stream.scaladsl.FlowOps andThen(akka.stream.impl.Stages$SymbolicStage<Out, T>);
}
