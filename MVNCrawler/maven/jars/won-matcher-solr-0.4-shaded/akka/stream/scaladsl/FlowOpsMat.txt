Compiled from "Flow.scala"
public interface akka.stream.scaladsl.FlowOpsMat<Out, Mat> extends akka.stream.scaladsl.FlowOps<Out, Mat> {
  public abstract <T, Mat2, Mat3> akka.stream.scaladsl.FlowOpsMat viaMat(akka.stream.Graph<akka.stream.FlowShape<Out, T>, Mat2>, scala.Function2<Mat, Mat2, Mat3>);

  public abstract <Mat2, Mat3> akka.stream.Graph toMat(akka.stream.Graph<akka.stream.SinkShape<Out>, Mat2>, scala.Function2<Mat, Mat2, Mat3>);

  public abstract <U, Mat2, Mat3> akka.stream.scaladsl.FlowOpsMat zipMat(akka.stream.Graph<akka.stream.SourceShape<U>, Mat2>, scala.Function2<Mat, Mat2, Mat3>);

  public abstract <Out2, Out3, Mat2, Mat3> akka.stream.scaladsl.FlowOpsMat zipWithMat(akka.stream.Graph<akka.stream.SourceShape<Out2>, Mat2>, scala.Function2<Out, Out2, Out3>, scala.Function2<Mat, Mat2, Mat3>);

  public abstract <U, Mat2, Mat3> akka.stream.scaladsl.FlowOpsMat mergeMat(akka.stream.Graph<akka.stream.SourceShape<U>, Mat2>, boolean, scala.Function2<Mat, Mat2, Mat3>);

  public abstract <U, Mat2, Mat3> boolean mergeMat$default$2();

  public abstract <U, Mat2, Mat3> akka.stream.scaladsl.FlowOpsMat interleaveMat(akka.stream.Graph<akka.stream.SourceShape<U>, Mat2>, int, scala.Function2<Mat, Mat2, Mat3>);

  public abstract <U, Mat2, Mat3> akka.stream.scaladsl.FlowOpsMat mergeSortedMat(akka.stream.Graph<akka.stream.SourceShape<U>, Mat2>, scala.Function2<Mat, Mat2, Mat3>, scala.math.Ordering<U>);

  public abstract <U, Mat2, Mat3> akka.stream.scaladsl.FlowOpsMat concatMat(akka.stream.Graph<akka.stream.SourceShape<U>, Mat2>, scala.Function2<Mat, Mat2, Mat3>);

  public abstract <U, Mat2, Mat3> akka.stream.scaladsl.FlowOpsMat prependMat(akka.stream.Graph<akka.stream.SourceShape<U>, Mat2>, scala.Function2<Mat, Mat2, Mat3>);

  public abstract <U, Mat2, Mat3> akka.stream.scaladsl.FlowOpsMat orElseMat(akka.stream.Graph<akka.stream.SourceShape<U>, Mat2>, scala.Function2<Mat, Mat2, Mat3>);

  public abstract <Mat2, Mat3> akka.stream.scaladsl.FlowOpsMat alsoToMat(akka.stream.Graph<akka.stream.SinkShape<Out>, Mat2>, scala.Function2<Mat, Mat2, Mat3>);

  public abstract <Mat2> akka.stream.scaladsl.FlowOpsMat watchTermination(scala.Function2<Mat, scala.concurrent.Future<akka.Done>, Mat2>);

  public abstract <Mat2> akka.stream.scaladsl.FlowOpsMat mapMaterializedValue(scala.Function1<Mat, Mat2>);

  public abstract <Mat2> akka.stream.scaladsl.FlowOpsMat monitor(scala.Function2<Mat, akka.stream.FlowMonitor<Out>, Mat2>);

  public abstract <T, M> akka.stream.scaladsl.FlowOpsMat transformMaterializing(scala.Function0<scala.Tuple2<akka.stream.stage.Stage<Out, T>, M>>);
}
