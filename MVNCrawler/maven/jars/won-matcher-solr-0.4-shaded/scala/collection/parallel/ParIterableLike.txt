Compiled from "ParIterableLike.scala"
public interface scala.collection.parallel.ParIterableLike<T, Repr extends scala.collection.parallel.ParIterable<T>, Sequential extends scala.collection.Iterable<T> & scala.collection.IterableLike<T, Sequential>> extends scala.collection.GenIterableLike<T, Repr>, scala.collection.CustomParallelizable<T, Repr>, scala.collection.Parallel, scala.collection.generic.HasNewCombiner<T, Repr> {
  public abstract scala.collection.parallel.TaskSupport scala$collection$parallel$ParIterableLike$$_tasksupport();

  public abstract void scala$collection$parallel$ParIterableLike$$_tasksupport_$eq(scala.collection.parallel.TaskSupport);

  public abstract void initTaskSupport();

  public abstract scala.collection.parallel.TaskSupport tasksupport();

  public abstract void tasksupport_$eq(scala.collection.parallel.TaskSupport);

  public abstract Sequential seq();

  public abstract Repr repr();

  public abstract boolean isTraversableAgain();

  public abstract boolean hasDefiniteSize();

  public abstract boolean isEmpty();

  public abstract boolean nonEmpty();

  public abstract T head();

  public abstract scala.Option<T> headOption();

  public abstract Repr tail();

  public abstract T last();

  public abstract scala.Option<T> lastOption();

  public abstract Repr init();

  public abstract scala.collection.parallel.IterableSplitter<T> splitter();

  public abstract scala.collection.parallel.Splitter<T> iterator();

  public abstract Repr par();

  public abstract boolean isStrictSplitterCollection();

  public abstract <S, That> scala.collection.parallel.Combiner<S, That> reuse(scala.Option<scala.collection.parallel.Combiner<S, That>>, scala.collection.parallel.Combiner<S, That>);

  public abstract <R, Tp> java.lang.Object task2ops(scala.collection.parallel.ParIterableLike<T, Repr, Sequential>.StrictSplitterCheckTask<R, Tp>);

  public abstract <R> java.lang.Object wrap(scala.Function0<R>);

  public abstract <PI extends scala.collection.generic.DelegatedSignalling> java.lang.Object delegatedSignalling2ops(PI);

  public abstract <Elem, To> java.lang.Object builder2ops(scala.collection.mutable.Builder<Elem, To>);

  public abstract <S, That> java.lang.Object bf2seq(scala.collection.generic.CanBuildFrom<Repr, S, That>);

  public abstract <S, That extends scala.collection.Parallel> Repr sequentially(scala.Function1<Sequential, scala.collection.Parallelizable<S, That>>);

  public abstract java.lang.String mkString(java.lang.String, java.lang.String, java.lang.String);

  public abstract java.lang.String mkString(java.lang.String);

  public abstract java.lang.String mkString();

  public abstract java.lang.String toString();

  public abstract boolean canEqual(java.lang.Object);

  public abstract <U> U reduce(scala.Function2<U, U, U>);

  public abstract <U> scala.Option<U> reduceOption(scala.Function2<U, U, U>);

  public abstract <U> U fold(U, scala.Function2<U, U, U>);

  public abstract <S> S aggregate(scala.Function0<S>, scala.Function2<S, T, S>, scala.Function2<S, S, S>);

  public abstract <S> S foldLeft(S, scala.Function2<S, T, S>);

  public abstract <S> S foldRight(S, scala.Function2<T, S, S>);

  public abstract <U> U reduceLeft(scala.Function2<U, T, U>);

  public abstract <U> U reduceRight(scala.Function2<T, U, U>);

  public abstract <U> scala.Option<U> reduceLeftOption(scala.Function2<U, T, U>);

  public abstract <U> scala.Option<U> reduceRightOption(scala.Function2<T, U, U>);

  public abstract <U> void foreach(scala.Function1<T, U>);

  public abstract int count(scala.Function1<T, java.lang.Object>);

  public abstract <U> U sum(scala.math.Numeric<U>);

  public abstract <U> U product(scala.math.Numeric<U>);

  public abstract <U> T min(scala.math.Ordering<U>);

  public abstract <U> T max(scala.math.Ordering<U>);

  public abstract <S> T maxBy(scala.Function1<T, S>, scala.math.Ordering<S>);

  public abstract <S> T minBy(scala.Function1<T, S>, scala.math.Ordering<S>);

  public abstract <S, That> That map(scala.Function1<T, S>, scala.collection.generic.CanBuildFrom<Repr, S, That>);

  public abstract <S, That> That collect(scala.PartialFunction<T, S>, scala.collection.generic.CanBuildFrom<Repr, S, That>);

  public abstract <S, That> That flatMap(scala.Function1<T, scala.collection.GenTraversableOnce<S>>, scala.collection.generic.CanBuildFrom<Repr, S, That>);

  public abstract boolean forall(scala.Function1<T, java.lang.Object>);

  public abstract boolean exists(scala.Function1<T, java.lang.Object>);

  public abstract scala.Option<T> find(scala.Function1<T, java.lang.Object>);

  public abstract java.lang.Object combinerFactory();

  public abstract <S, That> java.lang.Object combinerFactory(scala.Function0<scala.collection.parallel.Combiner<S, That>>);

  public abstract Repr withFilter(scala.Function1<T, java.lang.Object>);

  public abstract Repr filter(scala.Function1<T, java.lang.Object>);

  public abstract Repr filterNot(scala.Function1<T, java.lang.Object>);

  public abstract <U, That> That $plus$plus(scala.collection.GenTraversableOnce<U>, scala.collection.generic.CanBuildFrom<Repr, U, That>);

  public abstract scala.Tuple2<Repr, Repr> partition(scala.Function1<T, java.lang.Object>);

  public abstract <K> scala.collection.parallel.immutable.ParMap<K, Repr> groupBy(scala.Function1<T, K>);

  public abstract Repr take(int);

  public abstract Repr drop(int);

  public abstract Repr slice(int, int);

  public abstract scala.Tuple2<Repr, Repr> splitAt(int);

  public abstract <U, That> That scan(U, scala.Function2<U, U, U>, scala.collection.generic.CanBuildFrom<Repr, U, That>);

  public abstract <S, That> That scanLeft(S, scala.Function2<S, T, S>, scala.collection.generic.CanBuildFrom<Repr, S, That>);

  public abstract <S, That> That scanRight(S, scala.Function2<T, S, S>, scala.collection.generic.CanBuildFrom<Repr, S, That>);

  public abstract Repr takeWhile(scala.Function1<T, java.lang.Object>);

  public abstract scala.Tuple2<Repr, Repr> span(scala.Function1<T, java.lang.Object>);

  public abstract Repr dropWhile(scala.Function1<T, java.lang.Object>);

  public abstract <U> void copyToArray(java.lang.Object);

  public abstract <U> void copyToArray(java.lang.Object, int);

  public abstract <U> void copyToArray(java.lang.Object, int, int);

  public abstract <U> boolean sameElements(scala.collection.GenIterable<U>);

  public abstract <U, S, That> That zip(scala.collection.GenIterable<S>, scala.collection.generic.CanBuildFrom<Repr, scala.Tuple2<U, S>, That>);

  public abstract <U, That> That zipWithIndex(scala.collection.generic.CanBuildFrom<Repr, scala.Tuple2<U, java.lang.Object>, That>);

  public abstract <S, U, That> That zipAll(scala.collection.GenIterable<S>, U, S, scala.collection.generic.CanBuildFrom<Repr, scala.Tuple2<U, S>, That>);

  public abstract <U, That> That toParCollection(scala.Function0<scala.collection.parallel.Combiner<U, That>>);

  public abstract <K, V, That> That toParMap(scala.Function0<scala.collection.parallel.Combiner<scala.Tuple2<K, V>, That>>, scala.Predef$$less$colon$less<T, scala.Tuple2<K, V>>);

  public abstract java.lang.Object view();

  public abstract <U> java.lang.Object toArray(scala.reflect.ClassTag<U>);

  public abstract scala.collection.immutable.List<T> toList();

  public abstract scala.collection.immutable.IndexedSeq<T> toIndexedSeq();

  public abstract scala.collection.immutable.Stream<T> toStream();

  public abstract scala.collection.Iterator<T> toIterator();

  public abstract <U> scala.collection.mutable.Buffer<U> toBuffer();

  public abstract scala.collection.GenTraversable<T> toTraversable();

  public abstract scala.collection.parallel.ParIterable<T> toIterable();

  public abstract scala.collection.parallel.ParSeq<T> toSeq();

  public abstract <U> scala.collection.parallel.immutable.ParSet<U> toSet();

  public abstract <K, V> scala.collection.parallel.immutable.ParMap<K, V> toMap(scala.Predef$$less$colon$less<T, scala.Tuple2<K, V>>);

  public abstract scala.collection.immutable.Vector<T> toVector();

  public abstract <Col> Col to(scala.collection.generic.CanBuildFrom<scala.runtime.Nothing$, T, Col>);

  public abstract int scanBlockSize();

  public abstract scala.collection.parallel.ParIterableLike<T, Repr, Sequential>.ScanNode$ ScanNode();

  public abstract scala.collection.parallel.ParIterableLike<T, Repr, Sequential>.ScanLeaf$ ScanLeaf();

  public abstract <S> S $div$colon(S, scala.Function2<S, T, S>);

  public abstract <S> S $colon$bslash(S, scala.Function2<T, S, S>);

  public abstract java.lang.String debugInformation();

  public abstract scala.collection.Seq<java.lang.String> brokenInvariants();

  public abstract scala.collection.mutable.ArrayBuffer<java.lang.String> debugBuffer();

  public abstract void debugclear();

  public abstract scala.collection.mutable.ArrayBuffer<java.lang.String> debuglog(java.lang.String);

  public abstract void printDebugBuffer();
}
