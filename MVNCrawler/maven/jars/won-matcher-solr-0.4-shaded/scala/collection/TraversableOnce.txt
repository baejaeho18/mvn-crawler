Compiled from "TraversableOnce.scala"
public interface scala.collection.TraversableOnce<A> extends scala.collection.GenTraversableOnce<A> {
  public abstract <U> void foreach(scala.Function1<A, U>);

  public abstract boolean isEmpty();

  public abstract boolean hasDefiniteSize();

  public abstract scala.collection.TraversableOnce<A> seq();

  public abstract boolean forall(scala.Function1<A, java.lang.Object>);

  public abstract boolean exists(scala.Function1<A, java.lang.Object>);

  public abstract scala.Option<A> find(scala.Function1<A, java.lang.Object>);

  public abstract <B> void copyToArray(java.lang.Object, int, int);

  public abstract scala.collection.immutable.List<A> reversed();

  public abstract int size();

  public abstract boolean nonEmpty();

  public abstract int count(scala.Function1<A, java.lang.Object>);

  public abstract <B> scala.Option<B> collectFirst(scala.PartialFunction<A, B>);

  public abstract <B> B $div$colon(B, scala.Function2<B, A, B>);

  public abstract <B> B $colon$bslash(B, scala.Function2<A, B, B>);

  public abstract <B> B foldLeft(B, scala.Function2<B, A, B>);

  public abstract <B> B foldRight(B, scala.Function2<A, B, B>);

  public abstract <B> B reduceLeft(scala.Function2<B, A, B>);

  public abstract <B> B reduceRight(scala.Function2<A, B, B>);

  public abstract <B> scala.Option<B> reduceLeftOption(scala.Function2<B, A, B>);

  public abstract <B> scala.Option<B> reduceRightOption(scala.Function2<A, B, B>);

  public abstract <A1> A1 reduce(scala.Function2<A1, A1, A1>);

  public abstract <A1> scala.Option<A1> reduceOption(scala.Function2<A1, A1, A1>);

  public abstract <A1> A1 fold(A1, scala.Function2<A1, A1, A1>);

  public abstract <B> B aggregate(scala.Function0<B>, scala.Function2<B, A, B>, scala.Function2<B, B, B>);

  public abstract <B> B sum(scala.math.Numeric<B>);

  public abstract <B> B product(scala.math.Numeric<B>);

  public abstract <B> A min(scala.math.Ordering<B>);

  public abstract <B> A max(scala.math.Ordering<B>);

  public abstract <B> A maxBy(scala.Function1<A, B>, scala.math.Ordering<B>);

  public abstract <B> A minBy(scala.Function1<A, B>, scala.math.Ordering<B>);

  public abstract <B> void copyToBuffer(scala.collection.mutable.Buffer<B>);

  public abstract <B> void copyToArray(java.lang.Object, int);

  public abstract <B> void copyToArray(java.lang.Object);

  public abstract <B> java.lang.Object toArray(scala.reflect.ClassTag<B>);

  public abstract scala.collection.Traversable<A> toTraversable();

  public abstract scala.collection.immutable.List<A> toList();

  public abstract scala.collection.Iterable<A> toIterable();

  public abstract scala.collection.Seq<A> toSeq();

  public abstract scala.collection.immutable.IndexedSeq<A> toIndexedSeq();

  public abstract <B> scala.collection.mutable.Buffer<B> toBuffer();

  public abstract <B> scala.collection.immutable.Set<B> toSet();

  public abstract scala.collection.immutable.Vector<A> toVector();

  public abstract <Col> Col to(scala.collection.generic.CanBuildFrom<scala.runtime.Nothing$, A, Col>);

  public abstract <T, U> scala.collection.immutable.Map<T, U> toMap(scala.Predef$$less$colon$less<A, scala.Tuple2<T, U>>);

  public abstract java.lang.String mkString(java.lang.String, java.lang.String, java.lang.String);

  public abstract java.lang.String mkString(java.lang.String);

  public abstract java.lang.String mkString();

  public abstract scala.collection.mutable.StringBuilder addString(scala.collection.mutable.StringBuilder, java.lang.String, java.lang.String, java.lang.String);

  public abstract scala.collection.mutable.StringBuilder addString(scala.collection.mutable.StringBuilder, java.lang.String);

  public abstract scala.collection.mutable.StringBuilder addString(scala.collection.mutable.StringBuilder);
}
