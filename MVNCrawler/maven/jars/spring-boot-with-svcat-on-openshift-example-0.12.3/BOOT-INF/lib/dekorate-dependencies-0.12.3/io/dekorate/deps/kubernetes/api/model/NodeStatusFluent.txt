Compiled from "NodeStatusFluent.java"
public interface io.dekorate.deps.kubernetes.api.model.NodeStatusFluent<A extends io.dekorate.deps.kubernetes.api.model.NodeStatusFluent<A>> extends io.dekorate.deps.kubernetes.api.builder.Fluent<A> {
  public abstract A addToAddresses(int, io.dekorate.deps.kubernetes.api.model.NodeAddress);

  public abstract A setToAddresses(int, io.dekorate.deps.kubernetes.api.model.NodeAddress);

  public abstract A addToAddresses(io.dekorate.deps.kubernetes.api.model.NodeAddress...);

  public abstract A addAllToAddresses(java.util.Collection<io.dekorate.deps.kubernetes.api.model.NodeAddress>);

  public abstract A removeFromAddresses(io.dekorate.deps.kubernetes.api.model.NodeAddress...);

  public abstract A removeAllFromAddresses(java.util.Collection<io.dekorate.deps.kubernetes.api.model.NodeAddress>);

  public abstract A removeMatchingFromAddresses(io.dekorate.deps.kubernetes.api.builder.Predicate<io.dekorate.deps.kubernetes.api.model.NodeAddressBuilder>);

  public abstract java.util.List<io.dekorate.deps.kubernetes.api.model.NodeAddress> getAddresses();

  public abstract java.util.List<io.dekorate.deps.kubernetes.api.model.NodeAddress> buildAddresses();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeAddress buildAddress(int);

  public abstract io.dekorate.deps.kubernetes.api.model.NodeAddress buildFirstAddress();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeAddress buildLastAddress();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeAddress buildMatchingAddress(io.dekorate.deps.kubernetes.api.builder.Predicate<io.dekorate.deps.kubernetes.api.model.NodeAddressBuilder>);

  public abstract java.lang.Boolean hasMatchingAddress(io.dekorate.deps.kubernetes.api.builder.Predicate<io.dekorate.deps.kubernetes.api.model.NodeAddressBuilder>);

  public abstract A withAddresses(java.util.List<io.dekorate.deps.kubernetes.api.model.NodeAddress>);

  public abstract A withAddresses(io.dekorate.deps.kubernetes.api.model.NodeAddress...);

  public abstract java.lang.Boolean hasAddresses();

  public abstract A addNewAddress(java.lang.String, java.lang.String);

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$AddressesNested<A> addNewAddress();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$AddressesNested<A> addNewAddressLike(io.dekorate.deps.kubernetes.api.model.NodeAddress);

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$AddressesNested<A> setNewAddressLike(int, io.dekorate.deps.kubernetes.api.model.NodeAddress);

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$AddressesNested<A> editAddress(int);

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$AddressesNested<A> editFirstAddress();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$AddressesNested<A> editLastAddress();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$AddressesNested<A> editMatchingAddress(io.dekorate.deps.kubernetes.api.builder.Predicate<io.dekorate.deps.kubernetes.api.model.NodeAddressBuilder>);

  public abstract A addToAllocatable(java.lang.String, io.dekorate.deps.kubernetes.api.model.Quantity);

  public abstract A addToAllocatable(java.util.Map<java.lang.String, io.dekorate.deps.kubernetes.api.model.Quantity>);

  public abstract A removeFromAllocatable(java.lang.String);

  public abstract A removeFromAllocatable(java.util.Map<java.lang.String, io.dekorate.deps.kubernetes.api.model.Quantity>);

  public abstract java.util.Map<java.lang.String, io.dekorate.deps.kubernetes.api.model.Quantity> getAllocatable();

  public abstract A withAllocatable(java.util.Map<java.lang.String, io.dekorate.deps.kubernetes.api.model.Quantity>);

  public abstract java.lang.Boolean hasAllocatable();

  public abstract A addToCapacity(java.lang.String, io.dekorate.deps.kubernetes.api.model.Quantity);

  public abstract A addToCapacity(java.util.Map<java.lang.String, io.dekorate.deps.kubernetes.api.model.Quantity>);

  public abstract A removeFromCapacity(java.lang.String);

  public abstract A removeFromCapacity(java.util.Map<java.lang.String, io.dekorate.deps.kubernetes.api.model.Quantity>);

  public abstract java.util.Map<java.lang.String, io.dekorate.deps.kubernetes.api.model.Quantity> getCapacity();

  public abstract A withCapacity(java.util.Map<java.lang.String, io.dekorate.deps.kubernetes.api.model.Quantity>);

  public abstract java.lang.Boolean hasCapacity();

  public abstract A addToConditions(int, io.dekorate.deps.kubernetes.api.model.NodeCondition);

  public abstract A setToConditions(int, io.dekorate.deps.kubernetes.api.model.NodeCondition);

  public abstract A addToConditions(io.dekorate.deps.kubernetes.api.model.NodeCondition...);

  public abstract A addAllToConditions(java.util.Collection<io.dekorate.deps.kubernetes.api.model.NodeCondition>);

  public abstract A removeFromConditions(io.dekorate.deps.kubernetes.api.model.NodeCondition...);

  public abstract A removeAllFromConditions(java.util.Collection<io.dekorate.deps.kubernetes.api.model.NodeCondition>);

  public abstract A removeMatchingFromConditions(io.dekorate.deps.kubernetes.api.builder.Predicate<io.dekorate.deps.kubernetes.api.model.NodeConditionBuilder>);

  public abstract java.util.List<io.dekorate.deps.kubernetes.api.model.NodeCondition> getConditions();

  public abstract java.util.List<io.dekorate.deps.kubernetes.api.model.NodeCondition> buildConditions();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeCondition buildCondition(int);

  public abstract io.dekorate.deps.kubernetes.api.model.NodeCondition buildFirstCondition();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeCondition buildLastCondition();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeCondition buildMatchingCondition(io.dekorate.deps.kubernetes.api.builder.Predicate<io.dekorate.deps.kubernetes.api.model.NodeConditionBuilder>);

  public abstract java.lang.Boolean hasMatchingCondition(io.dekorate.deps.kubernetes.api.builder.Predicate<io.dekorate.deps.kubernetes.api.model.NodeConditionBuilder>);

  public abstract A withConditions(java.util.List<io.dekorate.deps.kubernetes.api.model.NodeCondition>);

  public abstract A withConditions(io.dekorate.deps.kubernetes.api.model.NodeCondition...);

  public abstract java.lang.Boolean hasConditions();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$ConditionsNested<A> addNewCondition();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$ConditionsNested<A> addNewConditionLike(io.dekorate.deps.kubernetes.api.model.NodeCondition);

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$ConditionsNested<A> setNewConditionLike(int, io.dekorate.deps.kubernetes.api.model.NodeCondition);

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$ConditionsNested<A> editCondition(int);

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$ConditionsNested<A> editFirstCondition();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$ConditionsNested<A> editLastCondition();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$ConditionsNested<A> editMatchingCondition(io.dekorate.deps.kubernetes.api.builder.Predicate<io.dekorate.deps.kubernetes.api.model.NodeConditionBuilder>);

  public abstract io.dekorate.deps.kubernetes.api.model.NodeConfigStatus getConfig();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeConfigStatus buildConfig();

  public abstract A withConfig(io.dekorate.deps.kubernetes.api.model.NodeConfigStatus);

  public abstract java.lang.Boolean hasConfig();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$ConfigNested<A> withNewConfig();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$ConfigNested<A> withNewConfigLike(io.dekorate.deps.kubernetes.api.model.NodeConfigStatus);

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$ConfigNested<A> editConfig();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$ConfigNested<A> editOrNewConfig();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$ConfigNested<A> editOrNewConfigLike(io.dekorate.deps.kubernetes.api.model.NodeConfigStatus);

  public abstract io.dekorate.deps.kubernetes.api.model.NodeDaemonEndpoints getDaemonEndpoints();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeDaemonEndpoints buildDaemonEndpoints();

  public abstract A withDaemonEndpoints(io.dekorate.deps.kubernetes.api.model.NodeDaemonEndpoints);

  public abstract java.lang.Boolean hasDaemonEndpoints();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$DaemonEndpointsNested<A> withNewDaemonEndpoints();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$DaemonEndpointsNested<A> withNewDaemonEndpointsLike(io.dekorate.deps.kubernetes.api.model.NodeDaemonEndpoints);

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$DaemonEndpointsNested<A> editDaemonEndpoints();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$DaemonEndpointsNested<A> editOrNewDaemonEndpoints();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$DaemonEndpointsNested<A> editOrNewDaemonEndpointsLike(io.dekorate.deps.kubernetes.api.model.NodeDaemonEndpoints);

  public abstract A addToImages(int, io.dekorate.deps.kubernetes.api.model.ContainerImage);

  public abstract A setToImages(int, io.dekorate.deps.kubernetes.api.model.ContainerImage);

  public abstract A addToImages(io.dekorate.deps.kubernetes.api.model.ContainerImage...);

  public abstract A addAllToImages(java.util.Collection<io.dekorate.deps.kubernetes.api.model.ContainerImage>);

  public abstract A removeFromImages(io.dekorate.deps.kubernetes.api.model.ContainerImage...);

  public abstract A removeAllFromImages(java.util.Collection<io.dekorate.deps.kubernetes.api.model.ContainerImage>);

  public abstract A removeMatchingFromImages(io.dekorate.deps.kubernetes.api.builder.Predicate<io.dekorate.deps.kubernetes.api.model.ContainerImageBuilder>);

  public abstract java.util.List<io.dekorate.deps.kubernetes.api.model.ContainerImage> getImages();

  public abstract java.util.List<io.dekorate.deps.kubernetes.api.model.ContainerImage> buildImages();

  public abstract io.dekorate.deps.kubernetes.api.model.ContainerImage buildImage(int);

  public abstract io.dekorate.deps.kubernetes.api.model.ContainerImage buildFirstImage();

  public abstract io.dekorate.deps.kubernetes.api.model.ContainerImage buildLastImage();

  public abstract io.dekorate.deps.kubernetes.api.model.ContainerImage buildMatchingImage(io.dekorate.deps.kubernetes.api.builder.Predicate<io.dekorate.deps.kubernetes.api.model.ContainerImageBuilder>);

  public abstract java.lang.Boolean hasMatchingImage(io.dekorate.deps.kubernetes.api.builder.Predicate<io.dekorate.deps.kubernetes.api.model.ContainerImageBuilder>);

  public abstract A withImages(java.util.List<io.dekorate.deps.kubernetes.api.model.ContainerImage>);

  public abstract A withImages(io.dekorate.deps.kubernetes.api.model.ContainerImage...);

  public abstract java.lang.Boolean hasImages();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$ImagesNested<A> addNewImage();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$ImagesNested<A> addNewImageLike(io.dekorate.deps.kubernetes.api.model.ContainerImage);

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$ImagesNested<A> setNewImageLike(int, io.dekorate.deps.kubernetes.api.model.ContainerImage);

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$ImagesNested<A> editImage(int);

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$ImagesNested<A> editFirstImage();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$ImagesNested<A> editLastImage();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$ImagesNested<A> editMatchingImage(io.dekorate.deps.kubernetes.api.builder.Predicate<io.dekorate.deps.kubernetes.api.model.ContainerImageBuilder>);

  public abstract io.dekorate.deps.kubernetes.api.model.NodeSystemInfo getNodeInfo();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeSystemInfo buildNodeInfo();

  public abstract A withNodeInfo(io.dekorate.deps.kubernetes.api.model.NodeSystemInfo);

  public abstract java.lang.Boolean hasNodeInfo();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$NodeInfoNested<A> withNewNodeInfo();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$NodeInfoNested<A> withNewNodeInfoLike(io.dekorate.deps.kubernetes.api.model.NodeSystemInfo);

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$NodeInfoNested<A> editNodeInfo();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$NodeInfoNested<A> editOrNewNodeInfo();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$NodeInfoNested<A> editOrNewNodeInfoLike(io.dekorate.deps.kubernetes.api.model.NodeSystemInfo);

  public abstract java.lang.String getPhase();

  public abstract A withPhase(java.lang.String);

  public abstract java.lang.Boolean hasPhase();

  public abstract A withNewPhase(java.lang.String);

  public abstract A withNewPhase(java.lang.StringBuilder);

  public abstract A withNewPhase(java.lang.StringBuffer);

  public abstract A addToVolumesAttached(int, io.dekorate.deps.kubernetes.api.model.AttachedVolume);

  public abstract A setToVolumesAttached(int, io.dekorate.deps.kubernetes.api.model.AttachedVolume);

  public abstract A addToVolumesAttached(io.dekorate.deps.kubernetes.api.model.AttachedVolume...);

  public abstract A addAllToVolumesAttached(java.util.Collection<io.dekorate.deps.kubernetes.api.model.AttachedVolume>);

  public abstract A removeFromVolumesAttached(io.dekorate.deps.kubernetes.api.model.AttachedVolume...);

  public abstract A removeAllFromVolumesAttached(java.util.Collection<io.dekorate.deps.kubernetes.api.model.AttachedVolume>);

  public abstract A removeMatchingFromVolumesAttached(io.dekorate.deps.kubernetes.api.builder.Predicate<io.dekorate.deps.kubernetes.api.model.AttachedVolumeBuilder>);

  public abstract java.util.List<io.dekorate.deps.kubernetes.api.model.AttachedVolume> getVolumesAttached();

  public abstract java.util.List<io.dekorate.deps.kubernetes.api.model.AttachedVolume> buildVolumesAttached();

  public abstract io.dekorate.deps.kubernetes.api.model.AttachedVolume buildVolumesAttached(int);

  public abstract io.dekorate.deps.kubernetes.api.model.AttachedVolume buildFirstVolumesAttached();

  public abstract io.dekorate.deps.kubernetes.api.model.AttachedVolume buildLastVolumesAttached();

  public abstract io.dekorate.deps.kubernetes.api.model.AttachedVolume buildMatchingVolumesAttached(io.dekorate.deps.kubernetes.api.builder.Predicate<io.dekorate.deps.kubernetes.api.model.AttachedVolumeBuilder>);

  public abstract java.lang.Boolean hasMatchingVolumesAttached(io.dekorate.deps.kubernetes.api.builder.Predicate<io.dekorate.deps.kubernetes.api.model.AttachedVolumeBuilder>);

  public abstract A withVolumesAttached(java.util.List<io.dekorate.deps.kubernetes.api.model.AttachedVolume>);

  public abstract A withVolumesAttached(io.dekorate.deps.kubernetes.api.model.AttachedVolume...);

  public abstract java.lang.Boolean hasVolumesAttached();

  public abstract A addNewVolumesAttached(java.lang.String, java.lang.String);

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$VolumesAttachedNested<A> addNewVolumesAttached();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$VolumesAttachedNested<A> addNewVolumesAttachedLike(io.dekorate.deps.kubernetes.api.model.AttachedVolume);

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$VolumesAttachedNested<A> setNewVolumesAttachedLike(int, io.dekorate.deps.kubernetes.api.model.AttachedVolume);

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$VolumesAttachedNested<A> editVolumesAttached(int);

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$VolumesAttachedNested<A> editFirstVolumesAttached();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$VolumesAttachedNested<A> editLastVolumesAttached();

  public abstract io.dekorate.deps.kubernetes.api.model.NodeStatusFluent$VolumesAttachedNested<A> editMatchingVolumesAttached(io.dekorate.deps.kubernetes.api.builder.Predicate<io.dekorate.deps.kubernetes.api.model.AttachedVolumeBuilder>);

  public abstract A addToVolumesInUse(int, java.lang.String);

  public abstract A setToVolumesInUse(int, java.lang.String);

  public abstract A addToVolumesInUse(java.lang.String...);

  public abstract A addAllToVolumesInUse(java.util.Collection<java.lang.String>);

  public abstract A removeFromVolumesInUse(java.lang.String...);

  public abstract A removeAllFromVolumesInUse(java.util.Collection<java.lang.String>);

  public abstract java.util.List<java.lang.String> getVolumesInUse();

  public abstract java.lang.String getVolumesInUse(int);

  public abstract java.lang.String getFirstVolumesInUse();

  public abstract java.lang.String getLastVolumesInUse();

  public abstract java.lang.String getMatchingVolumesInUse(io.dekorate.deps.kubernetes.api.builder.Predicate<java.lang.String>);

  public abstract java.lang.Boolean hasMatchingVolumesInUse(io.dekorate.deps.kubernetes.api.builder.Predicate<java.lang.String>);

  public abstract A withVolumesInUse(java.util.List<java.lang.String>);

  public abstract A withVolumesInUse(java.lang.String...);

  public abstract java.lang.Boolean hasVolumesInUse();

  public abstract A addNewVolumesInUse(java.lang.String);

  public abstract A addNewVolumesInUse(java.lang.StringBuilder);

  public abstract A addNewVolumesInUse(java.lang.StringBuffer);
}
