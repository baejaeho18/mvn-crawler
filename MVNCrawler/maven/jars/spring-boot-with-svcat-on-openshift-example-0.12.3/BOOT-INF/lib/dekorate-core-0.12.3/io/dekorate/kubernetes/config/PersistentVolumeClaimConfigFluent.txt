Compiled from "PersistentVolumeClaimConfigFluent.java"
public interface io.dekorate.kubernetes.config.PersistentVolumeClaimConfigFluent<A extends io.dekorate.kubernetes.config.PersistentVolumeClaimConfigFluent<A>> extends io.dekorate.kubernetes.config.ApplicationConfigurationFluent<A> {
  public abstract int getSize();

  public abstract A withSize(int);

  public abstract java.lang.Boolean hasSize();

  public abstract java.lang.String getUnit();

  public abstract A withUnit(java.lang.String);

  public abstract java.lang.Boolean hasUnit();

  public abstract A withNewUnit(java.lang.String);

  public abstract A withNewUnit(java.lang.StringBuilder);

  public abstract A withNewUnit(java.lang.StringBuffer);

  public abstract java.lang.String getStorageClass();

  public abstract A withStorageClass(java.lang.String);

  public abstract java.lang.Boolean hasStorageClass();

  public abstract A withNewStorageClass(java.lang.String);

  public abstract A withNewStorageClass(java.lang.StringBuilder);

  public abstract A withNewStorageClass(java.lang.StringBuffer);

  public abstract io.dekorate.kubernetes.annotation.AccessMode getAccessMode();

  public abstract A withAccessMode(io.dekorate.kubernetes.annotation.AccessMode);

  public abstract java.lang.Boolean hasAccessMode();

  public abstract A withMatchLabels(io.dekorate.kubernetes.config.Label...);

  public abstract io.dekorate.kubernetes.config.Label[] getMatchLabels();

  public abstract io.dekorate.kubernetes.config.Label[] buildMatchLabels();

  public abstract io.dekorate.kubernetes.config.Label buildMatchLabel(int);

  public abstract io.dekorate.kubernetes.config.Label buildFirstMatchLabel();

  public abstract io.dekorate.kubernetes.config.Label buildLastMatchLabel();

  public abstract io.dekorate.kubernetes.config.Label buildMatchingMatchLabel(io.dekorate.deps.kubernetes.api.builder.Predicate<io.dekorate.kubernetes.config.LabelBuilder>);

  public abstract java.lang.Boolean hasMatchingMatchLabel(io.dekorate.deps.kubernetes.api.builder.Predicate<io.dekorate.kubernetes.config.LabelBuilder>);

  public abstract A addToMatchLabels(int, io.dekorate.kubernetes.config.Label);

  public abstract A setToMatchLabels(int, io.dekorate.kubernetes.config.Label);

  public abstract A addToMatchLabels(io.dekorate.kubernetes.config.Label...);

  public abstract A addAllToMatchLabels(java.util.Collection<io.dekorate.kubernetes.config.Label>);

  public abstract A removeFromMatchLabels(io.dekorate.kubernetes.config.Label...);

  public abstract A removeAllFromMatchLabels(java.util.Collection<io.dekorate.kubernetes.config.Label>);

  public abstract A removeMatchingFromMatchLabels(io.dekorate.deps.kubernetes.api.builder.Predicate<io.dekorate.kubernetes.config.LabelBuilder>);

  public abstract java.lang.Boolean hasMatchLabels();

  public abstract A addNewMatchLabel(java.lang.String, java.lang.String);

  public abstract io.dekorate.kubernetes.config.PersistentVolumeClaimConfigFluent$MatchLabelsNested<A> addNewMatchLabel();

  public abstract io.dekorate.kubernetes.config.PersistentVolumeClaimConfigFluent$MatchLabelsNested<A> addNewMatchLabelLike(io.dekorate.kubernetes.config.Label);

  public abstract io.dekorate.kubernetes.config.PersistentVolumeClaimConfigFluent$MatchLabelsNested<A> setNewMatchLabelLike(int, io.dekorate.kubernetes.config.Label);

  public abstract io.dekorate.kubernetes.config.PersistentVolumeClaimConfigFluent$MatchLabelsNested<A> editMatchLabel(int);

  public abstract io.dekorate.kubernetes.config.PersistentVolumeClaimConfigFluent$MatchLabelsNested<A> editFirstMatchLabel();

  public abstract io.dekorate.kubernetes.config.PersistentVolumeClaimConfigFluent$MatchLabelsNested<A> editLastMatchLabel();

  public abstract io.dekorate.kubernetes.config.PersistentVolumeClaimConfigFluent$MatchLabelsNested<A> editMatchingMatchLabel(io.dekorate.deps.kubernetes.api.builder.Predicate<io.dekorate.kubernetes.config.LabelBuilder>);
}
