Compiled from "Vector.scala"
public final class scalaz.std.vector$ implements scalaz.std.VectorInstances,scalaz.std.VectorFunctions {
  public static final scalaz.std.vector$ MODULE$;

  private static scalaz.Traverse<scala.collection.immutable.Vector> vectorInstance;

  public static {};
    Code:
       0: new           #2                  // class scalaz/std/vector$
       3: dup
       4: invokespecial #19                 // Method "<init>":()V
       7: putstatic     #21                 // Field MODULE$:Lscalaz/std/vector$;
      10: getstatic     #21                 // Field MODULE$:Lscalaz/std/vector$;
      13: pop
      14: getstatic     #21                 // Field MODULE$:Lscalaz/std/vector$;
      17: invokestatic  #25                 // InterfaceMethod scalaz/std/VectorInstances.$init$:(Lscalaz/std/VectorInstances;)V
      20: getstatic     #21                 // Field MODULE$:Lscalaz/std/vector$;
      23: pop
      24: return

  public <A> scala.collection.immutable.Vector<A> empty();
    Code:
       0: aload_0
       1: invokestatic  #32                 // InterfaceMethod scalaz/std/VectorFunctions.empty$:(Lscalaz/std/VectorFunctions;)Lscala/collection/immutable/Vector;
       4: areturn

  public final <A> scala.collection.immutable.Vector<A> intersperse(scala.collection.immutable.Vector<A>, A);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: invokestatic  #42                 // InterfaceMethod scalaz/std/VectorFunctions.intersperse$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Ljava/lang/Object;)Lscala/collection/immutable/Vector;
       6: areturn

  public final <A> scalaz.Maybe<scalaz.NonEmptyList<A>> toNel(scala.collection.immutable.Vector<A>);
    Code:
       0: aload_0
       1: aload_1
       2: invokestatic  #51                 // InterfaceMethod scalaz/std/VectorFunctions.toNel$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;)Lscalaz/Maybe;
       5: areturn

  public final <A> scalaz.Maybe<scalaz.Zipper<A>> toZipper(scala.collection.immutable.Vector<A>);
    Code:
       0: aload_0
       1: aload_1
       2: invokestatic  #56                 // InterfaceMethod scalaz/std/VectorFunctions.toZipper$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;)Lscalaz/Maybe;
       5: areturn

  public final <A> scalaz.Maybe<scalaz.Zipper<A>> zipperEnd(scala.collection.immutable.Vector<A>);
    Code:
       0: aload_0
       1: aload_1
       2: invokestatic  #60                 // InterfaceMethod scalaz/std/VectorFunctions.zipperEnd$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;)Lscalaz/Maybe;
       5: areturn

  public final <A, B> B $less$up$greater(scala.collection.immutable.Vector<A>, scala.Function1<scalaz.NonEmptyList<A>, B>, scalaz.Monoid<B>);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: aload_3
       4: invokestatic  #69                 // InterfaceMethod scalaz/std/VectorFunctions.$less$up$greater$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Lscala/Function1;Lscalaz/Monoid;)Ljava/lang/Object;
       7: areturn

  public final <A, M> M takeWhileM(scala.collection.immutable.Vector<A>, scala.Function1<A, M>, scalaz.Monad<M>);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: aload_3
       4: invokestatic  #80                 // InterfaceMethod scalaz/std/VectorFunctions.takeWhileM$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Lscala/Function1;Lscalaz/Monad;)Ljava/lang/Object;
       7: areturn

  public final <A, M> M takeUntilM(scala.collection.immutable.Vector<A>, scala.Function1<A, M>, scalaz.Monad<M>);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: aload_3
       4: invokestatic  #86                 // InterfaceMethod scalaz/std/VectorFunctions.takeUntilM$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Lscala/Function1;Lscalaz/Monad;)Ljava/lang/Object;
       7: areturn

  public final <A, M> M filterM(scala.collection.immutable.Vector<A>, scala.Function1<A, M>, scalaz.Applicative<M>);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: aload_3
       4: invokestatic  #94                 // InterfaceMethod scalaz/std/VectorFunctions.filterM$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Lscala/Function1;Lscalaz/Applicative;)Ljava/lang/Object;
       7: areturn

  public final <A, M> M findM(scala.collection.immutable.Vector<A>, scala.Function1<A, M>, scalaz.Monad<M>);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: aload_3
       4: invokestatic  #100                // InterfaceMethod scalaz/std/VectorFunctions.findM$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Lscala/Function1;Lscalaz/Monad;)Ljava/lang/Object;
       7: areturn

  public final <A> scala.collection.immutable.Vector<scala.collection.immutable.Vector<A>> powerset(scala.collection.immutable.Vector<A>);
    Code:
       0: aload_0
       1: aload_1
       2: invokestatic  #107                // InterfaceMethod scalaz/std/VectorFunctions.powerset$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;)Lscala/collection/immutable/Vector;
       5: areturn

  public final <A, M> M partitionM(scala.collection.immutable.Vector<A>, scala.Function1<A, M>, scalaz.Applicative<M>);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: aload_3
       4: invokestatic  #111                // InterfaceMethod scalaz/std/VectorFunctions.partitionM$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Lscala/Function1;Lscalaz/Applicative;)Ljava/lang/Object;
       7: areturn

  public final <A, M> M spanM(scala.collection.immutable.Vector<A>, scala.Function1<A, M>, scalaz.Monad<M>);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: aload_3
       4: invokestatic  #116                // InterfaceMethod scalaz/std/VectorFunctions.spanM$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Lscala/Function1;Lscalaz/Monad;)Ljava/lang/Object;
       7: areturn

  public final <A, M> M breakM(scala.collection.immutable.Vector<A>, scala.Function1<A, M>, scalaz.Monad<M>);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: aload_3
       4: invokestatic  #121                // InterfaceMethod scalaz/std/VectorFunctions.breakM$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Lscala/Function1;Lscalaz/Monad;)Ljava/lang/Object;
       7: areturn

  public final <A, M> M groupWhenM(scala.collection.immutable.Vector<A>, scala.Function2<A, A, M>, scalaz.Monad<M>);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: aload_3
       4: invokestatic  #129                // InterfaceMethod scalaz/std/VectorFunctions.groupWhenM$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Lscala/Function2;Lscalaz/Monad;)Ljava/lang/Object;
       7: areturn

  public final <A> scala.collection.immutable.Vector<scala.collection.immutable.Vector<A>> groupWhen(scala.collection.immutable.Vector<A>, scala.Function2<A, A, java.lang.Object>);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: invokestatic  #137                // InterfaceMethod scalaz/std/VectorFunctions.groupWhen$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Lscala/Function2;)Lscala/collection/immutable/Vector;
       6: areturn

  public final <A, B, C> scala.Tuple2<C, scala.collection.immutable.Vector<B>> mapAccumLeft(scala.collection.immutable.Vector<A>, C, scala.Function2<C, A, scala.Tuple2<C, B>>);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: aload_3
       4: invokestatic  #145                // InterfaceMethod scalaz/std/VectorFunctions.mapAccumLeft$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Ljava/lang/Object;Lscala/Function2;)Lscala/Tuple2;
       7: areturn

  public final <A, B, C> scala.Tuple2<C, scala.collection.immutable.Vector<B>> mapAccumRight(scala.collection.immutable.Vector<A>, C, scala.Function2<C, A, scala.Tuple2<C, B>>);
    Code:
       0: aload_0
       1: aload_1
       2: aload_2
       3: aload_3
       4: invokestatic  #149                // InterfaceMethod scalaz/std/VectorFunctions.mapAccumRight$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;Ljava/lang/Object;Lscala/Function2;)Lscala/Tuple2;
       7: areturn

  public final <A> scala.collection.immutable.Vector<scala.collection.immutable.Vector<A>> tailz(scala.collection.immutable.Vector<A>);
    Code:
       0: aload_0
       1: aload_1
       2: invokestatic  #153                // InterfaceMethod scalaz/std/VectorFunctions.tailz$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;)Lscala/collection/immutable/Vector;
       5: areturn

  public final <A> scala.collection.immutable.Vector<scala.collection.immutable.Vector<A>> initz(scala.collection.immutable.Vector<A>);
    Code:
       0: aload_0
       1: aload_1
       2: invokestatic  #157                // InterfaceMethod scalaz/std/VectorFunctions.initz$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;)Lscala/collection/immutable/Vector;
       5: areturn

  public final <A> scala.collection.immutable.Vector<scala.Tuple2<A, A>> allPairs(scala.collection.immutable.Vector<A>);
    Code:
       0: aload_0
       1: aload_1
       2: invokestatic  #162                // InterfaceMethod scalaz/std/VectorFunctions.allPairs$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;)Lscala/collection/immutable/Vector;
       5: areturn

  public final <A> scala.collection.immutable.Vector<scala.Tuple2<A, A>> adjacentPairs(scala.collection.immutable.Vector<A>);
    Code:
       0: aload_0
       1: aload_1
       2: invokestatic  #166                // InterfaceMethod scalaz/std/VectorFunctions.adjacentPairs$:(Lscalaz/std/VectorFunctions;Lscala/collection/immutable/Vector;)Lscala/collection/immutable/Vector;
       5: areturn

  public <A> scalaz.Monoid<scala.collection.immutable.Vector<A>> vectorMonoid();
    Code:
       0: aload_0
       1: invokestatic  #173                // InterfaceMethod scalaz/std/VectorInstances.vectorMonoid$:(Lscalaz/std/VectorInstances;)Lscalaz/Monoid;
       4: areturn

  public <A> scalaz.Show<scala.collection.immutable.Vector<A>> vectorShow(scalaz.Show<A>);
    Code:
       0: aload_0
       1: aload_1
       2: invokestatic  #181                // InterfaceMethod scalaz/std/VectorInstances.vectorShow$:(Lscalaz/std/VectorInstances;Lscalaz/Show;)Lscalaz/Show;
       5: areturn

  public <A> scalaz.Order<scala.collection.immutable.Vector<A>> vectorOrder(scalaz.Order<A>);
    Code:
       0: aload_0
       1: aload_1
       2: invokestatic  #190                // InterfaceMethod scalaz/std/VectorInstances.vectorOrder$:(Lscalaz/std/VectorInstances;Lscalaz/Order;)Lscalaz/Order;
       5: areturn

  public <A> scalaz.Equal<scala.collection.immutable.Vector<A>> vectorEqual(scalaz.Equal<A>);
    Code:
       0: aload_0
       1: aload_1
       2: invokestatic  #200                // InterfaceMethod scalaz/std/VectorInstances0.vectorEqual$:(Lscalaz/std/VectorInstances0;Lscalaz/Equal;)Lscalaz/Equal;
       5: areturn

  public scalaz.Traverse<scala.collection.immutable.Vector> vectorInstance();
    Code:
       0: getstatic     #205                // Field vectorInstance:Lscalaz/Traverse;
       3: areturn

  public void scalaz$std$VectorInstances$_setter_$vectorInstance_$eq(scalaz.Traverse<scala.collection.immutable.Vector>);
    Code:
       0: aload_1
       1: putstatic     #205                // Field vectorInstance:Lscalaz/Traverse;
       4: return

  private scalaz.std.vector$();
    Code:
       0: aload_0
       1: invokespecial #210                // Method java/lang/Object."<init>":()V
       4: return
}
