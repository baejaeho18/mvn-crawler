Compiled from "PropertyTree.scala"
public interface zio.config.PropertyTree<K, V> {
  public abstract <K1, V1> zio.config.PropertyTree<K1, V1> flatMap(scala.Function1<V, zio.config.PropertyTree<K1, V1>>);

  public abstract zio.config.PropertyTree<K, V> leafNotASequence();

  public abstract <K1, V1> zio.config.PropertyTree<K1, scala.Tuple2<V, V1>> zip(zio.config.PropertyTree<K1, V1>);

  public abstract <K1> zio.config.PropertyTree<K1, V> at(zio.config.PropertyTreePath<K1>);

  public abstract <K1> scala.Option<zio.config.PropertyTree<K1, V>> atKey(K1);

  public abstract <K1> scala.Option<zio.config.PropertyTree<K1, V>> atIndex(int);

  public abstract <K1, V1> scala.collection.immutable.Map<scala.collection.immutable.Vector<K1>, scala.collection.immutable.$colon$colon<V1>> flatten();

  public abstract <K1, V1> scala.collection.immutable.Map<java.lang.String, java.lang.String> flattenKeyAndValue(java.lang.String, java.lang.String, scala.Predef$$eq$colon$eq<K1, java.lang.String>);

  public abstract <K1, V1> java.lang.String flattenKeyAndValue$default$1();

  public abstract <K1, V1> java.lang.String flattenKeyAndValue$default$2();

  public abstract <K1, V1> scala.collection.immutable.Map<java.lang.String, scala.collection.immutable.$colon$colon<V1>> flattenKeyWith(scala.Function1<K1, java.lang.String>, java.lang.String);

  public abstract <K1, V1> scala.collection.immutable.Map<java.lang.String, scala.collection.immutable.$colon$colon<V1>> flattenString(java.lang.String, scala.Predef$$eq$colon$eq<K1, java.lang.String>);

  public abstract <K1, V1> java.lang.String flattenString$default$1();

  public abstract <K1, V1> zio.config.PropertyTree<K1, V1> getOrElse(scala.Function0<zio.config.PropertyTree<K1, V1>>);

  public abstract <K1> zio.config.PropertyTree<K1, V> getPath(scala.collection.immutable.List<K1>);

  public abstract boolean isEmpty();

  public abstract <K2> zio.config.PropertyTree<K2, V> mapKey(scala.Function1<K, K2>);

  public abstract <V2> zio.config.PropertyTree<K, V2> map(scala.Function1<V, V2>);

  public abstract <E, V2> scala.util.Either<E, zio.config.PropertyTree<K, V2>> mapEither(scala.Function1<V, scala.util.Either<E, V2>>);

  public abstract <K2, V2> zio.config.PropertyTree<K2, V2> bimap(scala.Function1<K, K2>, scala.Function1<V, V2>);

  public abstract <K1, V1> scala.collection.immutable.List<zio.config.PropertyTree<K1, V1>> merge(zio.config.PropertyTree<K1, V1>);

  public abstract boolean nonEmpty();
}
