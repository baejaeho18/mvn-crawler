Compiled from "Range.java"
public class com.vladsch.flexmark.util.sequence.Range {
  public static final com.vladsch.flexmark.util.sequence.Range NULL;

  private final int myStart;

  private final int myEnd;

  public static com.vladsch.flexmark.util.sequence.Range of(int, int);
    Code:
       0: new           #1                  // class com/vladsch/flexmark/util/sequence/Range
       3: dup
       4: iload_0
       5: iload_1
       6: invokespecial #2                  // Method "<init>":(II)V
       9: areturn

  public int getStart();
    Code:
       0: aload_0
       1: getfield      #3                  // Field myStart:I
       4: ireturn

  public int getEnd();
    Code:
       0: aload_0
       1: getfield      #4                  // Field myEnd:I
       4: ireturn

  public int component1();
    Code:
       0: aload_0
       1: getfield      #3                  // Field myStart:I
       4: ireturn

  public int component2();
    Code:
       0: aload_0
       1: getfield      #4                  // Field myEnd:I
       4: ireturn

  public com.vladsch.flexmark.util.sequence.Range(int, int);
    Code:
       0: aload_0
       1: invokespecial #5                  // Method java/lang/Object."<init>":()V
       4: aload_0
       5: iload_1
       6: putfield      #3                  // Field myStart:I
       9: aload_0
      10: iload_2
      11: putfield      #4                  // Field myEnd:I
      14: return

  public com.vladsch.flexmark.util.sequence.Range(com.vladsch.flexmark.util.sequence.Range);
    Code:
       0: aload_0
       1: invokespecial #5                  // Method java/lang/Object."<init>":()V
       4: aload_0
       5: aload_1
       6: getfield      #3                  // Field myStart:I
       9: putfield      #3                  // Field myStart:I
      12: aload_0
      13: aload_1
      14: getfield      #4                  // Field myEnd:I
      17: putfield      #4                  // Field myEnd:I
      20: return

  public com.vladsch.flexmark.util.sequence.Range withStart(int);
    Code:
       0: iload_1
       1: aload_0
       2: getfield      #3                  // Field myStart:I
       5: if_icmpne     12
       8: aload_0
       9: goto          24
      12: new           #1                  // class com/vladsch/flexmark/util/sequence/Range
      15: dup
      16: iload_1
      17: aload_0
      18: getfield      #4                  // Field myEnd:I
      21: invokespecial #2                  // Method "<init>":(II)V
      24: areturn

  public com.vladsch.flexmark.util.sequence.Range withEnd(int);
    Code:
       0: iload_1
       1: aload_0
       2: getfield      #4                  // Field myEnd:I
       5: if_icmpne     12
       8: aload_0
       9: goto          24
      12: new           #1                  // class com/vladsch/flexmark/util/sequence/Range
      15: dup
      16: aload_0
      17: getfield      #3                  // Field myStart:I
      20: iload_1
      21: invokespecial #2                  // Method "<init>":(II)V
      24: areturn

  public com.vladsch.flexmark.util.sequence.Range withRange(int, int);
    Code:
       0: iload_1
       1: aload_0
       2: getfield      #3                  // Field myStart:I
       5: if_icmpne     20
       8: iload_2
       9: aload_0
      10: getfield      #4                  // Field myEnd:I
      13: if_icmpne     20
      16: aload_0
      17: goto          29
      20: new           #1                  // class com/vladsch/flexmark/util/sequence/Range
      23: dup
      24: iload_1
      25: iload_2
      26: invokespecial #2                  // Method "<init>":(II)V
      29: areturn

  public com.vladsch.flexmark.util.sequence.BasedSequence subSequence(java.lang.CharSequence);
    Code:
       0: aload_1
       1: aload_0
       2: getfield      #3                  // Field myStart:I
       5: aload_0
       6: getfield      #4                  // Field myEnd:I
       9: invokestatic  #6                  // Method com/vladsch/flexmark/util/sequence/BasedSequenceImpl.of:(Ljava/lang/CharSequence;II)Lcom/vladsch/flexmark/util/sequence/BasedSequence;
      12: areturn

  public boolean contains(int);
    Code:
       0: aload_0
       1: getfield      #3                  // Field myStart:I
       4: iload_1
       5: if_icmpgt     20
       8: iload_1
       9: aload_0
      10: getfield      #4                  // Field myEnd:I
      13: if_icmpge     20
      16: iconst_1
      17: goto          21
      20: iconst_0
      21: ireturn

  public boolean contains(int, int);
    Code:
       0: aload_0
       1: getfield      #3                  // Field myStart:I
       4: iload_1
       5: if_icmpgt     20
       8: iload_2
       9: aload_0
      10: getfield      #4                  // Field myEnd:I
      13: if_icmpgt     20
      16: iconst_1
      17: goto          21
      20: iconst_0
      21: ireturn

  public boolean leads(int);
    Code:
       0: aload_0
       1: getfield      #4                  // Field myEnd:I
       4: iload_1
       5: if_icmpgt     12
       8: iconst_1
       9: goto          13
      12: iconst_0
      13: ireturn

  public boolean trails(int);
    Code:
       0: aload_0
       1: getfield      #3                  // Field myStart:I
       4: iload_1
       5: if_icmple     12
       8: iconst_1
       9: goto          13
      12: iconst_0
      13: ireturn

  public boolean leadBy(int);
    Code:
       0: aload_0
       1: getfield      #3                  // Field myStart:I
       4: iload_1
       5: if_icmpgt     20
       8: iload_1
       9: aload_0
      10: getfield      #4                  // Field myEnd:I
      13: if_icmpge     20
      16: iconst_1
      17: goto          21
      20: iconst_0
      21: ireturn

  public boolean trailedBy(int);
    Code:
       0: aload_0
       1: getfield      #3                  // Field myStart:I
       4: iload_1
       5: if_icmpgt     20
       8: iload_1
       9: aload_0
      10: getfield      #4                  // Field myEnd:I
      13: if_icmpge     20
      16: iconst_1
      17: goto          21
      20: iconst_0
      21: ireturn

  public boolean doesNotOverlap(com.vladsch.flexmark.util.sequence.Range);
    Code:
       0: aload_1
       1: getfield      #4                  // Field myEnd:I
       4: aload_0
       5: getfield      #3                  // Field myStart:I
       8: if_icmple     22
      11: aload_1
      12: getfield      #3                  // Field myStart:I
      15: aload_0
      16: getfield      #4                  // Field myEnd:I
      19: if_icmplt     26
      22: iconst_1
      23: goto          27
      26: iconst_0
      27: ireturn

  public boolean doesOverlap(com.vladsch.flexmark.util.sequence.Range);
    Code:
       0: aload_1
       1: getfield      #4                  // Field myEnd:I
       4: aload_0
       5: getfield      #3                  // Field myStart:I
       8: if_icmple     26
      11: aload_1
      12: getfield      #3                  // Field myStart:I
      15: aload_0
      16: getfield      #4                  // Field myEnd:I
      19: if_icmpge     26
      22: iconst_1
      23: goto          27
      26: iconst_0
      27: ireturn

  public boolean isEqual(com.vladsch.flexmark.util.sequence.Range);
    Code:
       0: aload_0
       1: getfield      #4                  // Field myEnd:I
       4: aload_1
       5: getfield      #4                  // Field myEnd:I
       8: if_icmpne     26
      11: aload_0
      12: getfield      #3                  // Field myStart:I
      15: aload_1
      16: getfield      #3                  // Field myStart:I
      19: if_icmpne     26
      22: iconst_1
      23: goto          27
      26: iconst_0
      27: ireturn

  public boolean doesContain(com.vladsch.flexmark.util.sequence.Range);
    Code:
       0: aload_0
       1: getfield      #4                  // Field myEnd:I
       4: aload_1
       5: getfield      #4                  // Field myEnd:I
       8: if_icmplt     26
      11: aload_0
      12: getfield      #3                  // Field myStart:I
      15: aload_1
      16: getfield      #3                  // Field myStart:I
      19: if_icmpgt     26
      22: iconst_1
      23: goto          27
      26: iconst_0
      27: ireturn

  public boolean doesProperlyContain(com.vladsch.flexmark.util.sequence.Range);
    Code:
       0: aload_0
       1: getfield      #4                  // Field myEnd:I
       4: aload_1
       5: getfield      #4                  // Field myEnd:I
       8: if_icmple     26
      11: aload_0
      12: getfield      #3                  // Field myStart:I
      15: aload_1
      16: getfield      #3                  // Field myStart:I
      19: if_icmpge     26
      22: iconst_1
      23: goto          27
      26: iconst_0
      27: ireturn

  public boolean isEmpty();
    Code:
       0: aload_0
       1: getfield      #3                  // Field myStart:I
       4: aload_0
       5: getfield      #4                  // Field myEnd:I
       8: if_icmplt     15
      11: iconst_1
      12: goto          16
      15: iconst_0
      16: ireturn

  public boolean isContainedBy(int, int);
    Code:
       0: iload_2
       1: aload_0
       2: getfield      #4                  // Field myEnd:I
       5: if_icmplt     20
       8: iload_1
       9: aload_0
      10: getfield      #3                  // Field myStart:I
      13: if_icmpgt     20
      16: iconst_1
      17: goto          21
      20: iconst_0
      21: ireturn

  public boolean isProperlyContainedBy(int, int);
    Code:
       0: iload_2
       1: aload_0
       2: getfield      #4                  // Field myEnd:I
       5: if_icmple     20
       8: iload_1
       9: aload_0
      10: getfield      #3                  // Field myStart:I
      13: if_icmpge     20
      16: iconst_1
      17: goto          21
      20: iconst_0
      21: ireturn

  public boolean isContainedBy(com.vladsch.flexmark.util.sequence.Range);
    Code:
       0: aload_1
       1: getfield      #4                  // Field myEnd:I
       4: aload_0
       5: getfield      #4                  // Field myEnd:I
       8: if_icmplt     26
      11: aload_1
      12: getfield      #3                  // Field myStart:I
      15: aload_0
      16: getfield      #3                  // Field myStart:I
      19: if_icmpgt     26
      22: iconst_1
      23: goto          27
      26: iconst_0
      27: ireturn

  public boolean isProperlyContainedBy(com.vladsch.flexmark.util.sequence.Range);
    Code:
       0: aload_1
       1: getfield      #4                  // Field myEnd:I
       4: aload_0
       5: getfield      #4                  // Field myEnd:I
       8: if_icmple     26
      11: aload_1
      12: getfield      #3                  // Field myStart:I
      15: aload_0
      16: getfield      #3                  // Field myStart:I
      19: if_icmpge     26
      22: iconst_1
      23: goto          27
      26: iconst_0
      27: ireturn

  public boolean doesContain(int);
    Code:
       0: iload_1
       1: aload_0
       2: getfield      #3                  // Field myStart:I
       5: if_icmplt     20
       8: iload_1
       9: aload_0
      10: getfield      #4                  // Field myEnd:I
      13: if_icmpge     20
      16: iconst_1
      17: goto          21
      20: iconst_0
      21: ireturn

  public boolean isAdjacent(int);
    Code:
       0: iload_1
       1: aload_0
       2: getfield      #3                  // Field myStart:I
       5: iconst_1
       6: isub
       7: if_icmpeq     18
      10: iload_1
      11: aload_0
      12: getfield      #4                  // Field myEnd:I
      15: if_icmpne     22
      18: iconst_1
      19: goto          23
      22: iconst_0
      23: ireturn

  public boolean isStart(int);
    Code:
       0: iload_1
       1: aload_0
       2: getfield      #3                  // Field myStart:I
       5: if_icmpne     12
       8: iconst_1
       9: goto          13
      12: iconst_0
      13: ireturn

  public boolean isEnd(int);
    Code:
       0: iload_1
       1: aload_0
       2: getfield      #4                  // Field myEnd:I
       5: if_icmpne     12
       8: iconst_1
       9: goto          13
      12: iconst_0
      13: ireturn

  public boolean isLast(int);
    Code:
       0: iload_1
       1: aload_0
       2: getfield      #3                  // Field myStart:I
       5: if_icmplt     22
       8: iload_1
       9: aload_0
      10: getfield      #4                  // Field myEnd:I
      13: iconst_1
      14: isub
      15: if_icmpne     22
      18: iconst_1
      19: goto          23
      22: iconst_0
      23: ireturn

  public boolean isAdjacentBefore(int);
    Code:
       0: aload_0
       1: getfield      #4                  // Field myEnd:I
       4: iload_1
       5: if_icmpne     12
       8: iconst_1
       9: goto          13
      12: iconst_0
      13: ireturn

  public boolean isAdjacentAfter(int);
    Code:
       0: aload_0
       1: getfield      #3                  // Field myStart:I
       4: iconst_1
       5: isub
       6: iload_1
       7: if_icmpne     14
      10: iconst_1
      11: goto          15
      14: iconst_0
      15: ireturn

  public com.vladsch.flexmark.util.sequence.Range intersect(com.vladsch.flexmark.util.sequence.Range);
    Code:
       0: aload_0
       1: getfield      #3                  // Field myStart:I
       4: istore_2
       5: iload_2
       6: aload_1
       7: getfield      #3                  // Field myStart:I
      10: if_icmpge     18
      13: aload_1
      14: getfield      #3                  // Field myStart:I
      17: istore_2
      18: aload_0
      19: getfield      #4                  // Field myEnd:I
      22: istore_3
      23: iload_3
      24: aload_1
      25: getfield      #4                  // Field myEnd:I
      28: if_icmple     36
      31: aload_1
      32: getfield      #4                  // Field myEnd:I
      35: istore_3
      36: iload_2
      37: iload_3
      38: if_icmplt     45
      41: iconst_0
      42: dup
      43: istore_3
      44: istore_2
      45: aload_0
      46: iload_2
      47: iload_3
      48: invokevirtual #7                  // Method withRange:(II)Lcom/vladsch/flexmark/util/sequence/Range;
      51: areturn

  public com.vladsch.flexmark.util.sequence.Range exclude(com.vladsch.flexmark.util.sequence.Range);
    Code:
       0: aload_0
       1: getfield      #3                  // Field myStart:I
       4: istore_2
       5: iload_2
       6: aload_1
       7: getfield      #3                  // Field myStart:I
      10: if_icmplt     26
      13: iload_2
      14: aload_1
      15: getfield      #4                  // Field myEnd:I
      18: if_icmpge     26
      21: aload_1
      22: getfield      #4                  // Field myEnd:I
      25: istore_2
      26: aload_0
      27: getfield      #4                  // Field myEnd:I
      30: istore_3
      31: iload_3
      32: aload_1
      33: getfield      #4                  // Field myEnd:I
      36: if_icmpgt     52
      39: iload_3
      40: aload_1
      41: getfield      #3                  // Field myStart:I
      44: if_icmple     52
      47: aload_1
      48: getfield      #3                  // Field myStart:I
      51: istore_3
      52: iload_2
      53: iload_3
      54: if_icmplt     61
      57: iconst_0
      58: dup
      59: istore_3
      60: istore_2
      61: aload_0
      62: iload_2
      63: iload_3
      64: invokevirtual #7                  // Method withRange:(II)Lcom/vladsch/flexmark/util/sequence/Range;
      67: areturn

  public int compare(com.vladsch.flexmark.util.sequence.Range);
    Code:
       0: aload_0
       1: getfield      #3                  // Field myStart:I
       4: aload_1
       5: getfield      #3                  // Field myStart:I
       8: if_icmpge     13
      11: iconst_m1
      12: ireturn
      13: aload_0
      14: getfield      #3                  // Field myStart:I
      17: aload_1
      18: getfield      #3                  // Field myStart:I
      21: if_icmple     26
      24: iconst_1
      25: ireturn
      26: aload_0
      27: getfield      #4                  // Field myEnd:I
      30: aload_1
      31: getfield      #4                  // Field myEnd:I
      34: if_icmple     39
      37: iconst_m1
      38: ireturn
      39: aload_0
      40: getfield      #4                  // Field myEnd:I
      43: aload_1
      44: getfield      #4                  // Field myEnd:I
      47: if_icmpge     52
      50: iconst_1
      51: ireturn
      52: iconst_0
      53: ireturn

  public int getSpan();
    Code:
       0: aload_0
       1: getfield      #4                  // Field myEnd:I
       4: aload_0
       5: getfield      #3                  // Field myStart:I
       8: isub
       9: ireturn

  public int length();
    Code:
       0: aload_0
       1: getfield      #4                  // Field myEnd:I
       4: aload_0
       5: getfield      #3                  // Field myStart:I
       8: isub
       9: ireturn

  public boolean isNull();
    Code:
       0: aload_0
       1: getstatic     #8                  // Field NULL:Lcom/vladsch/flexmark/util/sequence/Range;
       4: if_acmpne     11
       7: iconst_1
       8: goto          12
      11: iconst_0
      12: ireturn

  public boolean isNotNull();
    Code:
       0: aload_0
       1: getstatic     #8                  // Field NULL:Lcom/vladsch/flexmark/util/sequence/Range;
       4: if_acmpeq     11
       7: iconst_1
       8: goto          12
      11: iconst_0
      12: ireturn

  public java.lang.String toString();
    Code:
       0: new           #9                  // class java/lang/StringBuilder
       3: dup
       4: invokespecial #10                 // Method java/lang/StringBuilder."<init>":()V
       7: ldc           #11                 // String [
       9: invokevirtual #12                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      12: aload_0
      13: getfield      #3                  // Field myStart:I
      16: invokevirtual #13                 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
      19: ldc           #14                 // String ,
      21: invokevirtual #12                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      24: aload_0
      25: getfield      #4                  // Field myEnd:I
      28: invokevirtual #13                 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
      31: ldc           #15                 // String )
      33: invokevirtual #12                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      36: invokevirtual #16                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      39: areturn

  public boolean isAdjacent(com.vladsch.flexmark.util.sequence.Range);
    Code:
       0: aload_0
       1: getfield      #3                  // Field myStart:I
       4: aload_1
       5: getfield      #4                  // Field myEnd:I
       8: if_icmpeq     22
      11: aload_0
      12: getfield      #4                  // Field myEnd:I
      15: aload_1
      16: getfield      #3                  // Field myStart:I
      19: if_icmpne     26
      22: iconst_1
      23: goto          27
      26: iconst_0
      27: ireturn

  public boolean isAdjacentBefore(com.vladsch.flexmark.util.sequence.Range);
    Code:
       0: aload_0
       1: getfield      #4                  // Field myEnd:I
       4: aload_1
       5: getfield      #3                  // Field myStart:I
       8: if_icmpne     15
      11: iconst_1
      12: goto          16
      15: iconst_0
      16: ireturn

  public boolean isAdjacentAfter(com.vladsch.flexmark.util.sequence.Range);
    Code:
       0: aload_0
       1: getfield      #3                  // Field myStart:I
       4: aload_1
       5: getfield      #4                  // Field myEnd:I
       8: if_icmpne     15
      11: iconst_1
      12: goto          16
      15: iconst_0
      16: ireturn

  public com.vladsch.flexmark.util.sequence.Range include(com.vladsch.flexmark.util.sequence.Range);
    Code:
       0: aload_1
       1: invokevirtual #17                 // Method isNull:()Z
       4: ifeq          24
       7: aload_0
       8: invokevirtual #17                 // Method isNull:()Z
      11: ifeq          20
      14: getstatic     #8                  // Field NULL:Lcom/vladsch/flexmark/util/sequence/Range;
      17: goto          29
      20: aload_0
      21: goto          29
      24: aload_0
      25: aload_1
      26: invokevirtual #18                 // Method expandToInclude:(Lcom/vladsch/flexmark/util/sequence/Range;)Lcom/vladsch/flexmark/util/sequence/Range;
      29: areturn

  public com.vladsch.flexmark.util.sequence.Range include(int);
    Code:
       0: aload_0
       1: iload_1
       2: iload_1
       3: invokevirtual #19                 // Method include:(II)Lcom/vladsch/flexmark/util/sequence/Range;
       6: areturn

  public com.vladsch.flexmark.util.sequence.Range include(int, int);
    Code:
       0: aload_0
       1: invokevirtual #17                 // Method isNull:()Z
       4: ifeq          19
       7: new           #1                  // class com/vladsch/flexmark/util/sequence/Range
      10: dup
      11: iload_1
      12: iload_2
      13: invokespecial #2                  // Method "<init>":(II)V
      16: goto          25
      19: aload_0
      20: iload_1
      21: iload_2
      22: invokevirtual #20                 // Method expandToInclude:(II)Lcom/vladsch/flexmark/util/sequence/Range;
      25: areturn

  public com.vladsch.flexmark.util.sequence.Range expandToInclude(com.vladsch.flexmark.util.sequence.Range);
    Code:
       0: aload_0
       1: aload_1
       2: getfield      #3                  // Field myStart:I
       5: aload_1
       6: getfield      #4                  // Field myEnd:I
       9: invokevirtual #20                 // Method expandToInclude:(II)Lcom/vladsch/flexmark/util/sequence/Range;
      12: areturn

  public com.vladsch.flexmark.util.sequence.Range expandToInclude(int, int);
    Code:
       0: aload_0
       1: aload_0
       2: getfield      #3                  // Field myStart:I
       5: iload_1
       6: if_icmple     13
       9: iload_1
      10: goto          17
      13: aload_0
      14: getfield      #3                  // Field myStart:I
      17: aload_0
      18: getfield      #4                  // Field myEnd:I
      21: iload_2
      22: if_icmpge     29
      25: iload_2
      26: goto          33
      29: aload_0
      30: getfield      #4                  // Field myEnd:I
      33: invokevirtual #7                  // Method withRange:(II)Lcom/vladsch/flexmark/util/sequence/Range;
      36: areturn

  public boolean equals(java.lang.Object);
    Code:
       0: aload_0
       1: aload_1
       2: if_acmpne     7
       5: iconst_1
       6: ireturn
       7: aload_1
       8: instanceof    #1                  // class com/vladsch/flexmark/util/sequence/Range
      11: ifne          16
      14: iconst_0
      15: ireturn
      16: aload_1
      17: checkcast     #1                  // class com/vladsch/flexmark/util/sequence/Range
      20: astore_2
      21: aload_0
      22: getfield      #3                  // Field myStart:I
      25: aload_2
      26: getfield      #3                  // Field myStart:I
      29: if_icmpne     47
      32: aload_0
      33: getfield      #4                  // Field myEnd:I
      36: aload_2
      37: getfield      #4                  // Field myEnd:I
      40: if_icmpne     47
      43: iconst_1
      44: goto          48
      47: iconst_0
      48: ireturn

  public int hashCode();
    Code:
       0: aload_0
       1: getfield      #3                  // Field myStart:I
       4: istore_1
       5: bipush        31
       7: iload_1
       8: imul
       9: aload_0
      10: getfield      #4                  // Field myEnd:I
      13: iadd
      14: istore_1
      15: iload_1
      16: ireturn

  static {};
    Code:
       0: new           #1                  // class com/vladsch/flexmark/util/sequence/Range
       3: dup
       4: iconst_0
       5: iconst_0
       6: invokespecial #2                  // Method "<init>":(II)V
       9: putstatic     #8                  // Field NULL:Lcom/vladsch/flexmark/util/sequence/Range;
      12: return
}
