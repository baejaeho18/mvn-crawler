Compiled from "NodeClassifierVisitor.java"
public class com.vladsch.flexmark.util.collection.NodeClassifierVisitor extends com.vladsch.flexmark.ast.NodeVisitorBase implements com.vladsch.flexmark.util.NodeTracker {
  private final com.vladsch.flexmark.util.collection.OrderedMap<java.lang.Class<?>, java.util.Set<java.lang.Class<?>>> myExclusionMap;

  private final com.vladsch.flexmark.util.collection.OrderedSet<java.lang.Class<?>> myExclusionSet;

  private final java.util.HashMap<java.lang.Integer, java.util.BitSet> myNodeAncestryMap;

  private final java.util.Stack<java.util.BitSet> myNodeAncestryBitSetStack;

  private final com.vladsch.flexmark.util.collection.CopyOnWriteRef<java.util.BitSet> myNodeAncestryBitSet;

  private static final java.util.BitSet EMPTY_SET;

  private boolean myClassificationDone;

  private final com.vladsch.flexmark.util.collection.ClassifyingNodeTracker myClassifyingNodeTracker;

  static final boolean $assertionsDisabled;

  public com.vladsch.flexmark.util.collection.NodeClassifierVisitor(java.util.Map<java.lang.Class<? extends com.vladsch.flexmark.ast.Node>, java.util.Set<java.lang.Class<?>>>);
    Code:
       0: aload_0
       1: invokespecial #1                  // Method com/vladsch/flexmark/ast/NodeVisitorBase."<init>":()V
       4: aload_0
       5: new           #2                  // class java/util/Stack
       8: dup
       9: invokespecial #3                  // Method java/util/Stack."<init>":()V
      12: putfield      #4                  // Field myNodeAncestryBitSetStack:Ljava/util/Stack;
      15: aload_0
      16: new           #5                  // class com/vladsch/flexmark/util/collection/CopyOnWriteRef
      19: dup
      20: new           #6                  // class java/util/BitSet
      23: dup
      24: invokespecial #7                  // Method java/util/BitSet."<init>":()V
      27: new           #8                  // class com/vladsch/flexmark/util/collection/NodeClassifierVisitor$1
      30: dup
      31: aload_0
      32: invokespecial #9                  // Method com/vladsch/flexmark/util/collection/NodeClassifierVisitor$1."<init>":(Lcom/vladsch/flexmark/util/collection/NodeClassifierVisitor;)V
      35: invokespecial #10                 // Method com/vladsch/flexmark/util/collection/CopyOnWriteRef."<init>":(Ljava/lang/Object;Lcom/vladsch/flexmark/util/Computable;)V
      38: putfield      #11                 // Field myNodeAncestryBitSet:Lcom/vladsch/flexmark/util/collection/CopyOnWriteRef;
      41: aload_0
      42: iconst_0
      43: putfield      #12                 // Field myClassificationDone:Z
      46: aload_0
      47: new           #13                 // class com/vladsch/flexmark/util/collection/ClassifyingNodeTracker
      50: dup
      51: aload_0
      52: aload_1
      53: invokespecial #14                 // Method com/vladsch/flexmark/util/collection/ClassifyingNodeTracker."<init>":(Lcom/vladsch/flexmark/util/NodeTracker;Ljava/util/Map;)V
      56: putfield      #15                 // Field myClassifyingNodeTracker:Lcom/vladsch/flexmark/util/collection/ClassifyingNodeTracker;
      59: aload_0
      60: aload_0
      61: getfield      #15                 // Field myClassifyingNodeTracker:Lcom/vladsch/flexmark/util/collection/ClassifyingNodeTracker;
      64: invokevirtual #16                 // Method com/vladsch/flexmark/util/collection/ClassifyingNodeTracker.getExclusionMap:()Lcom/vladsch/flexmark/util/collection/OrderedMap;
      67: putfield      #17                 // Field myExclusionMap:Lcom/vladsch/flexmark/util/collection/OrderedMap;
      70: aload_0
      71: aload_0
      72: getfield      #15                 // Field myClassifyingNodeTracker:Lcom/vladsch/flexmark/util/collection/ClassifyingNodeTracker;
      75: invokevirtual #18                 // Method com/vladsch/flexmark/util/collection/ClassifyingNodeTracker.getNodeAncestryMap:()Ljava/util/HashMap;
      78: putfield      #19                 // Field myNodeAncestryMap:Ljava/util/HashMap;
      81: aload_0
      82: aload_0
      83: getfield      #15                 // Field myClassifyingNodeTracker:Lcom/vladsch/flexmark/util/collection/ClassifyingNodeTracker;
      86: invokevirtual #20                 // Method com/vladsch/flexmark/util/collection/ClassifyingNodeTracker.getExclusionSet:()Lcom/vladsch/flexmark/util/collection/OrderedSet;
      89: putfield      #21                 // Field myExclusionSet:Lcom/vladsch/flexmark/util/collection/OrderedSet;
      92: return

  public com.vladsch.flexmark.util.collection.ClassifyingNodeTracker classify(com.vladsch.flexmark.ast.Node);
    Code:
       0: getstatic     #22                 // Field $assertionsDisabled:Z
       3: ifne          21
       6: aload_0
       7: getfield      #12                 // Field myClassificationDone:Z
      10: ifeq          21
      13: new           #23                 // class java/lang/AssertionError
      16: dup
      17: invokespecial #24                 // Method java/lang/AssertionError."<init>":()V
      20: athrow
      21: aload_0
      22: aload_1
      23: invokevirtual #25                 // Method visit:(Lcom/vladsch/flexmark/ast/Node;)V
      26: aload_0
      27: iconst_1
      28: putfield      #12                 // Field myClassificationDone:Z
      31: aload_0
      32: getfield      #15                 // Field myClassifyingNodeTracker:Lcom/vladsch/flexmark/util/collection/ClassifyingNodeTracker;
      35: areturn

  public void visit(com.vladsch.flexmark.ast.Node);
    Code:
       0: aload_0
       1: aload_1
       2: invokevirtual #26                 // Method visitChildren:(Lcom/vladsch/flexmark/ast/Node;)V
       5: return

  public void nodeRemoved(com.vladsch.flexmark.ast.Node);
    Code:
       0: return

  public void nodeRemovedWithChildren(com.vladsch.flexmark.ast.Node);
    Code:
       0: return

  public void nodeRemovedWithDescendants(com.vladsch.flexmark.ast.Node);
    Code:
       0: return

  public void nodeAddedWithChildren(com.vladsch.flexmark.ast.Node);
    Code:
       0: aload_0
       1: aload_1
       2: invokevirtual #27                 // Method nodeAdded:(Lcom/vladsch/flexmark/ast/Node;)V
       5: return

  public void nodeAddedWithDescendants(com.vladsch.flexmark.ast.Node);
    Code:
       0: aload_0
       1: aload_1
       2: invokevirtual #27                 // Method nodeAdded:(Lcom/vladsch/flexmark/ast/Node;)V
       5: return

  public void nodeAdded(com.vladsch.flexmark.ast.Node);
    Code:
       0: aload_0
       1: getfield      #12                 // Field myClassificationDone:Z
       4: ifeq          133
       7: aload_1
       8: invokevirtual #28                 // Method com/vladsch/flexmark/ast/Node.getParent:()Lcom/vladsch/flexmark/ast/Node;
      11: ifnonnull     24
      14: new           #29                 // class java/lang/IllegalStateException
      17: dup
      18: ldc           #30                 // String Node must be inserted into the document before calling node tracker nodeAdded functions
      20: invokespecial #31                 // Method java/lang/IllegalStateException."<init>":(Ljava/lang/String;)V
      23: athrow
      24: aload_1
      25: invokevirtual #28                 // Method com/vladsch/flexmark/ast/Node.getParent:()Lcom/vladsch/flexmark/ast/Node;
      28: instanceof    #32                 // class com/vladsch/flexmark/ast/Document
      31: ifne          121
      34: aload_0
      35: getfield      #15                 // Field myClassifyingNodeTracker:Lcom/vladsch/flexmark/util/collection/ClassifyingNodeTracker;
      38: invokevirtual #33                 // Method com/vladsch/flexmark/util/collection/ClassifyingNodeTracker.getItems:()Lcom/vladsch/flexmark/util/collection/OrderedSet;
      41: aload_1
      42: invokevirtual #28                 // Method com/vladsch/flexmark/ast/Node.getParent:()Lcom/vladsch/flexmark/ast/Node;
      45: invokevirtual #34                 // Method com/vladsch/flexmark/util/collection/OrderedSet.indexOf:(Ljava/lang/Object;)I
      48: istore_2
      49: iload_2
      50: iconst_m1
      51: if_icmpne     98
      54: new           #29                 // class java/lang/IllegalStateException
      57: dup
      58: new           #35                 // class java/lang/StringBuilder
      61: dup
      62: invokespecial #36                 // Method java/lang/StringBuilder."<init>":()V
      65: ldc           #37                 // String Parent node:
      67: invokevirtual #38                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      70: aload_1
      71: invokevirtual #28                 // Method com/vladsch/flexmark/ast/Node.getParent:()Lcom/vladsch/flexmark/ast/Node;
      74: invokevirtual #39                 // Method java/lang/StringBuilder.append:(Ljava/lang/Object;)Ljava/lang/StringBuilder;
      77: ldc           #40                 // String  of
      79: invokevirtual #38                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      82: aload_1
      83: invokevirtual #39                 // Method java/lang/StringBuilder.append:(Ljava/lang/Object;)Ljava/lang/StringBuilder;
      86: ldc           #41                 // String  is not tracked, some post processor forgot to call tracker.nodeAdded().
      88: invokevirtual #38                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      91: invokevirtual #42                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      94: invokespecial #31                 // Method java/lang/IllegalStateException."<init>":(Ljava/lang/String;)V
      97: athrow
      98: aload_0
      99: getfield      #19                 // Field myNodeAncestryMap:Ljava/util/HashMap;
     102: iload_2
     103: invokestatic  #43                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
     106: invokevirtual #44                 // Method java/util/HashMap.get:(Ljava/lang/Object;)Ljava/lang/Object;
     109: checkcast     #6                  // class java/util/BitSet
     112: astore_3
     113: aload_0
     114: getfield      #11                 // Field myNodeAncestryBitSet:Lcom/vladsch/flexmark/util/collection/CopyOnWriteRef;
     117: aload_3
     118: invokevirtual #45                 // Method com/vladsch/flexmark/util/collection/CopyOnWriteRef.setValue:(Ljava/lang/Object;)V
     121: aload_0
     122: getfield      #4                  // Field myNodeAncestryBitSetStack:Ljava/util/Stack;
     125: invokevirtual #46                 // Method java/util/Stack.clear:()V
     128: aload_0
     129: aload_1
     130: invokevirtual #25                 // Method visit:(Lcom/vladsch/flexmark/ast/Node;)V
     133: return

  void pushNodeAncestry();
    Code:
       0: aload_0
       1: getfield      #17                 // Field myExclusionMap:Lcom/vladsch/flexmark/util/collection/OrderedMap;
       4: invokevirtual #47                 // Method com/vladsch/flexmark/util/collection/OrderedMap.isEmpty:()Z
       7: ifne          25
      10: aload_0
      11: getfield      #4                  // Field myNodeAncestryBitSetStack:Ljava/util/Stack;
      14: aload_0
      15: getfield      #11                 // Field myNodeAncestryBitSet:Lcom/vladsch/flexmark/util/collection/CopyOnWriteRef;
      18: invokevirtual #48                 // Method com/vladsch/flexmark/util/collection/CopyOnWriteRef.getImmutable:()Ljava/lang/Object;
      21: invokevirtual #49                 // Method java/util/Stack.push:(Ljava/lang/Object;)Ljava/lang/Object;
      24: pop
      25: return

  void popNodeAncestry();
    Code:
       0: aload_0
       1: getfield      #11                 // Field myNodeAncestryBitSet:Lcom/vladsch/flexmark/util/collection/CopyOnWriteRef;
       4: aload_0
       5: getfield      #4                  // Field myNodeAncestryBitSetStack:Ljava/util/Stack;
       8: invokevirtual #50                 // Method java/util/Stack.pop:()Ljava/lang/Object;
      11: invokevirtual #45                 // Method com/vladsch/flexmark/util/collection/CopyOnWriteRef.setValue:(Ljava/lang/Object;)V
      14: return

  boolean updateNodeAncestry(com.vladsch.flexmark.ast.Node, com.vladsch.flexmark.util.collection.CopyOnWriteRef<java.util.BitSet>);
    Code:
       0: aload_1
       1: invokevirtual #28                 // Method com/vladsch/flexmark/ast/Node.getParent:()Lcom/vladsch/flexmark/ast/Node;
       4: astore_3
       5: aload_0
       6: getfield      #17                 // Field myExclusionMap:Lcom/vladsch/flexmark/util/collection/OrderedMap;
       9: invokevirtual #47                 // Method com/vladsch/flexmark/util/collection/OrderedMap.isEmpty:()Z
      12: ifne          290
      15: aload_1
      16: instanceof    #32                 // class com/vladsch/flexmark/ast/Document
      19: ifne          290
      22: aload_1
      23: invokevirtual #51                 // Method java/lang/Object.getClass:()Ljava/lang/Class;
      26: pop
      27: aload_2
      28: invokevirtual #52                 // Method com/vladsch/flexmark/util/collection/CopyOnWriteRef.getPeek:()Ljava/lang/Object;
      31: checkcast     #6                  // class java/util/BitSet
      34: astore        4
      36: aload_0
      37: getfield      #15                 // Field myClassifyingNodeTracker:Lcom/vladsch/flexmark/util/collection/ClassifyingNodeTracker;
      40: invokevirtual #33                 // Method com/vladsch/flexmark/util/collection/ClassifyingNodeTracker.getItems:()Lcom/vladsch/flexmark/util/collection/OrderedSet;
      43: aload_1
      44: invokevirtual #34                 // Method com/vladsch/flexmark/util/collection/OrderedSet.indexOf:(Ljava/lang/Object;)I
      47: istore        5
      49: iload         5
      51: iconst_m1
      52: if_icmpne     87
      55: new           #29                 // class java/lang/IllegalStateException
      58: dup
      59: new           #35                 // class java/lang/StringBuilder
      62: dup
      63: invokespecial #36                 // Method java/lang/StringBuilder."<init>":()V
      66: ldc           #53                 // String Node:
      68: invokevirtual #38                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      71: aload_1
      72: invokevirtual #39                 // Method java/lang/StringBuilder.append:(Ljava/lang/Object;)Ljava/lang/StringBuilder;
      75: ldc           #41                 // String  is not tracked, some post processor forgot to call tracker.nodeAdded().
      77: invokevirtual #38                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      80: invokevirtual #42                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      83: invokespecial #31                 // Method java/lang/IllegalStateException."<init>":(Ljava/lang/String;)V
      86: athrow
      87: aload_0
      88: getfield      #21                 // Field myExclusionSet:Lcom/vladsch/flexmark/util/collection/OrderedSet;
      91: ifnull        213
      94: aload_0
      95: getfield      #21                 // Field myExclusionSet:Lcom/vladsch/flexmark/util/collection/OrderedSet;
      98: invokevirtual #54                 // Method com/vladsch/flexmark/util/collection/OrderedSet.isEmpty:()Z
     101: ifne          213
     104: aload_0
     105: getfield      #21                 // Field myExclusionSet:Lcom/vladsch/flexmark/util/collection/OrderedSet;
     108: invokeinterface #55,  1           // InterfaceMethod java/util/Set.iterator:()Ljava/util/Iterator;
     113: astore        6
     115: aload         6
     117: invokeinterface #56,  1           // InterfaceMethod java/util/Iterator.hasNext:()Z
     122: ifeq          213
     125: aload         6
     127: invokeinterface #57,  1           // InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;
     132: checkcast     #58                 // class java/lang/Class
     135: astore        7
     137: aload         7
     139: aload_1
     140: invokevirtual #59                 // Method java/lang/Class.isInstance:(Ljava/lang/Object;)Z
     143: ifeq          210
     146: aload_0
     147: getfield      #21                 // Field myExclusionSet:Lcom/vladsch/flexmark/util/collection/OrderedSet;
     150: aload         7
     152: invokevirtual #34                 // Method com/vladsch/flexmark/util/collection/OrderedSet.indexOf:(Ljava/lang/Object;)I
     155: istore        8
     157: getstatic     #22                 // Field $assertionsDisabled:Z
     160: ifne          177
     163: iload         8
     165: iconst_m1
     166: if_icmpne     177
     169: new           #23                 // class java/lang/AssertionError
     172: dup
     173: invokespecial #24                 // Method java/lang/AssertionError."<init>":()V
     176: athrow
     177: aload         4
     179: iload         8
     181: invokevirtual #60                 // Method java/util/BitSet.get:(I)Z
     184: ifne          210
     187: aload_2
     188: invokevirtual #61                 // Method com/vladsch/flexmark/util/collection/CopyOnWriteRef.isMutable:()Z
     191: ifne          210
     194: aload_2
     195: invokevirtual #62                 // Method com/vladsch/flexmark/util/collection/CopyOnWriteRef.getMutable:()Ljava/lang/Object;
     198: checkcast     #6                  // class java/util/BitSet
     201: astore        4
     203: aload         4
     205: iload         8
     207: invokevirtual #63                 // Method java/util/BitSet.set:(I)V
     210: goto          115
     213: aload_0
     214: getfield      #12                 // Field myClassificationDone:Z
     217: ifeq          265
     220: aload_0
     221: getfield      #4                  // Field myNodeAncestryBitSetStack:Ljava/util/Stack;
     224: invokevirtual #64                 // Method java/util/Stack.size:()I
     227: iconst_1
     228: if_icmple     265
     231: aload_0
     232: getfield      #19                 // Field myNodeAncestryMap:Ljava/util/HashMap;
     235: iload         5
     237: invokestatic  #43                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
     240: invokevirtual #44                 // Method java/util/HashMap.get:(Ljava/lang/Object;)Ljava/lang/Object;
     243: checkcast     #6                  // class java/util/BitSet
     246: astore        6
     248: aload         6
     250: ifnull        265
     253: aload         6
     255: aload         4
     257: invokevirtual #65                 // Method java/util/BitSet.equals:(Ljava/lang/Object;)Z
     260: ifeq          265
     263: iconst_0
     264: ireturn
     265: aload         4
     267: invokevirtual #66                 // Method java/util/BitSet.isEmpty:()Z
     270: ifne          290
     273: aload_0
     274: getfield      #19                 // Field myNodeAncestryMap:Ljava/util/HashMap;
     277: iload         5
     279: invokestatic  #43                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
     282: aload_2
     283: invokevirtual #48                 // Method com/vladsch/flexmark/util/collection/CopyOnWriteRef.getImmutable:()Ljava/lang/Object;
     286: invokevirtual #67                 // Method java/util/HashMap.put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
     289: pop
     290: iconst_1
     291: ireturn

  public void visitChildren(com.vladsch.flexmark.ast.Node);
    Code:
       0: aload_0
       1: getfield      #12                 // Field myClassificationDone:Z
       4: ifne          22
       7: aload_1
       8: instanceof    #32                 // class com/vladsch/flexmark/ast/Document
      11: ifne          22
      14: aload_0
      15: getfield      #15                 // Field myClassifyingNodeTracker:Lcom/vladsch/flexmark/util/collection/ClassifyingNodeTracker;
      18: aload_1
      19: invokevirtual #68                 // Method com/vladsch/flexmark/util/collection/ClassifyingNodeTracker.nodeAdded:(Lcom/vladsch/flexmark/ast/Node;)V
      22: aload_1
      23: invokevirtual #69                 // Method com/vladsch/flexmark/ast/Node.getFirstChild:()Lcom/vladsch/flexmark/ast/Node;
      26: ifnull        57
      29: aload_0
      30: invokevirtual #70                 // Method pushNodeAncestry:()V
      33: aload_0
      34: aload_1
      35: aload_0
      36: getfield      #11                 // Field myNodeAncestryBitSet:Lcom/vladsch/flexmark/util/collection/CopyOnWriteRef;
      39: invokevirtual #71                 // Method updateNodeAncestry:(Lcom/vladsch/flexmark/ast/Node;Lcom/vladsch/flexmark/util/collection/CopyOnWriteRef;)Z
      42: ifeq          50
      45: aload_0
      46: aload_1
      47: invokespecial #72                 // Method com/vladsch/flexmark/ast/NodeVisitorBase.visitChildren:(Lcom/vladsch/flexmark/ast/Node;)V
      50: aload_0
      51: invokevirtual #73                 // Method popNodeAncestry:()V
      54: goto          67
      57: aload_0
      58: aload_1
      59: aload_0
      60: getfield      #11                 // Field myNodeAncestryBitSet:Lcom/vladsch/flexmark/util/collection/CopyOnWriteRef;
      63: invokevirtual #71                 // Method updateNodeAncestry:(Lcom/vladsch/flexmark/ast/Node;Lcom/vladsch/flexmark/util/collection/CopyOnWriteRef;)Z
      66: pop
      67: return

  static {};
    Code:
       0: ldc           #74                 // class com/vladsch/flexmark/util/collection/NodeClassifierVisitor
       2: invokevirtual #75                 // Method java/lang/Class.desiredAssertionStatus:()Z
       5: ifne          12
       8: iconst_1
       9: goto          13
      12: iconst_0
      13: putstatic     #22                 // Field $assertionsDisabled:Z
      16: new           #6                  // class java/util/BitSet
      19: dup
      20: invokespecial #7                  // Method java/util/BitSet."<init>":()V
      23: putstatic     #76                 // Field EMPTY_SET:Ljava/util/BitSet;
      26: return
}
