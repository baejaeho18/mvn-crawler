Compiled from "BasedSequence.java"
public interface com.vladsch.flexmark.util.sequence.BasedSequence extends java.lang.CharSequence, java.lang.Comparable<java.lang.CharSequence> {
  public static final com.vladsch.flexmark.util.sequence.BasedSequence NULL;

  public static final com.vladsch.flexmark.util.sequence.BasedSequence EOL;

  public static final com.vladsch.flexmark.util.sequence.BasedSequence SPACE;

  public static final java.util.List<com.vladsch.flexmark.util.sequence.BasedSequence> EMPTY_LIST;

  public static final com.vladsch.flexmark.util.sequence.BasedSequence[] EMPTY_ARRAY;

  public static final java.lang.String WHITESPACE_NO_EOL_CHARS;

  public static final java.lang.String WHITESPACE_CHARS;

  public static final java.lang.String WHITESPACE_NBSP_CHARS;

  public static final java.lang.String EOL_CHARS;

  public static final char EOL_CHAR;

  public static final char EOL_CHAR1;

  public static final char EOL_CHAR2;

  public static final int SPLIT_INCLUDE_DELIMS;

  public static final int SPLIT_TRIM_PARTS;

  public static final int SPLIT_SKIP_EMPTY;

  public static final int SPLIT_INCLUDE_DELIM_PARTS;

  public static final int SPLIT_TRIM_SKIP_EMPTY;

  public abstract char lastChar();

  public abstract char firstChar();

  public abstract java.lang.Object getBase();

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence getBaseSequence();

  public abstract int getStartOffset();

  public abstract int getEndOffset();

  public abstract int getIndexOffset(int);

  public abstract com.vladsch.flexmark.util.sequence.Range getIndexRange(int, int);

  public abstract com.vladsch.flexmark.util.sequence.Range getSourceRange();

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence subSequence(int, int);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence subSequence(com.vladsch.flexmark.util.sequence.Range);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence subSequence(int);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence baseSubSequence(int, int);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence endSequence(int, int);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence endSequence(int);

  public abstract char endCharAt(int);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence midSequence(int, int);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence midSequence(int);

  public abstract char midCharAt(int);

  public abstract int indexOf(java.lang.CharSequence);

  public abstract int indexOf(java.lang.CharSequence, int);

  public abstract int indexOf(java.lang.CharSequence, int, int);

  public abstract int indexOf(char);

  public abstract int indexOfAny(char, char);

  public abstract int indexOfAny(char, char, char);

  public abstract int indexOfAny(java.lang.CharSequence);

  public abstract int indexOf(char, int);

  public abstract int indexOfAny(char, char, int);

  public abstract int indexOfAny(char, char, char, int);

  public abstract int indexOfAny(java.lang.CharSequence, int);

  public abstract int indexOf(char, int, int);

  public abstract int indexOfAny(char, char, int, int);

  public abstract int indexOfAny(char, char, char, int, int);

  public abstract int indexOfAny(java.lang.CharSequence, int, int);

  public abstract int indexOfNot(char);

  public abstract int indexOfAnyNot(char, char);

  public abstract int indexOfAnyNot(char, char, char);

  public abstract int indexOfAnyNot(java.lang.CharSequence);

  public abstract int indexOfNot(char, int);

  public abstract int indexOfAnyNot(char, char, int);

  public abstract int indexOfAnyNot(char, char, char, int);

  public abstract int indexOfAnyNot(java.lang.CharSequence, int);

  public abstract int indexOfNot(char, int, int);

  public abstract int indexOfAnyNot(char, char, int, int);

  public abstract int indexOfAnyNot(char, char, char, int, int);

  public abstract int indexOfAnyNot(java.lang.CharSequence, int, int);

  public abstract int lastIndexOf(java.lang.CharSequence);

  public abstract int lastIndexOf(java.lang.CharSequence, int);

  public abstract int lastIndexOf(java.lang.CharSequence, int, int);

  public abstract int lastIndexOf(char);

  public abstract int lastIndexOfAny(char, char);

  public abstract int lastIndexOfAny(char, char, char);

  public abstract int lastIndexOfAny(java.lang.CharSequence);

  public abstract int lastIndexOf(char, int);

  public abstract int lastIndexOfAny(char, char, int);

  public abstract int lastIndexOfAny(char, char, char, int);

  public abstract int lastIndexOfAny(java.lang.CharSequence, int);

  public abstract int lastIndexOf(char, int, int);

  public abstract int lastIndexOfAny(char, char, int, int);

  public abstract int lastIndexOfAny(char, char, char, int, int);

  public abstract int lastIndexOfAny(java.lang.CharSequence, int, int);

  public abstract int lastIndexOfNot(char);

  public abstract int lastIndexOfAnyNot(char, char);

  public abstract int lastIndexOfAnyNot(char, char, char);

  public abstract int lastIndexOfAnyNot(java.lang.CharSequence);

  public abstract int lastIndexOfNot(char, int);

  public abstract int lastIndexOfAnyNot(char, char, int);

  public abstract int lastIndexOfAnyNot(char, char, char, int);

  public abstract int lastIndexOfAnyNot(java.lang.CharSequence, int);

  public abstract int lastIndexOfNot(char, int, int);

  public abstract int lastIndexOfAnyNot(char, char, int, int);

  public abstract int lastIndexOfAnyNot(char, char, char, int, int);

  public abstract int lastIndexOfAnyNot(java.lang.CharSequence, int, int);

  public abstract int countLeading(java.lang.CharSequence);

  public abstract int countLeadingNot(java.lang.CharSequence);

  public abstract int countLeading(java.lang.CharSequence, int);

  public abstract int countLeadingNot(java.lang.CharSequence, int);

  public abstract int countLeading(java.lang.CharSequence, int, int);

  public abstract int countLeadingNot(java.lang.CharSequence, int, int);

  public abstract int countTrailing(java.lang.CharSequence);

  public abstract int countTrailingNot(java.lang.CharSequence);

  public abstract int countTrailing(java.lang.CharSequence, int);

  public abstract int countTrailingNot(java.lang.CharSequence, int);

  public abstract int countTrailing(java.lang.CharSequence, int, int);

  public abstract int countTrailingNot(java.lang.CharSequence, int, int);

  public abstract int countLeading(char);

  public abstract int countLeadingNot(char);

  public abstract int countLeading(char, int);

  public abstract int countLeadingNot(char, int);

  public abstract int countLeading(char, int, int);

  public abstract int countLeadingNot(char, int, int);

  public abstract int countTrailing(char);

  public abstract int countTrailingNot(char);

  public abstract int countTrailing(char, int);

  public abstract int countTrailingNot(char, int);

  public abstract int countTrailing(char, int, int);

  public abstract int countTrailingNot(char, int, int);

  public abstract int countChars(char);

  public abstract int countCharsReversed(char);

  public abstract int countNotChars(char);

  public abstract int countNotCharsReversed(char);

  public abstract int countChars(char, int);

  public abstract int countCharsReversed(char, int);

  public abstract int countNotChars(char, int);

  public abstract int countNotCharsReversed(char, int);

  public abstract int countChars(char, int, int);

  public abstract int countNotChars(char, int, int);

  public abstract int countCharsReversed(char, int, int);

  public abstract int countNotCharsReversed(char, int, int);

  public abstract int countChars(java.lang.CharSequence);

  public abstract int countCharsReversed(java.lang.CharSequence);

  public abstract int countNotChars(java.lang.CharSequence);

  public abstract int countNotCharsReversed(java.lang.CharSequence);

  public abstract int countChars(java.lang.CharSequence, int);

  public abstract int countCharsReversed(java.lang.CharSequence, int);

  public abstract int countNotChars(java.lang.CharSequence, int);

  public abstract int countNotCharsReversed(java.lang.CharSequence, int);

  public abstract int countChars(java.lang.CharSequence, int, int);

  public abstract int countNotChars(java.lang.CharSequence, int, int);

  public abstract int countCharsReversed(java.lang.CharSequence, int, int);

  public abstract int countNotCharsReversed(java.lang.CharSequence, int, int);

  public abstract int countLeadingColumns(int, java.lang.CharSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence trimStart(java.lang.CharSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence trimEnd(java.lang.CharSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence trim(java.lang.CharSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence trimStart();

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence trimEnd();

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence trim();

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence trimEOL();

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence trimmedStart(java.lang.CharSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence trimmedEnd(java.lang.CharSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence trimmedStart();

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence trimmedEnd();

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence trimmedEOL();

  public abstract int eolLength();

  public abstract int eolLength(int);

  public abstract boolean isEmpty();

  public abstract boolean isBlank();

  public abstract boolean isNull();

  public abstract boolean isNotNull();

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence ifNull(com.vladsch.flexmark.util.sequence.BasedSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence ifNullEmptyAfter(com.vladsch.flexmark.util.sequence.BasedSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence ifNullEmptyBefore(com.vladsch.flexmark.util.sequence.BasedSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence nullIfEmpty();

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence nullIfBlank();

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence nullIf(boolean);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence nullIf(java.lang.CharSequence...);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence nullIfNot(java.lang.CharSequence...);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence nullIfStartsWith(java.lang.CharSequence...);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence nullIfStartsWithNot(java.lang.CharSequence...);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence nullIfEndsWith(java.lang.CharSequence...);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence nullIfEndsWithNot(java.lang.CharSequence...);

  public abstract int endOfDelimitedBy(java.lang.CharSequence, int);

  public abstract int endOfDelimitedByAny(java.lang.CharSequence, int);

  public abstract int endOfDelimitedByAnyNot(java.lang.CharSequence, int);

  public abstract int startOfDelimitedBy(java.lang.CharSequence, int);

  public abstract int startOfDelimitedByAny(java.lang.CharSequence, int);

  public abstract int startOfDelimitedByAnyNot(java.lang.CharSequence, int);

  public abstract int endOfLine(int);

  public abstract int endOfLineAnyEOL(int);

  public abstract int startOfLine(int);

  public abstract int startOfLineAnyEOL(int);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence lineAt(int);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence lineAtAnyEOL(int);

  public abstract java.lang.String unescape();

  public abstract java.lang.String unescapeNoEntities();

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence unescape(com.vladsch.flexmark.util.sequence.ReplacedTextMapper);

  public abstract java.lang.String normalizeEOL();

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence normalizeEOL(com.vladsch.flexmark.util.sequence.ReplacedTextMapper);

  public abstract java.lang.String normalizeEndWithEOL();

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence normalizeEndWithEOL(com.vladsch.flexmark.util.sequence.ReplacedTextMapper);

  public abstract boolean matches(java.lang.CharSequence);

  public abstract boolean matchesIgnoreCase(java.lang.CharSequence);

  public abstract boolean equalsIgnoreCase(java.lang.CharSequence);

  public abstract boolean matches(java.lang.CharSequence, boolean);

  public abstract boolean equals(java.lang.Object, boolean);

  public abstract boolean matchChars(java.lang.CharSequence);

  public abstract boolean matchCharsIgnoreCase(java.lang.CharSequence);

  public abstract boolean matchChars(java.lang.CharSequence, boolean);

  public abstract boolean matchChars(java.lang.CharSequence, int);

  public abstract boolean matchCharsIgnoreCase(java.lang.CharSequence, int);

  public abstract boolean matchChars(java.lang.CharSequence, int, boolean);

  public abstract boolean matchCharsReversed(java.lang.CharSequence, int);

  public abstract boolean matchCharsReversedIgnoreCase(java.lang.CharSequence, int);

  public abstract boolean matchCharsReversed(java.lang.CharSequence, int, boolean);

  public abstract boolean endsWith(java.lang.CharSequence);

  public abstract boolean endsWithIgnoreCase(java.lang.CharSequence);

  public abstract boolean endsWith(java.lang.CharSequence, boolean);

  public abstract boolean startsWith(java.lang.CharSequence);

  public abstract boolean startsWithIgnoreCase(java.lang.CharSequence);

  public abstract boolean startsWith(java.lang.CharSequence, boolean);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence removeSuffix(java.lang.CharSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence removeSuffixIgnoreCase(java.lang.CharSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence removeSuffix(java.lang.CharSequence, boolean);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence removePrefix(java.lang.CharSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence removePrefixIgnoreCase(java.lang.CharSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence removePrefix(java.lang.CharSequence, boolean);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence removeProperSuffix(java.lang.CharSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence removeProperSuffixIgnoreCase(java.lang.CharSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence removeProperSuffix(java.lang.CharSequence, boolean);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence removeProperPrefix(java.lang.CharSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence removeProperPrefixIgnoreCase(java.lang.CharSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence removeProperPrefix(java.lang.CharSequence, boolean);

  public abstract com.vladsch.flexmark.util.sequence.MappedSequence toLowerCase();

  public abstract com.vladsch.flexmark.util.sequence.MappedSequence toUpperCase();

  public abstract com.vladsch.flexmark.util.sequence.MappedSequence toLowerCase(java.util.Locale);

  public abstract com.vladsch.flexmark.util.sequence.MappedSequence toUpperCase(java.util.Locale);

  public abstract com.vladsch.flexmark.util.sequence.MappedSequence toMapped(com.vladsch.flexmark.util.mappers.CharMapper);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence trimTailBlankLines();

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence trimLeadBlankLines();

  public abstract java.lang.String toVisibleWhitespaceString();

  public abstract boolean isContinuedBy(com.vladsch.flexmark.util.sequence.BasedSequence);

  public abstract boolean isContinuationOf(com.vladsch.flexmark.util.sequence.BasedSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence spliceAtEnd(com.vladsch.flexmark.util.sequence.BasedSequence);

  public abstract boolean containsAllOf(com.vladsch.flexmark.util.sequence.BasedSequence);

  public abstract boolean containsSomeOf(com.vladsch.flexmark.util.sequence.BasedSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence prefixOf(com.vladsch.flexmark.util.sequence.BasedSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence suffixOf(com.vladsch.flexmark.util.sequence.BasedSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence intersect(com.vladsch.flexmark.util.sequence.BasedSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence[] split(char, int, int, java.lang.String);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence[] split(char);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence[] split(char, int);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence[] split(char, int, int);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence[] split(java.lang.CharSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence[] split(java.lang.CharSequence, int);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence[] split(java.lang.CharSequence, int, int);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence[] split(java.lang.CharSequence, int, int, java.lang.String);

  public abstract int[] indexOfAll(java.lang.CharSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence replace(java.lang.CharSequence, java.lang.CharSequence);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence appendTo(java.lang.StringBuilder);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence appendTo(java.lang.StringBuilder, int);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence appendTo(java.lang.StringBuilder, int, int);

  public abstract com.vladsch.flexmark.util.sequence.BasedSequence append(java.lang.CharSequence...);

  static {};
    Code:
       0: new           #2                  // class com/vladsch/flexmark/util/sequence/BasedSequence$EmptyBasedSequence
       3: dup
       4: invokespecial #3                  // Method com/vladsch/flexmark/util/sequence/BasedSequence$EmptyBasedSequence."<init>":()V
       7: putstatic     #4                  // Field NULL:Lcom/vladsch/flexmark/util/sequence/BasedSequence;
      10: ldc           #5                  // String \n
      12: invokestatic  #6                  // Method com/vladsch/flexmark/util/sequence/CharSubSequence.of:(Ljava/lang/CharSequence;)Lcom/vladsch/flexmark/util/sequence/CharSubSequence;
      15: putstatic     #7                  // Field EOL:Lcom/vladsch/flexmark/util/sequence/BasedSequence;
      18: ldc           #8                  // String
      20: invokestatic  #6                  // Method com/vladsch/flexmark/util/sequence/CharSubSequence.of:(Ljava/lang/CharSequence;)Lcom/vladsch/flexmark/util/sequence/CharSubSequence;
      23: putstatic     #9                  // Field SPACE:Lcom/vladsch/flexmark/util/sequence/BasedSequence;
      26: new           #10                 // class java/util/ArrayList
      29: dup
      30: invokespecial #11                 // Method java/util/ArrayList."<init>":()V
      33: putstatic     #12                 // Field EMPTY_LIST:Ljava/util/List;
      36: iconst_0
      37: anewarray     #1                  // class com/vladsch/flexmark/util/sequence/BasedSequence
      40: putstatic     #13                 // Field EMPTY_ARRAY:[Lcom/vladsch/flexmark/util/sequence/BasedSequence;
      43: ldc           #14                 // String \r\n
      45: iconst_1
      46: invokevirtual #15                 // Method java/lang/String.charAt:(I)C
      49: putstatic     #16                 // Field EOL_CHAR:C
      52: ldc           #14                 // String \r\n
      54: iconst_0
      55: invokevirtual #15                 // Method java/lang/String.charAt:(I)C
      58: putstatic     #17                 // Field EOL_CHAR1:C
      61: ldc           #14                 // String \r\n
      63: iconst_1
      64: invokevirtual #15                 // Method java/lang/String.charAt:(I)C
      67: putstatic     #18                 // Field EOL_CHAR2:C
      70: return
}
