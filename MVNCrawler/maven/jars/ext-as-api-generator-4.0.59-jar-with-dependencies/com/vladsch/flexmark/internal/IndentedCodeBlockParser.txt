Compiled from "IndentedCodeBlockParser.java"
public class com.vladsch.flexmark.internal.IndentedCodeBlockParser extends com.vladsch.flexmark.parser.block.AbstractBlockParser {
  private final com.vladsch.flexmark.ast.IndentedCodeBlock block;

  private com.vladsch.flexmark.ast.BlockContent content;

  private boolean trimTrailingBlankLines;

  private final boolean codeContentBlock;

  public com.vladsch.flexmark.internal.IndentedCodeBlockParser(com.vladsch.flexmark.util.options.DataHolder);
    Code:
       0: aload_0
       1: invokespecial #1                  // Method com/vladsch/flexmark/parser/block/AbstractBlockParser."<init>":()V
       4: aload_0
       5: new           #2                  // class com/vladsch/flexmark/ast/IndentedCodeBlock
       8: dup
       9: invokespecial #3                  // Method com/vladsch/flexmark/ast/IndentedCodeBlock."<init>":()V
      12: putfield      #4                  // Field block:Lcom/vladsch/flexmark/ast/IndentedCodeBlock;
      15: aload_0
      16: new           #5                  // class com/vladsch/flexmark/ast/BlockContent
      19: dup
      20: invokespecial #6                  // Method com/vladsch/flexmark/ast/BlockContent."<init>":()V
      23: putfield      #7                  // Field content:Lcom/vladsch/flexmark/ast/BlockContent;
      26: aload_0
      27: aload_1
      28: getstatic     #8                  // Field com/vladsch/flexmark/parser/Parser.INDENTED_CODE_NO_TRAILING_BLANK_LINES:Lcom/vladsch/flexmark/util/options/DataKey;
      31: invokeinterface #9,  2            // InterfaceMethod com/vladsch/flexmark/util/options/DataHolder.get:(Lcom/vladsch/flexmark/util/options/DataKey;)Ljava/lang/Object;
      36: checkcast     #10                 // class java/lang/Boolean
      39: invokevirtual #11                 // Method java/lang/Boolean.booleanValue:()Z
      42: putfield      #12                 // Field trimTrailingBlankLines:Z
      45: aload_0
      46: aload_1
      47: getstatic     #13                 // Field com/vladsch/flexmark/parser/Parser.FENCED_CODE_CONTENT_BLOCK:Lcom/vladsch/flexmark/util/options/DataKey;
      50: invokeinterface #9,  2            // InterfaceMethod com/vladsch/flexmark/util/options/DataHolder.get:(Lcom/vladsch/flexmark/util/options/DataKey;)Ljava/lang/Object;
      55: checkcast     #10                 // class java/lang/Boolean
      58: invokevirtual #11                 // Method java/lang/Boolean.booleanValue:()Z
      61: putfield      #14                 // Field codeContentBlock:Z
      64: return

  public com.vladsch.flexmark.ast.Block getBlock();
    Code:
       0: aload_0
       1: getfield      #4                  // Field block:Lcom/vladsch/flexmark/ast/IndentedCodeBlock;
       4: areturn

  public com.vladsch.flexmark.parser.block.BlockContinue tryContinue(com.vladsch.flexmark.parser.block.ParserState);
    Code:
       0: aload_1
       1: invokeinterface #15,  1           // InterfaceMethod com/vladsch/flexmark/parser/block/ParserState.getIndent:()I
       6: aload_1
       7: invokeinterface #16,  1           // InterfaceMethod com/vladsch/flexmark/parser/block/ParserState.getParsing:()Lcom/vladsch/flexmark/ast/util/Parsing;
      12: getfield      #17                 // Field com/vladsch/flexmark/ast/util/Parsing.CODE_BLOCK_INDENT:I
      15: if_icmplt     38
      18: aload_1
      19: invokeinterface #18,  1           // InterfaceMethod com/vladsch/flexmark/parser/block/ParserState.getColumn:()I
      24: aload_1
      25: invokeinterface #16,  1           // InterfaceMethod com/vladsch/flexmark/parser/block/ParserState.getParsing:()Lcom/vladsch/flexmark/ast/util/Parsing;
      30: getfield      #17                 // Field com/vladsch/flexmark/ast/util/Parsing.CODE_BLOCK_INDENT:I
      33: iadd
      34: invokestatic  #19                 // Method com/vladsch/flexmark/parser/block/BlockContinue.atColumn:(I)Lcom/vladsch/flexmark/parser/block/BlockContinue;
      37: areturn
      38: aload_1
      39: invokeinterface #20,  1           // InterfaceMethod com/vladsch/flexmark/parser/block/ParserState.isBlank:()Z
      44: ifeq          57
      47: aload_1
      48: invokeinterface #21,  1           // InterfaceMethod com/vladsch/flexmark/parser/block/ParserState.getNextNonSpaceIndex:()I
      53: invokestatic  #22                 // Method com/vladsch/flexmark/parser/block/BlockContinue.atIndex:(I)Lcom/vladsch/flexmark/parser/block/BlockContinue;
      56: areturn
      57: invokestatic  #23                 // Method com/vladsch/flexmark/parser/block/BlockContinue.none:()Lcom/vladsch/flexmark/parser/block/BlockContinue;
      60: areturn

  public void addLine(com.vladsch.flexmark.parser.block.ParserState, com.vladsch.flexmark.util.sequence.BasedSequence);
    Code:
       0: aload_0
       1: getfield      #7                  // Field content:Lcom/vladsch/flexmark/ast/BlockContent;
       4: aload_2
       5: aload_1
       6: invokeinterface #15,  1           // InterfaceMethod com/vladsch/flexmark/parser/block/ParserState.getIndent:()I
      11: invokevirtual #24                 // Method com/vladsch/flexmark/ast/BlockContent.add:(Lcom/vladsch/flexmark/util/sequence/BasedSequence;I)V
      14: return

  public void closeBlock(com.vladsch.flexmark.parser.block.ParserState);
    Code:
       0: aload_0
       1: getfield      #12                 // Field trimTrailingBlankLines:Z
       4: ifeq          114
       7: iconst_0
       8: istore_2
       9: aload_0
      10: getfield      #7                  // Field content:Lcom/vladsch/flexmark/ast/BlockContent;
      13: invokevirtual #25                 // Method com/vladsch/flexmark/ast/BlockContent.getLines:()Ljava/util/List;
      16: astore_3
      17: new           #26                 // class com/vladsch/flexmark/util/collection/iteration/Reverse
      20: dup
      21: aload_3
      22: invokespecial #27                 // Method com/vladsch/flexmark/util/collection/iteration/Reverse."<init>":(Ljava/util/List;)V
      25: invokevirtual #28                 // Method com/vladsch/flexmark/util/collection/iteration/Reverse.iterator:()Lcom/vladsch/flexmark/util/collection/iteration/ReversibleIterator;
      28: astore        4
      30: aload         4
      32: invokeinterface #29,  1           // InterfaceMethod java/util/Iterator.hasNext:()Z
      37: ifeq          71
      40: aload         4
      42: invokeinterface #30,  1           // InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;
      47: checkcast     #31                 // class com/vladsch/flexmark/util/sequence/BasedSequence
      50: astore        5
      52: aload         5
      54: invokeinterface #32,  1           // InterfaceMethod com/vladsch/flexmark/util/sequence/BasedSequence.isBlank:()Z
      59: ifne          65
      62: goto          71
      65: iinc          2, 1
      68: goto          30
      71: iload_2
      72: ifle          100
      75: aload_0
      76: getfield      #4                  // Field block:Lcom/vladsch/flexmark/ast/IndentedCodeBlock;
      79: aload_3
      80: iconst_0
      81: aload_3
      82: invokeinterface #33,  1           // InterfaceMethod java/util/List.size:()I
      87: iload_2
      88: isub
      89: invokeinterface #34,  3           // InterfaceMethod java/util/List.subList:(II)Ljava/util/List;
      94: invokevirtual #35                 // Method com/vladsch/flexmark/ast/IndentedCodeBlock.setContent:(Ljava/util/List;)V
      97: goto          111
     100: aload_0
     101: getfield      #4                  // Field block:Lcom/vladsch/flexmark/ast/IndentedCodeBlock;
     104: aload_0
     105: getfield      #7                  // Field content:Lcom/vladsch/flexmark/ast/BlockContent;
     108: invokevirtual #36                 // Method com/vladsch/flexmark/ast/IndentedCodeBlock.setContent:(Lcom/vladsch/flexmark/ast/BlockContent;)V
     111: goto          125
     114: aload_0
     115: getfield      #4                  // Field block:Lcom/vladsch/flexmark/ast/IndentedCodeBlock;
     118: aload_0
     119: getfield      #7                  // Field content:Lcom/vladsch/flexmark/ast/BlockContent;
     122: invokevirtual #36                 // Method com/vladsch/flexmark/ast/IndentedCodeBlock.setContent:(Lcom/vladsch/flexmark/ast/BlockContent;)V
     125: aload_0
     126: getfield      #14                 // Field codeContentBlock:Z
     129: ifeq          162
     132: new           #37                 // class com/vladsch/flexmark/ast/CodeBlock
     135: dup
     136: aload_0
     137: getfield      #4                  // Field block:Lcom/vladsch/flexmark/ast/IndentedCodeBlock;
     140: invokevirtual #38                 // Method com/vladsch/flexmark/ast/IndentedCodeBlock.getChars:()Lcom/vladsch/flexmark/util/sequence/BasedSequence;
     143: aload_0
     144: getfield      #4                  // Field block:Lcom/vladsch/flexmark/ast/IndentedCodeBlock;
     147: invokevirtual #39                 // Method com/vladsch/flexmark/ast/IndentedCodeBlock.getContentLines:()Ljava/util/List;
     150: invokespecial #40                 // Method com/vladsch/flexmark/ast/CodeBlock."<init>":(Lcom/vladsch/flexmark/util/sequence/BasedSequence;Ljava/util/List;)V
     153: astore_2
     154: aload_0
     155: getfield      #4                  // Field block:Lcom/vladsch/flexmark/ast/IndentedCodeBlock;
     158: aload_2
     159: invokevirtual #41                 // Method com/vladsch/flexmark/ast/IndentedCodeBlock.appendChild:(Lcom/vladsch/flexmark/ast/Node;)V
     162: aload_0
     163: aconst_null
     164: putfield      #7                  // Field content:Lcom/vladsch/flexmark/ast/BlockContent;
     167: return
}
