Compiled from "Delimiter.java"
public class com.vladsch.flexmark.internal.Delimiter implements com.vladsch.flexmark.parser.delimiter.DelimiterRun {
  final com.vladsch.flexmark.ast.Text node;

  final com.vladsch.flexmark.util.sequence.BasedSequence input;

  final char delimiterChar;

  int index;

  final boolean canOpen;

  final boolean canClose;

  boolean matched;

  com.vladsch.flexmark.internal.Delimiter previous;

  com.vladsch.flexmark.internal.Delimiter next;

  int numDelims;

  public com.vladsch.flexmark.parser.delimiter.DelimiterRun getPrevious();
    Code:
       0: aload_0
       1: getfield      #1                  // Field previous:Lcom/vladsch/flexmark/internal/Delimiter;
       4: areturn

  public com.vladsch.flexmark.parser.delimiter.DelimiterRun getNext();
    Code:
       0: aload_0
       1: getfield      #2                  // Field next:Lcom/vladsch/flexmark/internal/Delimiter;
       4: areturn

  public char getDelimiterChar();
    Code:
       0: aload_0
       1: getfield      #3                  // Field delimiterChar:C
       4: ireturn

  public boolean isMatched();
    Code:
       0: aload_0
       1: getfield      #4                  // Field matched:Z
       4: ireturn

  public int getNumDelims();
    Code:
       0: aload_0
       1: getfield      #5                  // Field numDelims:I
       4: ireturn

  public com.vladsch.flexmark.ast.Text getNode();
    Code:
       0: aload_0
       1: getfield      #6                  // Field node:Lcom/vladsch/flexmark/ast/Text;
       4: areturn

  public com.vladsch.flexmark.util.sequence.BasedSequence getInput();
    Code:
       0: aload_0
       1: getfield      #7                  // Field input:Lcom/vladsch/flexmark/util/sequence/BasedSequence;
       4: areturn

  public int getStartIndex();
    Code:
       0: aload_0
       1: getfield      #8                  // Field index:I
       4: ireturn

  public int getEndIndex();
    Code:
       0: aload_0
       1: getfield      #8                  // Field index:I
       4: aload_0
       5: getfield      #5                  // Field numDelims:I
       8: iadd
       9: ireturn

  public int getIndex();
    Code:
       0: aload_0
       1: getfield      #8                  // Field index:I
       4: ireturn

  public void setIndex(int);
    Code:
       0: aload_0
       1: iload_1
       2: putfield      #8                  // Field index:I
       5: return

  public com.vladsch.flexmark.util.sequence.BasedSequence getTailChars(int);
    Code:
       0: aload_0
       1: getfield      #7                  // Field input:Lcom/vladsch/flexmark/util/sequence/BasedSequence;
       4: aload_0
       5: invokevirtual #9                  // Method getEndIndex:()I
       8: iload_1
       9: isub
      10: aload_0
      11: invokevirtual #9                  // Method getEndIndex:()I
      14: invokeinterface #10,  3           // InterfaceMethod com/vladsch/flexmark/util/sequence/BasedSequence.subSequence:(II)Lcom/vladsch/flexmark/util/sequence/BasedSequence;
      19: areturn

  public com.vladsch.flexmark.util.sequence.BasedSequence getLeadChars(int);
    Code:
       0: aload_0
       1: getfield      #7                  // Field input:Lcom/vladsch/flexmark/util/sequence/BasedSequence;
       4: aload_0
       5: invokevirtual #11                 // Method getStartIndex:()I
       8: aload_0
       9: invokevirtual #11                 // Method getStartIndex:()I
      12: iload_1
      13: iadd
      14: invokeinterface #10,  3           // InterfaceMethod com/vladsch/flexmark/util/sequence/BasedSequence.subSequence:(II)Lcom/vladsch/flexmark/util/sequence/BasedSequence;
      19: areturn

  com.vladsch.flexmark.internal.Delimiter(com.vladsch.flexmark.util.sequence.BasedSequence, com.vladsch.flexmark.ast.Text, char, boolean, boolean, com.vladsch.flexmark.internal.Delimiter, int);
    Code:
       0: aload_0
       1: invokespecial #12                 // Method java/lang/Object."<init>":()V
       4: aload_0
       5: iconst_0
       6: putfield      #4                  // Field matched:Z
       9: aload_0
      10: iconst_1
      11: putfield      #5                  // Field numDelims:I
      14: aload_0
      15: aload_1
      16: putfield      #7                  // Field input:Lcom/vladsch/flexmark/util/sequence/BasedSequence;
      19: aload_0
      20: aload_2
      21: putfield      #6                  // Field node:Lcom/vladsch/flexmark/ast/Text;
      24: aload_0
      25: iload_3
      26: putfield      #3                  // Field delimiterChar:C
      29: aload_0
      30: iload         4
      32: putfield      #13                 // Field canOpen:Z
      35: aload_0
      36: iload         5
      38: putfield      #14                 // Field canClose:Z
      41: aload_0
      42: aload         6
      44: putfield      #1                  // Field previous:Lcom/vladsch/flexmark/internal/Delimiter;
      47: aload_0
      48: iload         7
      50: putfield      #8                  // Field index:I
      53: return

  com.vladsch.flexmark.ast.Text getPreviousNonDelimiterTextNode();
    Code:
       0: aload_0
       1: getfield      #6                  // Field node:Lcom/vladsch/flexmark/ast/Text;
       4: invokevirtual #15                 // Method com/vladsch/flexmark/ast/Text.getPrevious:()Lcom/vladsch/flexmark/ast/Node;
       7: astore_1
       8: aload_1
       9: instanceof    #16                 // class com/vladsch/flexmark/ast/Text
      12: ifeq          38
      15: aload_0
      16: getfield      #1                  // Field previous:Lcom/vladsch/flexmark/internal/Delimiter;
      19: ifnull        33
      22: aload_0
      23: getfield      #1                  // Field previous:Lcom/vladsch/flexmark/internal/Delimiter;
      26: getfield      #6                  // Field node:Lcom/vladsch/flexmark/ast/Text;
      29: aload_1
      30: if_acmpeq     38
      33: aload_1
      34: checkcast     #16                 // class com/vladsch/flexmark/ast/Text
      37: areturn
      38: aconst_null
      39: areturn

  com.vladsch.flexmark.ast.Text getNextNonDelimiterTextNode();
    Code:
       0: aload_0
       1: getfield      #6                  // Field node:Lcom/vladsch/flexmark/ast/Text;
       4: invokevirtual #17                 // Method com/vladsch/flexmark/ast/Text.getNext:()Lcom/vladsch/flexmark/ast/Node;
       7: astore_1
       8: aload_1
       9: instanceof    #16                 // class com/vladsch/flexmark/ast/Text
      12: ifeq          38
      15: aload_0
      16: getfield      #2                  // Field next:Lcom/vladsch/flexmark/internal/Delimiter;
      19: ifnull        33
      22: aload_0
      23: getfield      #2                  // Field next:Lcom/vladsch/flexmark/internal/Delimiter;
      26: getfield      #6                  // Field node:Lcom/vladsch/flexmark/ast/Text;
      29: aload_1
      30: if_acmpeq     38
      33: aload_1
      34: checkcast     #16                 // class com/vladsch/flexmark/ast/Text
      37: areturn
      38: aconst_null
      39: areturn

  public void moveNodesBetweenDelimitersTo(com.vladsch.flexmark.ast.DelimitedNode, com.vladsch.flexmark.internal.Delimiter);
    Code:
       0: aload_0
       1: invokevirtual #18                 // Method getNode:()Lcom/vladsch/flexmark/ast/Text;
       4: invokevirtual #17                 // Method com/vladsch/flexmark/ast/Text.getNext:()Lcom/vladsch/flexmark/ast/Node;
       7: astore_3
       8: aload_3
       9: ifnull        40
      12: aload_3
      13: aload_2
      14: invokevirtual #18                 // Method getNode:()Lcom/vladsch/flexmark/ast/Text;
      17: if_acmpeq     40
      20: aload_3
      21: invokevirtual #19                 // Method com/vladsch/flexmark/ast/Node.getNext:()Lcom/vladsch/flexmark/ast/Node;
      24: astore        4
      26: aload_1
      27: checkcast     #20                 // class com/vladsch/flexmark/ast/Node
      30: aload_3
      31: invokevirtual #21                 // Method com/vladsch/flexmark/ast/Node.appendChild:(Lcom/vladsch/flexmark/ast/Node;)V
      34: aload         4
      36: astore_3
      37: goto          8
      40: aload_1
      41: aload_0
      42: getfield      #7                  // Field input:Lcom/vladsch/flexmark/util/sequence/BasedSequence;
      45: aload_0
      46: invokevirtual #9                  // Method getEndIndex:()I
      49: aload_2
      50: invokevirtual #11                 // Method getStartIndex:()I
      53: invokeinterface #10,  3           // InterfaceMethod com/vladsch/flexmark/util/sequence/BasedSequence.subSequence:(II)Lcom/vladsch/flexmark/util/sequence/BasedSequence;
      58: invokeinterface #22,  2           // InterfaceMethod com/vladsch/flexmark/ast/DelimitedNode.setText:(Lcom/vladsch/flexmark/util/sequence/BasedSequence;)V
      63: aload_0
      64: invokevirtual #18                 // Method getNode:()Lcom/vladsch/flexmark/ast/Text;
      67: aload_1
      68: checkcast     #20                 // class com/vladsch/flexmark/ast/Node
      71: invokevirtual #23                 // Method com/vladsch/flexmark/ast/Text.insertAfter:(Lcom/vladsch/flexmark/ast/Node;)V
      74: return

  public void convertDelimitersToText(int, com.vladsch.flexmark.internal.Delimiter);
    Code:
       0: new           #16                 // class com/vladsch/flexmark/ast/Text
       3: dup
       4: invokespecial #24                 // Method com/vladsch/flexmark/ast/Text."<init>":()V
       7: astore_3
       8: aload_3
       9: aload_0
      10: iload_1
      11: invokevirtual #25                 // Method getTailChars:(I)Lcom/vladsch/flexmark/util/sequence/BasedSequence;
      14: invokevirtual #26                 // Method com/vladsch/flexmark/ast/Text.setChars:(Lcom/vladsch/flexmark/util/sequence/BasedSequence;)V
      17: new           #16                 // class com/vladsch/flexmark/ast/Text
      20: dup
      21: invokespecial #24                 // Method com/vladsch/flexmark/ast/Text."<init>":()V
      24: astore        4
      26: aload         4
      28: aload_2
      29: iload_1
      30: invokevirtual #27                 // Method getLeadChars:(I)Lcom/vladsch/flexmark/util/sequence/BasedSequence;
      33: invokevirtual #26                 // Method com/vladsch/flexmark/ast/Text.setChars:(Lcom/vladsch/flexmark/util/sequence/BasedSequence;)V
      36: aload_0
      37: invokevirtual #18                 // Method getNode:()Lcom/vladsch/flexmark/ast/Text;
      40: aload_3
      41: invokevirtual #23                 // Method com/vladsch/flexmark/ast/Text.insertAfter:(Lcom/vladsch/flexmark/ast/Node;)V
      44: aload_2
      45: invokevirtual #18                 // Method getNode:()Lcom/vladsch/flexmark/ast/Text;
      48: aload         4
      50: invokevirtual #28                 // Method com/vladsch/flexmark/ast/Text.insertBefore:(Lcom/vladsch/flexmark/ast/Node;)V
      53: return

  public boolean canOpen();
    Code:
       0: aload_0
       1: getfield      #13                 // Field canOpen:Z
       4: ireturn

  public boolean canClose();
    Code:
       0: aload_0
       1: getfield      #14                 // Field canClose:Z
       4: ireturn

  public int length();
    Code:
       0: aload_0
       1: getfield      #5                  // Field numDelims:I
       4: ireturn
}
