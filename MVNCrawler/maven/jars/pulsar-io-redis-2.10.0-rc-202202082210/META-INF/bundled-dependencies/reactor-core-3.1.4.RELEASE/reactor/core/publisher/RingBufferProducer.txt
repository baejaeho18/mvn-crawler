Compiled from "RingBuffer.java"
abstract class reactor.core.publisher.RingBufferProducer {
  static final java.util.concurrent.atomic.AtomicReferenceFieldUpdater<reactor.core.publisher.RingBufferProducer, reactor.core.publisher.RingBuffer$Sequence[]> SEQUENCE_UPDATER;

  final java.lang.Runnable spinObserver;

  final int bufferSize;

  final reactor.util.concurrent.WaitStrategy waitStrategy;

  final reactor.core.publisher.RingBuffer$Sequence cursor;

  volatile reactor.core.publisher.RingBuffer$Sequence[] gatingSequences;

  reactor.core.publisher.RingBufferProducer(int, reactor.util.concurrent.WaitStrategy, java.lang.Runnable);
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: aload_0
       5: ldc2_w        #3                  // long -1l
       8: invokestatic  #5                  // Method reactor/core/publisher/RingBuffer.newSequence:(J)Lreactor/core/publisher/RingBuffer$Sequence;
      11: putfield      #6                  // Field cursor:Lreactor/core/publisher/RingBuffer$Sequence;
      14: aload_0
      15: iconst_0
      16: anewarray     #7                  // class reactor/core/publisher/RingBuffer$Sequence
      19: putfield      #8                  // Field gatingSequences:[Lreactor/core/publisher/RingBuffer$Sequence;
      22: aload_0
      23: aload_3
      24: putfield      #9                  // Field spinObserver:Ljava/lang/Runnable;
      27: aload_0
      28: iload_1
      29: putfield      #10                 // Field bufferSize:I
      32: aload_0
      33: aload_2
      34: putfield      #11                 // Field waitStrategy:Lreactor/util/concurrent/WaitStrategy;
      37: return

  final long getCursor();
    Code:
       0: aload_0
       1: getfield      #6                  // Field cursor:Lreactor/core/publisher/RingBuffer$Sequence;
       4: invokeinterface #12,  1           // InterfaceMethod reactor/core/publisher/RingBuffer$Sequence.getAsLong:()J
       9: lreturn

  final int getBufferSize();
    Code:
       0: aload_0
       1: getfield      #10                 // Field bufferSize:I
       4: ireturn

  final void addGatingSequence(reactor.core.publisher.RingBuffer$Sequence);
    Code:
       0: aload_0
       1: getstatic     #13                 // Field SEQUENCE_UPDATER:Ljava/util/concurrent/atomic/AtomicReferenceFieldUpdater;
       4: aload_1
       5: invokestatic  #14                 // Method reactor/core/publisher/RingBuffer.addSequence:(Ljava/lang/Object;Ljava/util/concurrent/atomic/AtomicReferenceFieldUpdater;Lreactor/core/publisher/RingBuffer$Sequence;)V
       8: return

  boolean removeGatingSequence(reactor.core.publisher.RingBuffer$Sequence);
    Code:
       0: aload_0
       1: getstatic     #13                 // Field SEQUENCE_UPDATER:Ljava/util/concurrent/atomic/AtomicReferenceFieldUpdater;
       4: aload_1
       5: invokestatic  #15                 // Method reactor/core/publisher/RingBuffer.removeSequence:(Ljava/lang/Object;Ljava/util/concurrent/atomic/AtomicReferenceFieldUpdater;Lreactor/core/publisher/RingBuffer$Sequence;)Z
       8: ireturn

  long getMinimumSequence(reactor.core.publisher.RingBuffer$Sequence);
    Code:
       0: aload_1
       1: aload_0
       2: getfield      #8                  // Field gatingSequences:[Lreactor/core/publisher/RingBuffer$Sequence;
       5: aload_0
       6: getfield      #6                  // Field cursor:Lreactor/core/publisher/RingBuffer$Sequence;
       9: invokeinterface #12,  1           // InterfaceMethod reactor/core/publisher/RingBuffer$Sequence.getAsLong:()J
      14: invokestatic  #16                 // Method reactor/core/publisher/RingBuffer.getMinimumSequence:(Lreactor/core/publisher/RingBuffer$Sequence;[Lreactor/core/publisher/RingBuffer$Sequence;J)J
      17: lreturn

  reactor.core.publisher.RingBuffer$Reader newBarrier();
    Code:
       0: new           #17                 // class reactor/core/publisher/RingBuffer$Reader
       3: dup
       4: aload_0
       5: aload_0
       6: getfield      #11                 // Field waitStrategy:Lreactor/util/concurrent/WaitStrategy;
       9: aload_0
      10: getfield      #6                  // Field cursor:Lreactor/core/publisher/RingBuffer$Sequence;
      13: invokespecial #18                 // Method reactor/core/publisher/RingBuffer$Reader."<init>":(Lreactor/core/publisher/RingBufferProducer;Lreactor/util/concurrent/WaitStrategy;Lreactor/core/publisher/RingBuffer$Sequence;)V
      16: areturn

  abstract long getHighestPublishedSequence(long, long);

  abstract long getPending();

  abstract long next();

  abstract long next(int);

  abstract void publish(long);

  reactor.core.publisher.RingBuffer$Sequence[] getGatingSequences();
    Code:
       0: aload_0
       1: getfield      #8                  // Field gatingSequences:[Lreactor/core/publisher/RingBuffer$Sequence;
       4: areturn

  static {};
    Code:
       0: ldc           #19                 // class reactor/core/publisher/RingBufferProducer
       2: ldc           #20                 // class "[Lreactor/core/publisher/RingBuffer$Sequence;"
       4: ldc           #21                 // String gatingSequences
       6: invokestatic  #22                 // Method java/util/concurrent/atomic/AtomicReferenceFieldUpdater.newUpdater:(Ljava/lang/Class;Ljava/lang/Class;Ljava/lang/String;)Ljava/util/concurrent/atomic/AtomicReferenceFieldUpdater;
       9: putstatic     #13                 // Field SEQUENCE_UPDATER:Ljava/util/concurrent/atomic/AtomicReferenceFieldUpdater;
      12: return
}
