Compiled from "FluxOnBackpressureBufferTimeout.java"
final class reactor.core.publisher.FluxOnBackpressureBufferTimeout<O> extends reactor.core.publisher.FluxOperator<O, O> {
  private static final reactor.util.Logger LOGGER;

  final java.time.Duration ttl;

  final reactor.core.scheduler.Scheduler ttlScheduler;

  final int bufferSize;

  final java.util.function.Consumer<? super O> onBufferEviction;

  reactor.core.publisher.FluxOnBackpressureBufferTimeout(reactor.core.publisher.Flux<? extends O>, java.time.Duration, reactor.core.scheduler.Scheduler, int, java.util.function.Consumer<? super O>);
    Code:
       0: aload_0
       1: aload_1
       2: invokespecial #2                  // Method reactor/core/publisher/FluxOperator."<init>":(Lreactor/core/publisher/Flux;)V
       5: aload_0
       6: aload_2
       7: putfield      #3                  // Field ttl:Ljava/time/Duration;
      10: aload_0
      11: aload_3
      12: putfield      #4                  // Field ttlScheduler:Lreactor/core/scheduler/Scheduler;
      15: aload_0
      16: iload         4
      18: putfield      #5                  // Field bufferSize:I
      21: aload_0
      22: aload         5
      24: putfield      #6                  // Field onBufferEviction:Ljava/util/function/Consumer;
      27: return

  public void subscribe(reactor.core.CoreSubscriber<? super O>);
    Code:
       0: aload_0
       1: getfield      #7                  // Field source:Lreactor/core/publisher/Flux;
       4: new           #8                  // class reactor/core/publisher/FluxOnBackpressureBufferTimeout$BackpressureBufferTimeoutSubscriber
       7: dup
       8: aload_1
       9: aload_0
      10: getfield      #3                  // Field ttl:Ljava/time/Duration;
      13: aload_0
      14: getfield      #4                  // Field ttlScheduler:Lreactor/core/scheduler/Scheduler;
      17: aload_0
      18: getfield      #5                  // Field bufferSize:I
      21: aload_0
      22: getfield      #6                  // Field onBufferEviction:Ljava/util/function/Consumer;
      25: invokespecial #9                  // Method reactor/core/publisher/FluxOnBackpressureBufferTimeout$BackpressureBufferTimeoutSubscriber."<init>":(Lreactor/core/CoreSubscriber;Ljava/time/Duration;Lreactor/core/scheduler/Scheduler;ILjava/util/function/Consumer;)V
      28: invokevirtual #10                 // Method reactor/core/publisher/Flux.subscribe:(Lreactor/core/CoreSubscriber;)V
      31: return

  public int getPrefetch();
    Code:
       0: ldc           #12                 // int 2147483647
       2: ireturn

  public java.lang.Object scanUnsafe(reactor.core.Scannable$Attr);
    Code:
       0: aload_1
       1: getstatic     #13                 // Field reactor/core/Scannable$Attr.RUN_ON:Lreactor/core/Scannable$Attr;
       4: if_acmpne     12
       7: aload_0
       8: getfield      #4                  // Field ttlScheduler:Lreactor/core/scheduler/Scheduler;
      11: areturn
      12: aload_0
      13: aload_1
      14: invokespecial #14                 // Method reactor/core/publisher/FluxOperator.scanUnsafe:(Lreactor/core/Scannable$Attr;)Ljava/lang/Object;
      17: areturn

  static reactor.util.Logger access$000();
    Code:
       0: getstatic     #1                  // Field LOGGER:Lreactor/util/Logger;
       3: areturn

  static {};
    Code:
       0: ldc           #15                 // class reactor/core/publisher/FluxOnBackpressureBufferTimeout
       2: invokestatic  #16                 // Method reactor/util/Loggers.getLogger:(Ljava/lang/Class;)Lreactor/util/Logger;
       5: putstatic     #1                  // Field LOGGER:Lreactor/util/Logger;
       8: return
}
