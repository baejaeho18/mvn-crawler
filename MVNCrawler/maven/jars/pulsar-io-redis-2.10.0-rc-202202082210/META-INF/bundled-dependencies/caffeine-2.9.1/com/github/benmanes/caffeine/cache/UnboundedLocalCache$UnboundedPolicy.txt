Compiled from "UnboundedLocalCache.java"
final class com.github.benmanes.caffeine.cache.UnboundedLocalCache$UnboundedPolicy<K, V> implements com.github.benmanes.caffeine.cache.Policy<K, V> {
  final com.github.benmanes.caffeine.cache.UnboundedLocalCache<K, V> cache;

  final java.util.function.Function<V, V> transformer;

  com.github.benmanes.caffeine.cache.UnboundedLocalCache$UnboundedPolicy(com.github.benmanes.caffeine.cache.UnboundedLocalCache<K, V>, java.util.function.Function<V, V>);
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: aload_0
       5: aload_2
       6: putfield      #2                  // Field transformer:Ljava/util/function/Function;
       9: aload_0
      10: aload_1
      11: putfield      #3                  // Field cache:Lcom/github/benmanes/caffeine/cache/UnboundedLocalCache;
      14: return

  public boolean isRecordingStats();
    Code:
       0: aload_0
       1: getfield      #3                  // Field cache:Lcom/github/benmanes/caffeine/cache/UnboundedLocalCache;
       4: getfield      #4                  // Field com/github/benmanes/caffeine/cache/UnboundedLocalCache.isRecordingStats:Z
       7: ireturn

  public V getIfPresentQuietly(java.lang.Object);
    Code:
       0: aload_0
       1: getfield      #2                  // Field transformer:Ljava/util/function/Function;
       4: aload_0
       5: getfield      #3                  // Field cache:Lcom/github/benmanes/caffeine/cache/UnboundedLocalCache;
       8: getfield      #5                  // Field com/github/benmanes/caffeine/cache/UnboundedLocalCache.data:Ljava/util/concurrent/ConcurrentHashMap;
      11: aload_1
      12: invokevirtual #6                  // Method java/util/concurrent/ConcurrentHashMap.get:(Ljava/lang/Object;)Ljava/lang/Object;
      15: invokeinterface #7,  2            // InterfaceMethod java/util/function/Function.apply:(Ljava/lang/Object;)Ljava/lang/Object;
      20: areturn

  public java.util.Optional<com.github.benmanes.caffeine.cache.Policy$Eviction<K, V>> eviction();
    Code:
       0: invokestatic  #8                  // Method java/util/Optional.empty:()Ljava/util/Optional;
       3: areturn

  public java.util.Optional<com.github.benmanes.caffeine.cache.Policy$Expiration<K, V>> expireAfterAccess();
    Code:
       0: invokestatic  #8                  // Method java/util/Optional.empty:()Ljava/util/Optional;
       3: areturn

  public java.util.Optional<com.github.benmanes.caffeine.cache.Policy$Expiration<K, V>> expireAfterWrite();
    Code:
       0: invokestatic  #8                  // Method java/util/Optional.empty:()Ljava/util/Optional;
       3: areturn

  public java.util.Optional<com.github.benmanes.caffeine.cache.Policy$Expiration<K, V>> refreshAfterWrite();
    Code:
       0: invokestatic  #8                  // Method java/util/Optional.empty:()Ljava/util/Optional;
       3: areturn
}
