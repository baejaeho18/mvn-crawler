Compiled from "V1NodeStatusFluent.java"
public interface io.kubernetes.client.openapi.models.V1NodeStatusFluent<A extends io.kubernetes.client.openapi.models.V1NodeStatusFluent<A>> extends io.kubernetes.client.fluent.Fluent<A> {
  public abstract A addToAddresses(int, io.kubernetes.client.openapi.models.V1NodeAddress);

  public abstract A setToAddresses(int, io.kubernetes.client.openapi.models.V1NodeAddress);

  public abstract A addToAddresses(io.kubernetes.client.openapi.models.V1NodeAddress...);

  public abstract A addAllToAddresses(java.util.Collection<io.kubernetes.client.openapi.models.V1NodeAddress>);

  public abstract A removeFromAddresses(io.kubernetes.client.openapi.models.V1NodeAddress...);

  public abstract A removeAllFromAddresses(java.util.Collection<io.kubernetes.client.openapi.models.V1NodeAddress>);

  public abstract A removeMatchingFromAddresses(io.kubernetes.client.fluent.Predicate<io.kubernetes.client.openapi.models.V1NodeAddressBuilder>);

  public abstract java.util.List<io.kubernetes.client.openapi.models.V1NodeAddress> getAddresses();

  public abstract java.util.List<io.kubernetes.client.openapi.models.V1NodeAddress> buildAddresses();

  public abstract io.kubernetes.client.openapi.models.V1NodeAddress buildAddress(int);

  public abstract io.kubernetes.client.openapi.models.V1NodeAddress buildFirstAddress();

  public abstract io.kubernetes.client.openapi.models.V1NodeAddress buildLastAddress();

  public abstract io.kubernetes.client.openapi.models.V1NodeAddress buildMatchingAddress(io.kubernetes.client.fluent.Predicate<io.kubernetes.client.openapi.models.V1NodeAddressBuilder>);

  public abstract java.lang.Boolean hasMatchingAddress(io.kubernetes.client.fluent.Predicate<io.kubernetes.client.openapi.models.V1NodeAddressBuilder>);

  public abstract A withAddresses(java.util.List<io.kubernetes.client.openapi.models.V1NodeAddress>);

  public abstract A withAddresses(io.kubernetes.client.openapi.models.V1NodeAddress...);

  public abstract java.lang.Boolean hasAddresses();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$AddressesNested<A> addNewAddress();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$AddressesNested<A> addNewAddressLike(io.kubernetes.client.openapi.models.V1NodeAddress);

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$AddressesNested<A> setNewAddressLike(int, io.kubernetes.client.openapi.models.V1NodeAddress);

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$AddressesNested<A> editAddress(int);

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$AddressesNested<A> editFirstAddress();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$AddressesNested<A> editLastAddress();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$AddressesNested<A> editMatchingAddress(io.kubernetes.client.fluent.Predicate<io.kubernetes.client.openapi.models.V1NodeAddressBuilder>);

  public abstract A addToAllocatable(java.lang.String, io.kubernetes.client.custom.Quantity);

  public abstract A addToAllocatable(java.util.Map<java.lang.String, io.kubernetes.client.custom.Quantity>);

  public abstract A removeFromAllocatable(java.lang.String);

  public abstract A removeFromAllocatable(java.util.Map<java.lang.String, io.kubernetes.client.custom.Quantity>);

  public abstract java.util.Map<java.lang.String, io.kubernetes.client.custom.Quantity> getAllocatable();

  public abstract A withAllocatable(java.util.Map<java.lang.String, io.kubernetes.client.custom.Quantity>);

  public abstract java.lang.Boolean hasAllocatable();

  public abstract A addToCapacity(java.lang.String, io.kubernetes.client.custom.Quantity);

  public abstract A addToCapacity(java.util.Map<java.lang.String, io.kubernetes.client.custom.Quantity>);

  public abstract A removeFromCapacity(java.lang.String);

  public abstract A removeFromCapacity(java.util.Map<java.lang.String, io.kubernetes.client.custom.Quantity>);

  public abstract java.util.Map<java.lang.String, io.kubernetes.client.custom.Quantity> getCapacity();

  public abstract A withCapacity(java.util.Map<java.lang.String, io.kubernetes.client.custom.Quantity>);

  public abstract java.lang.Boolean hasCapacity();

  public abstract A addToConditions(int, io.kubernetes.client.openapi.models.V1NodeCondition);

  public abstract A setToConditions(int, io.kubernetes.client.openapi.models.V1NodeCondition);

  public abstract A addToConditions(io.kubernetes.client.openapi.models.V1NodeCondition...);

  public abstract A addAllToConditions(java.util.Collection<io.kubernetes.client.openapi.models.V1NodeCondition>);

  public abstract A removeFromConditions(io.kubernetes.client.openapi.models.V1NodeCondition...);

  public abstract A removeAllFromConditions(java.util.Collection<io.kubernetes.client.openapi.models.V1NodeCondition>);

  public abstract A removeMatchingFromConditions(io.kubernetes.client.fluent.Predicate<io.kubernetes.client.openapi.models.V1NodeConditionBuilder>);

  public abstract java.util.List<io.kubernetes.client.openapi.models.V1NodeCondition> getConditions();

  public abstract java.util.List<io.kubernetes.client.openapi.models.V1NodeCondition> buildConditions();

  public abstract io.kubernetes.client.openapi.models.V1NodeCondition buildCondition(int);

  public abstract io.kubernetes.client.openapi.models.V1NodeCondition buildFirstCondition();

  public abstract io.kubernetes.client.openapi.models.V1NodeCondition buildLastCondition();

  public abstract io.kubernetes.client.openapi.models.V1NodeCondition buildMatchingCondition(io.kubernetes.client.fluent.Predicate<io.kubernetes.client.openapi.models.V1NodeConditionBuilder>);

  public abstract java.lang.Boolean hasMatchingCondition(io.kubernetes.client.fluent.Predicate<io.kubernetes.client.openapi.models.V1NodeConditionBuilder>);

  public abstract A withConditions(java.util.List<io.kubernetes.client.openapi.models.V1NodeCondition>);

  public abstract A withConditions(io.kubernetes.client.openapi.models.V1NodeCondition...);

  public abstract java.lang.Boolean hasConditions();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$ConditionsNested<A> addNewCondition();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$ConditionsNested<A> addNewConditionLike(io.kubernetes.client.openapi.models.V1NodeCondition);

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$ConditionsNested<A> setNewConditionLike(int, io.kubernetes.client.openapi.models.V1NodeCondition);

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$ConditionsNested<A> editCondition(int);

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$ConditionsNested<A> editFirstCondition();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$ConditionsNested<A> editLastCondition();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$ConditionsNested<A> editMatchingCondition(io.kubernetes.client.fluent.Predicate<io.kubernetes.client.openapi.models.V1NodeConditionBuilder>);

  public abstract io.kubernetes.client.openapi.models.V1NodeConfigStatus getConfig();

  public abstract io.kubernetes.client.openapi.models.V1NodeConfigStatus buildConfig();

  public abstract A withConfig(io.kubernetes.client.openapi.models.V1NodeConfigStatus);

  public abstract java.lang.Boolean hasConfig();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$ConfigNested<A> withNewConfig();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$ConfigNested<A> withNewConfigLike(io.kubernetes.client.openapi.models.V1NodeConfigStatus);

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$ConfigNested<A> editConfig();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$ConfigNested<A> editOrNewConfig();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$ConfigNested<A> editOrNewConfigLike(io.kubernetes.client.openapi.models.V1NodeConfigStatus);

  public abstract io.kubernetes.client.openapi.models.V1NodeDaemonEndpoints getDaemonEndpoints();

  public abstract io.kubernetes.client.openapi.models.V1NodeDaemonEndpoints buildDaemonEndpoints();

  public abstract A withDaemonEndpoints(io.kubernetes.client.openapi.models.V1NodeDaemonEndpoints);

  public abstract java.lang.Boolean hasDaemonEndpoints();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$DaemonEndpointsNested<A> withNewDaemonEndpoints();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$DaemonEndpointsNested<A> withNewDaemonEndpointsLike(io.kubernetes.client.openapi.models.V1NodeDaemonEndpoints);

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$DaemonEndpointsNested<A> editDaemonEndpoints();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$DaemonEndpointsNested<A> editOrNewDaemonEndpoints();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$DaemonEndpointsNested<A> editOrNewDaemonEndpointsLike(io.kubernetes.client.openapi.models.V1NodeDaemonEndpoints);

  public abstract A addToImages(int, io.kubernetes.client.openapi.models.V1ContainerImage);

  public abstract A setToImages(int, io.kubernetes.client.openapi.models.V1ContainerImage);

  public abstract A addToImages(io.kubernetes.client.openapi.models.V1ContainerImage...);

  public abstract A addAllToImages(java.util.Collection<io.kubernetes.client.openapi.models.V1ContainerImage>);

  public abstract A removeFromImages(io.kubernetes.client.openapi.models.V1ContainerImage...);

  public abstract A removeAllFromImages(java.util.Collection<io.kubernetes.client.openapi.models.V1ContainerImage>);

  public abstract A removeMatchingFromImages(io.kubernetes.client.fluent.Predicate<io.kubernetes.client.openapi.models.V1ContainerImageBuilder>);

  public abstract java.util.List<io.kubernetes.client.openapi.models.V1ContainerImage> getImages();

  public abstract java.util.List<io.kubernetes.client.openapi.models.V1ContainerImage> buildImages();

  public abstract io.kubernetes.client.openapi.models.V1ContainerImage buildImage(int);

  public abstract io.kubernetes.client.openapi.models.V1ContainerImage buildFirstImage();

  public abstract io.kubernetes.client.openapi.models.V1ContainerImage buildLastImage();

  public abstract io.kubernetes.client.openapi.models.V1ContainerImage buildMatchingImage(io.kubernetes.client.fluent.Predicate<io.kubernetes.client.openapi.models.V1ContainerImageBuilder>);

  public abstract java.lang.Boolean hasMatchingImage(io.kubernetes.client.fluent.Predicate<io.kubernetes.client.openapi.models.V1ContainerImageBuilder>);

  public abstract A withImages(java.util.List<io.kubernetes.client.openapi.models.V1ContainerImage>);

  public abstract A withImages(io.kubernetes.client.openapi.models.V1ContainerImage...);

  public abstract java.lang.Boolean hasImages();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$ImagesNested<A> addNewImage();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$ImagesNested<A> addNewImageLike(io.kubernetes.client.openapi.models.V1ContainerImage);

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$ImagesNested<A> setNewImageLike(int, io.kubernetes.client.openapi.models.V1ContainerImage);

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$ImagesNested<A> editImage(int);

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$ImagesNested<A> editFirstImage();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$ImagesNested<A> editLastImage();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$ImagesNested<A> editMatchingImage(io.kubernetes.client.fluent.Predicate<io.kubernetes.client.openapi.models.V1ContainerImageBuilder>);

  public abstract io.kubernetes.client.openapi.models.V1NodeSystemInfo getNodeInfo();

  public abstract io.kubernetes.client.openapi.models.V1NodeSystemInfo buildNodeInfo();

  public abstract A withNodeInfo(io.kubernetes.client.openapi.models.V1NodeSystemInfo);

  public abstract java.lang.Boolean hasNodeInfo();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$NodeInfoNested<A> withNewNodeInfo();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$NodeInfoNested<A> withNewNodeInfoLike(io.kubernetes.client.openapi.models.V1NodeSystemInfo);

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$NodeInfoNested<A> editNodeInfo();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$NodeInfoNested<A> editOrNewNodeInfo();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$NodeInfoNested<A> editOrNewNodeInfoLike(io.kubernetes.client.openapi.models.V1NodeSystemInfo);

  public abstract java.lang.String getPhase();

  public abstract A withPhase(java.lang.String);

  public abstract java.lang.Boolean hasPhase();

  public abstract A withNewPhase(java.lang.String);

  public abstract A withNewPhase(java.lang.StringBuilder);

  public abstract A withNewPhase(java.lang.StringBuffer);

  public abstract A addToVolumesAttached(int, io.kubernetes.client.openapi.models.V1AttachedVolume);

  public abstract A setToVolumesAttached(int, io.kubernetes.client.openapi.models.V1AttachedVolume);

  public abstract A addToVolumesAttached(io.kubernetes.client.openapi.models.V1AttachedVolume...);

  public abstract A addAllToVolumesAttached(java.util.Collection<io.kubernetes.client.openapi.models.V1AttachedVolume>);

  public abstract A removeFromVolumesAttached(io.kubernetes.client.openapi.models.V1AttachedVolume...);

  public abstract A removeAllFromVolumesAttached(java.util.Collection<io.kubernetes.client.openapi.models.V1AttachedVolume>);

  public abstract A removeMatchingFromVolumesAttached(io.kubernetes.client.fluent.Predicate<io.kubernetes.client.openapi.models.V1AttachedVolumeBuilder>);

  public abstract java.util.List<io.kubernetes.client.openapi.models.V1AttachedVolume> getVolumesAttached();

  public abstract java.util.List<io.kubernetes.client.openapi.models.V1AttachedVolume> buildVolumesAttached();

  public abstract io.kubernetes.client.openapi.models.V1AttachedVolume buildVolumesAttached(int);

  public abstract io.kubernetes.client.openapi.models.V1AttachedVolume buildFirstVolumesAttached();

  public abstract io.kubernetes.client.openapi.models.V1AttachedVolume buildLastVolumesAttached();

  public abstract io.kubernetes.client.openapi.models.V1AttachedVolume buildMatchingVolumesAttached(io.kubernetes.client.fluent.Predicate<io.kubernetes.client.openapi.models.V1AttachedVolumeBuilder>);

  public abstract java.lang.Boolean hasMatchingVolumesAttached(io.kubernetes.client.fluent.Predicate<io.kubernetes.client.openapi.models.V1AttachedVolumeBuilder>);

  public abstract A withVolumesAttached(java.util.List<io.kubernetes.client.openapi.models.V1AttachedVolume>);

  public abstract A withVolumesAttached(io.kubernetes.client.openapi.models.V1AttachedVolume...);

  public abstract java.lang.Boolean hasVolumesAttached();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$VolumesAttachedNested<A> addNewVolumesAttached();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$VolumesAttachedNested<A> addNewVolumesAttachedLike(io.kubernetes.client.openapi.models.V1AttachedVolume);

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$VolumesAttachedNested<A> setNewVolumesAttachedLike(int, io.kubernetes.client.openapi.models.V1AttachedVolume);

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$VolumesAttachedNested<A> editVolumesAttached(int);

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$VolumesAttachedNested<A> editFirstVolumesAttached();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$VolumesAttachedNested<A> editLastVolumesAttached();

  public abstract io.kubernetes.client.openapi.models.V1NodeStatusFluent$VolumesAttachedNested<A> editMatchingVolumesAttached(io.kubernetes.client.fluent.Predicate<io.kubernetes.client.openapi.models.V1AttachedVolumeBuilder>);

  public abstract A addToVolumesInUse(int, java.lang.String);

  public abstract A setToVolumesInUse(int, java.lang.String);

  public abstract A addToVolumesInUse(java.lang.String...);

  public abstract A addAllToVolumesInUse(java.util.Collection<java.lang.String>);

  public abstract A removeFromVolumesInUse(java.lang.String...);

  public abstract A removeAllFromVolumesInUse(java.util.Collection<java.lang.String>);

  public abstract java.util.List<java.lang.String> getVolumesInUse();

  public abstract java.lang.String getVolumesInUse(int);

  public abstract java.lang.String getFirstVolumesInUse();

  public abstract java.lang.String getLastVolumesInUse();

  public abstract java.lang.String getMatchingVolumesInUse(io.kubernetes.client.fluent.Predicate<java.lang.String>);

  public abstract java.lang.Boolean hasMatchingVolumesInUse(io.kubernetes.client.fluent.Predicate<java.lang.String>);

  public abstract A withVolumesInUse(java.util.List<java.lang.String>);

  public abstract A withVolumesInUse(java.lang.String...);

  public abstract java.lang.Boolean hasVolumesInUse();

  public abstract A addNewVolumesInUse(java.lang.String);

  public abstract A addNewVolumesInUse(java.lang.StringBuilder);

  public abstract A addNewVolumesInUse(java.lang.StringBuffer);
}
