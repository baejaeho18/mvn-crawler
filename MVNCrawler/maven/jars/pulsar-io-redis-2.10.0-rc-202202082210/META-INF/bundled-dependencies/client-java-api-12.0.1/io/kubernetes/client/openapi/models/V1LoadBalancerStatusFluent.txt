Compiled from "V1LoadBalancerStatusFluent.java"
public interface io.kubernetes.client.openapi.models.V1LoadBalancerStatusFluent<A extends io.kubernetes.client.openapi.models.V1LoadBalancerStatusFluent<A>> extends io.kubernetes.client.fluent.Fluent<A> {
  public abstract A addToIngress(int, io.kubernetes.client.openapi.models.V1LoadBalancerIngress);

  public abstract A setToIngress(int, io.kubernetes.client.openapi.models.V1LoadBalancerIngress);

  public abstract A addToIngress(io.kubernetes.client.openapi.models.V1LoadBalancerIngress...);

  public abstract A addAllToIngress(java.util.Collection<io.kubernetes.client.openapi.models.V1LoadBalancerIngress>);

  public abstract A removeFromIngress(io.kubernetes.client.openapi.models.V1LoadBalancerIngress...);

  public abstract A removeAllFromIngress(java.util.Collection<io.kubernetes.client.openapi.models.V1LoadBalancerIngress>);

  public abstract A removeMatchingFromIngress(io.kubernetes.client.fluent.Predicate<io.kubernetes.client.openapi.models.V1LoadBalancerIngressBuilder>);

  public abstract java.util.List<io.kubernetes.client.openapi.models.V1LoadBalancerIngress> getIngress();

  public abstract java.util.List<io.kubernetes.client.openapi.models.V1LoadBalancerIngress> buildIngress();

  public abstract io.kubernetes.client.openapi.models.V1LoadBalancerIngress buildIngress(int);

  public abstract io.kubernetes.client.openapi.models.V1LoadBalancerIngress buildFirstIngress();

  public abstract io.kubernetes.client.openapi.models.V1LoadBalancerIngress buildLastIngress();

  public abstract io.kubernetes.client.openapi.models.V1LoadBalancerIngress buildMatchingIngress(io.kubernetes.client.fluent.Predicate<io.kubernetes.client.openapi.models.V1LoadBalancerIngressBuilder>);

  public abstract java.lang.Boolean hasMatchingIngress(io.kubernetes.client.fluent.Predicate<io.kubernetes.client.openapi.models.V1LoadBalancerIngressBuilder>);

  public abstract A withIngress(java.util.List<io.kubernetes.client.openapi.models.V1LoadBalancerIngress>);

  public abstract A withIngress(io.kubernetes.client.openapi.models.V1LoadBalancerIngress...);

  public abstract java.lang.Boolean hasIngress();

  public abstract io.kubernetes.client.openapi.models.V1LoadBalancerStatusFluent$IngressNested<A> addNewIngress();

  public abstract io.kubernetes.client.openapi.models.V1LoadBalancerStatusFluent$IngressNested<A> addNewIngressLike(io.kubernetes.client.openapi.models.V1LoadBalancerIngress);

  public abstract io.kubernetes.client.openapi.models.V1LoadBalancerStatusFluent$IngressNested<A> setNewIngressLike(int, io.kubernetes.client.openapi.models.V1LoadBalancerIngress);

  public abstract io.kubernetes.client.openapi.models.V1LoadBalancerStatusFluent$IngressNested<A> editIngress(int);

  public abstract io.kubernetes.client.openapi.models.V1LoadBalancerStatusFluent$IngressNested<A> editFirstIngress();

  public abstract io.kubernetes.client.openapi.models.V1LoadBalancerStatusFluent$IngressNested<A> editLastIngress();

  public abstract io.kubernetes.client.openapi.models.V1LoadBalancerStatusFluent$IngressNested<A> editMatchingIngress(io.kubernetes.client.fluent.Predicate<io.kubernetes.client.openapi.models.V1LoadBalancerIngressBuilder>);
}
