Compiled from "RedisKeyReactiveCommands.java"
public interface io.lettuce.core.api.reactive.RedisKeyReactiveCommands<K, V> {
  public abstract reactor.core.publisher.Mono<java.lang.Long> del(K...);

  public abstract reactor.core.publisher.Mono<java.lang.Long> unlink(K...);

  public abstract reactor.core.publisher.Mono<byte[]> dump(K);

  public abstract reactor.core.publisher.Mono<java.lang.Long> exists(K...);

  public abstract reactor.core.publisher.Mono<java.lang.Boolean> expire(K, long);

  public abstract reactor.core.publisher.Mono<java.lang.Boolean> expireat(K, java.util.Date);

  public abstract reactor.core.publisher.Mono<java.lang.Boolean> expireat(K, long);

  public abstract reactor.core.publisher.Flux<K> keys(K);

  public abstract reactor.core.publisher.Mono<java.lang.Long> keys(io.lettuce.core.output.KeyStreamingChannel<K>, K);

  public abstract reactor.core.publisher.Mono<java.lang.String> migrate(java.lang.String, int, K, int, long);

  public abstract reactor.core.publisher.Mono<java.lang.String> migrate(java.lang.String, int, int, long, io.lettuce.core.MigrateArgs<K>);

  public abstract reactor.core.publisher.Mono<java.lang.Boolean> move(K, int);

  public abstract reactor.core.publisher.Mono<java.lang.String> objectEncoding(K);

  public abstract reactor.core.publisher.Mono<java.lang.Long> objectIdletime(K);

  public abstract reactor.core.publisher.Mono<java.lang.Long> objectRefcount(K);

  public abstract reactor.core.publisher.Mono<java.lang.Boolean> persist(K);

  public abstract reactor.core.publisher.Mono<java.lang.Boolean> pexpire(K, long);

  public abstract reactor.core.publisher.Mono<java.lang.Boolean> pexpireat(K, java.util.Date);

  public abstract reactor.core.publisher.Mono<java.lang.Boolean> pexpireat(K, long);

  public abstract reactor.core.publisher.Mono<java.lang.Long> pttl(K);

  public abstract reactor.core.publisher.Mono<V> randomkey();

  public abstract reactor.core.publisher.Mono<java.lang.String> rename(K, K);

  public abstract reactor.core.publisher.Mono<java.lang.Boolean> renamenx(K, K);

  public abstract reactor.core.publisher.Mono<java.lang.String> restore(K, long, byte[]);

  public abstract reactor.core.publisher.Flux<V> sort(K);

  public abstract reactor.core.publisher.Mono<java.lang.Long> sort(io.lettuce.core.output.ValueStreamingChannel<V>, K);

  public abstract reactor.core.publisher.Flux<V> sort(K, io.lettuce.core.SortArgs);

  public abstract reactor.core.publisher.Mono<java.lang.Long> sort(io.lettuce.core.output.ValueStreamingChannel<V>, K, io.lettuce.core.SortArgs);

  public abstract reactor.core.publisher.Mono<java.lang.Long> sortStore(K, io.lettuce.core.SortArgs, K);

  public abstract reactor.core.publisher.Mono<java.lang.Long> touch(K...);

  public abstract reactor.core.publisher.Mono<java.lang.Long> ttl(K);

  public abstract reactor.core.publisher.Mono<java.lang.String> type(K);

  public abstract reactor.core.publisher.Mono<io.lettuce.core.KeyScanCursor<K>> scan();

  public abstract reactor.core.publisher.Mono<io.lettuce.core.KeyScanCursor<K>> scan(io.lettuce.core.ScanArgs);

  public abstract reactor.core.publisher.Mono<io.lettuce.core.KeyScanCursor<K>> scan(io.lettuce.core.ScanCursor, io.lettuce.core.ScanArgs);

  public abstract reactor.core.publisher.Mono<io.lettuce.core.KeyScanCursor<K>> scan(io.lettuce.core.ScanCursor);

  public abstract reactor.core.publisher.Mono<io.lettuce.core.StreamScanCursor> scan(io.lettuce.core.output.KeyStreamingChannel<K>);

  public abstract reactor.core.publisher.Mono<io.lettuce.core.StreamScanCursor> scan(io.lettuce.core.output.KeyStreamingChannel<K>, io.lettuce.core.ScanArgs);

  public abstract reactor.core.publisher.Mono<io.lettuce.core.StreamScanCursor> scan(io.lettuce.core.output.KeyStreamingChannel<K>, io.lettuce.core.ScanCursor, io.lettuce.core.ScanArgs);

  public abstract reactor.core.publisher.Mono<io.lettuce.core.StreamScanCursor> scan(io.lettuce.core.output.KeyStreamingChannel<K>, io.lettuce.core.ScanCursor);
}
