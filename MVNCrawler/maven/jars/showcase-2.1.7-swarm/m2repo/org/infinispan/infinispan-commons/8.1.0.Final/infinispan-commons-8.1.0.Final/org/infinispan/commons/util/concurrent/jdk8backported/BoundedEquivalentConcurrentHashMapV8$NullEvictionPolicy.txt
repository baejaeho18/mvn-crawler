Compiled from "BoundedEquivalentConcurrentHashMapV8.java"
class org.infinispan.commons.util.concurrent.jdk8backported.BoundedEquivalentConcurrentHashMapV8$NullEvictionPolicy<K, V> implements org.infinispan.commons.util.concurrent.jdk8backported.BoundedEquivalentConcurrentHashMapV8$EvictionPolicy<K, V> {
  private final org.infinispan.commons.util.concurrent.jdk8backported.BoundedEquivalentConcurrentHashMapV8$NodeEquivalence<K, V> nodeEq;

  public org.infinispan.commons.util.concurrent.jdk8backported.BoundedEquivalentConcurrentHashMapV8$NullEvictionPolicy(org.infinispan.commons.util.concurrent.jdk8backported.BoundedEquivalentConcurrentHashMapV8$NodeEquivalence<K, V>);
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: aload_0
       5: aload_1
       6: putfield      #2                  // Field nodeEq:Lorg/infinispan/commons/util/concurrent/jdk8backported/BoundedEquivalentConcurrentHashMapV8$NodeEquivalence;
       9: return

  public void onEntryMiss(org.infinispan.commons.util.concurrent.jdk8backported.BoundedEquivalentConcurrentHashMapV8$Node<K, V>, V);
    Code:
       0: return

  public void onEntryRemove(org.infinispan.commons.util.concurrent.jdk8backported.BoundedEquivalentConcurrentHashMapV8$Node<K, V>);
    Code:
       0: return

  public org.infinispan.commons.util.concurrent.jdk8backported.BoundedEquivalentConcurrentHashMapV8$Node<K, V> createNewEntry(K, int, org.infinispan.commons.util.concurrent.jdk8backported.BoundedEquivalentConcurrentHashMapV8$Node<K, V>, V, org.infinispan.commons.util.concurrent.jdk8backported.BoundedEquivalentConcurrentHashMapV8$EvictionEntry<K, V>);
    Code:
       0: new           #3                  // class org/infinispan/commons/util/concurrent/jdk8backported/BoundedEquivalentConcurrentHashMapV8$Node
       3: dup
       4: iload_2
       5: aload_0
       6: getfield      #2                  // Field nodeEq:Lorg/infinispan/commons/util/concurrent/jdk8backported/BoundedEquivalentConcurrentHashMapV8$NodeEquivalence;
       9: aload_1
      10: aload         4
      12: aload_3
      13: invokespecial #4                  // Method org/infinispan/commons/util/concurrent/jdk8backported/BoundedEquivalentConcurrentHashMapV8$Node."<init>":(ILorg/infinispan/commons/util/concurrent/jdk8backported/BoundedEquivalentConcurrentHashMapV8$NodeEquivalence;Ljava/lang/Object;Ljava/lang/Object;Lorg/infinispan/commons/util/concurrent/jdk8backported/BoundedEquivalentConcurrentHashMapV8$Node;)V
      16: areturn

  public org.infinispan.commons.util.concurrent.jdk8backported.BoundedEquivalentConcurrentHashMapV8$TreeNode<K, V> createNewEntry(K, int, org.infinispan.commons.util.concurrent.jdk8backported.BoundedEquivalentConcurrentHashMapV8$TreeNode<K, V>, org.infinispan.commons.util.concurrent.jdk8backported.BoundedEquivalentConcurrentHashMapV8$TreeNode<K, V>, V, org.infinispan.commons.util.concurrent.jdk8backported.BoundedEquivalentConcurrentHashMapV8$EvictionEntry<K, V>);
    Code:
       0: new           #5                  // class org/infinispan/commons/util/concurrent/jdk8backported/BoundedEquivalentConcurrentHashMapV8$TreeNode
       3: dup
       4: iload_2
       5: aload_0
       6: getfield      #2                  // Field nodeEq:Lorg/infinispan/commons/util/concurrent/jdk8backported/BoundedEquivalentConcurrentHashMapV8$NodeEquivalence;
       9: aload_1
      10: aload         5
      12: aload_3
      13: aload         4
      15: aload         6
      17: invokespecial #6                  // Method org/infinispan/commons/util/concurrent/jdk8backported/BoundedEquivalentConcurrentHashMapV8$TreeNode."<init>":(ILorg/infinispan/commons/util/concurrent/jdk8backported/BoundedEquivalentConcurrentHashMapV8$NodeEquivalence;Ljava/lang/Object;Ljava/lang/Object;Lorg/infinispan/commons/util/concurrent/jdk8backported/BoundedEquivalentConcurrentHashMapV8$Node;Lorg/infinispan/commons/util/concurrent/jdk8backported/BoundedEquivalentConcurrentHashMapV8$TreeNode;Lorg/infinispan/commons/util/concurrent/jdk8backported/BoundedEquivalentConcurrentHashMapV8$EvictionEntry;)V
      20: areturn

  public java.util.Set<org.infinispan.commons.util.concurrent.jdk8backported.BoundedEquivalentConcurrentHashMapV8$Node<K, V>> findIfEntriesNeedEvicting();
    Code:
       0: invokestatic  #7                  // Method org/infinispan/commons/util/InfinispanCollections.emptySet:()Ljava/util/Set;
       3: areturn

  public void onEntryHitRead(org.infinispan.commons.util.concurrent.jdk8backported.BoundedEquivalentConcurrentHashMapV8$Node<K, V>, V);
    Code:
       0: return

  public void onEntryHitWrite(org.infinispan.commons.util.concurrent.jdk8backported.BoundedEquivalentConcurrentHashMapV8$Node<K, V>, V);
    Code:
       0: return

  public void onResize(long, long);
    Code:
       0: return

  public void resize(long);
    Code:
       0: return

  public java.util.Collection findIfEntriesNeedEvicting();
    Code:
       0: aload_0
       1: invokevirtual #8                  // Method findIfEntriesNeedEvicting:()Ljava/util/Set;
       4: areturn
}
